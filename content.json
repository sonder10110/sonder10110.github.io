{"posts":[{"title":"多维动态规划","text":"","link":"/%E5%8A%9B%E6%89%A3/%E5%8A%9B%E6%89%A3%E7%83%AD%E9%97%A8100/%E5%A4%9A%E7%BB%B4%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/LC100-MDdp/"},{"title":"回溯","text":"","link":"/%E5%8A%9B%E6%89%A3/%E5%8A%9B%E6%89%A3%E7%83%AD%E9%97%A8100/%E5%9B%9E%E6%BA%AF/LC100-backtrack/"},{"title":"数组","text":"","link":"/%E5%8A%9B%E6%89%A3/%E5%8A%9B%E6%89%A3%E7%83%AD%E9%97%A8100/%E6%95%B0%E7%BB%84/LC100-array/"},{"title":"二叉树","text":"","link":"/%E5%8A%9B%E6%89%A3/%E5%8A%9B%E6%89%A3%E7%83%AD%E9%97%A8100/%E4%BA%8C%E5%8F%89%E6%A0%91/LC100-binary-tree/"},{"title":"二分查找","text":"","link":"/%E5%8A%9B%E6%89%A3/%E5%8A%9B%E6%89%A3%E7%83%AD%E9%97%A8100/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/LC100-binary-search/"},{"title":"动态规划","text":"","link":"/%E5%8A%9B%E6%89%A3/%E5%8A%9B%E6%89%A3%E7%83%AD%E9%97%A8100/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/LC100-dp/"},{"title":"双指针","text":"","link":"/%E5%8A%9B%E6%89%A3/%E5%8A%9B%E6%89%A3%E7%83%AD%E9%97%A8100/%E5%8F%8C%E6%8C%87%E9%92%88/LC100-dual-pointer/"},{"title":"贪心算法","text":"","link":"/%E5%8A%9B%E6%89%A3/%E5%8A%9B%E6%89%A3%E7%83%AD%E9%97%A8100/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/LC100-greedy/"},{"title":"图论","text":"","link":"/%E5%8A%9B%E6%89%A3/%E5%8A%9B%E6%89%A3%E7%83%AD%E9%97%A8100/%E5%9B%BE%E8%AE%BA/LC100-graph/"},{"title":"链表","text":"","link":"/%E5%8A%9B%E6%89%A3/%E5%8A%9B%E6%89%A3%E7%83%AD%E9%97%A8100/%E9%93%BE%E8%A1%A8/LC100-linked-list/"},{"title":"堆","text":"","link":"/%E5%8A%9B%E6%89%A3/%E5%8A%9B%E6%89%A3%E7%83%AD%E9%97%A8100/%E5%A0%86/LC100-heap/"},{"title":"矩阵","text":"","link":"/%E5%8A%9B%E6%89%A3/%E5%8A%9B%E6%89%A3%E7%83%AD%E9%97%A8100/%E7%9F%A9%E9%98%B5/LC100-matrix/"},{"title":"滑动窗口","text":"","link":"/%E5%8A%9B%E6%89%A3/%E5%8A%9B%E6%89%A3%E7%83%AD%E9%97%A8100/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/LC100-sliding-window/"},{"title":"技巧","text":"","link":"/%E5%8A%9B%E6%89%A3/%E5%8A%9B%E6%89%A3%E7%83%AD%E9%97%A8100/%E6%8A%80%E5%B7%A7/LC100-skill/"},{"title":"栈","text":"","link":"/%E5%8A%9B%E6%89%A3/%E5%8A%9B%E6%89%A3%E7%83%AD%E9%97%A8100/%E6%A0%88/LC100-stack/"},{"title":"子串","text":"","link":"/%E5%8A%9B%E6%89%A3/%E5%8A%9B%E6%89%A3%E7%83%AD%E9%97%A8100/%E5%AD%90%E4%B8%B2/LC100-substring/"},{"title":"力扣热门100JAVA版","text":"基础操作 put(K key, V value)：将指定的键值对插入到 HashMap 中，若键已存在，则更新值。 get(Object key)：根据键获取值，如果不存在该键，返回 null。 remove(Object key)：根据键删除键值对。 containsKey(Object key)：检查是否包含指定的键。 containsValue(Object value)：检查是否包含指定的值。 size()：返回 HashMap 中键值对的数量。 isEmpty()：检查 HashMap 是否为空。 keySet()：返回所有键的集合。 values()：返回所有值的集合。 entrySet()：返回 HashMap 中所有键值对的 Set 集合。 clear()：清空所有元素。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import java.util.HashMap;import java.util.Map;public class HashMapExample { public static void main(String[] args) { // 创建 HashMap 实例 HashMap&lt;String, Integer&gt; map = new HashMap&lt;&gt;(); // 1. put() - 添加或更新元素 map.put(&quot;apple&quot;, 1); // key = &quot;apple&quot;, value = 1 map.put(&quot;banana&quot;, 2); // key = &quot;banana&quot;, value = 2 map.put(&quot;orange&quot;, 3); // key = &quot;orange&quot;, value = 3 // 2. get() - 获取元素 System.out.println(&quot;Value for key 'apple': &quot; + map.get(&quot;apple&quot;)); // 输出 1 // 3. containsKey() - 检查是否包含某个键 System.out.println(&quot;Contains key 'banana': &quot; + map.containsKey(&quot;banana&quot;)); // 输出 true // 4. containsValue() - 检查是否包含某个值 System.out.println(&quot;Contains value 2: &quot; + map.containsValue(2)); // 输出 true // 5. remove() - 删除某个键值对 map.remove(&quot;banana&quot;); System.out.println(&quot;After removing 'banana': &quot; + map); // 6. size() - 获取大小 System.out.println(&quot;Size of map: &quot; + map.size()); // 输出 2 // 7. isEmpty() - 检查是否为空 System.out.println(&quot;Is map empty? &quot; + map.isEmpty()); // 输出 false // 8. keySet() - 获取所有的键 System.out.println(&quot;All keys: &quot; + map.keySet()); // 输出 [apple, orange] // 9. values() - 获取所有的值 System.out.println(&quot;All values: &quot; + map.values()); // 输出 [1, 3] // 10. entrySet() - 获取所有的键值对 for (Map.Entry&lt;String, Integer&gt; entry : map.entrySet()) { System.out.println(entry.getKey() + &quot;: &quot; + entry.getValue()); } // 11. clear() - 清空所有元素 map.clear(); System.out.println(&quot;After clearing map: &quot; + map); // 输出 {} }} 1. 两数之和 12345678910111213class Solution { public int[] twoSum(int[] nums, int target) { HashMap&lt;Integer, Integer&gt; mp = new HashMap&lt;&gt;(); for (int i = 0; i &lt; nums.length; i++){ int temp = target - nums[i]; if (mp.containsKey(temp)){ return new int[]{mp.get(temp), i}; } mp.put(nums[i], i); } return new int[0]; }} 49. 字母异位词分组 128. 最长连续序列 1234567891011121314151617181920212223class Solution { public int longestConsecutive(int[] nums) { Set&lt;Integer&gt; num_set = new HashSet&lt;Integer&gt;(); for (int num : nums){ num_set.add(num); } int ans = 0; for (int num : num_set){ if (!num_set.contains(num - 1)){ int cur = num; int temp = 1; while (num_set.contains(cur + 1)){ cur++; temp++; } ans = Math.max(ans, temp); } } return ans; }}","link":"/%E5%8A%9B%E6%89%A3/%E5%8A%9B%E6%89%A3%E7%83%AD%E9%97%A8100/%E5%93%88%E5%B8%8C/LChot100/"},{"title":"人月神话","text":"&quot;success without applause, diligence without reward&quot;. 关于管理大型的计算机编程项目。 第一章 焦油坑 The Tar Pit &quot;A ship on the beach is a lighthouse to the sea.&quot;前车之覆，后车之鉴。 大型项目开发-&gt;焦油坑。 编程系统产品 程序、编程系统（接口、系统集成）、编程产品（通用化、测试、文档、维护）、编程系统产品（目标） 职业的乐趣 创建事物、开发有用的东西、组件组装、持续学习、神奇且灵活的创造 职业的苦恼 追求完美 设定的目标、供给资源、提供信息 依赖于他人（无可避免的，就像我讨厌让我写注释的，也讨厌别人不写注释的） 琐碎的bug、调试和查错 完成后陈旧过时... 第二章 人月神话 The Mythical Man Month &quot;Good cooking takes time. If you are made to wait, it is to serve you better, and to please you.&quot; 缺乏合理的进度安排 -&gt; 项目滞后 乐观主义 年轻的程序员。一切都将运作良好，每一项任务仅花费它所”应该“花费的时间。 创造性活动有三个阶段：构思、实现、交流。而计算机编程基于十分容易掌握的介质，加重了乐观主义。构思总是有缺陷的，总会有各种各样的bug存在。 在单个任务中，”一切都将运作良好“是可能的，但当进行大型的编程工作时，任务数目多，且存在先后次序，导致一切正常的概率几近于零。 人月 错误的估计和进度安排中的工作量：人月。 对于成本，确实是可以以人月计，但进度并非如此。 用人月作为衡量一项项目的规模是一个危险和带有欺骗性的神话。 人数与时间仅仅在参与人员间不需要任何相互交流时可行。当任务由于次序限制无法分解时，添加人手不会对进度有帮助。 沟通增加的负担：培训和相互的交流。 月-人的关系图会呈v字形，也就是增加人数，耗时反而会增加。 系统测试 单元测试和系统测试受顺序限制最大。且时间难以估计。 时间占比 任务 1/3 计划 1/6 编码 1/4 构件测试和早期系统测试 1/4 所有构件已完成，系统测试 空泛的估算 为了满足客户需求，造成不合理的进度安排。 重复产生的进度灾难 当项目落后于进度时，增加人手、重新安排进度、削减任务都是可能的选择。 &quot;Adding manpower to a late software project makes it later.&quot; --- Brooks法则，项目的时间依赖于顺序上的限制、人员的最大数量依赖于独立子任务的数量。 第三章 外科手术队伍 如何在有意义的进度安排内创建大型的系统？ 问题 在优秀程序员和较差程序员之间存在生产率的差异。沟通增加的负担：培训和相互的交流以及更正沟通不当所引起的不良结果（系统调试）。 进退两难的境地：对于效率和概念的完整性来说，最好由少数干练的人员来设计和开发，而对于大型系统则需要大量人手，以使产品能在时间上满足要求。 Mills的建议 建议大型项目的每一个部分由一个团队解决，以类似外科手术队伍的方式组建，而非一拥而上。也就是说，同每个成员截取问题某个部分的做法相反，由一个人来完成问题的分解，其他人给予他所需要的支持以提高效率和生产力。 外科队伍 项目人员 职能 外科医生 首席程序员 定义功能和性能技术说明书，设计程序，编制源代码，测试，书写技术文档。 后备 副手 能完成任何一部分工作，但相对经验较少。主要作为设计的思考者、讨论者和评估人员。充当外科医生的保险机制。 老板 管理员 在人员、薪酬、办公室等方面具有决定权，但不能在这些方面浪费任何时间。需要有一个控制财务、人员、工作地点、办公设备的专业人员，充当与组织中其他管理机构的接口。可以服务两个团队。 编辑 考虑透明度，外科医生必须创建各种文档，编辑则根据草稿或口述进行重新分析和重新组织，提供各种参考信息和书目，对多个版本进行维护，并监督文档生成的机制。 文秘*2 管理员和编辑各一个。管理员的文秘负责非产品文件和项目协作一致。 程序职员 负责维护编程产品库中所有团队的技术记录。 工具维护人员 保证所有基本服务的可靠性，承担团队成员所需要的特殊工具（尤其是交互式计算机服务）的构建、维护和升级责任。 测试人员 设计测试用例、负责计划测试的步骤和为单元测试搭建测试平台。 语言专家 寻找一种简洁有效的使用语言的方法来解决复杂、晦涩、棘手的问题。 Mills概念的关键是“从个人艺术到公共实践”的编程观念转换。 如何运作 上述团队中7个专业人士在解决问题，而系统是一个人或两个人思考的产物，在客观上达到了概念的一致性。下图为10人程序开发队伍的沟通模式 团队的扩建 当面对大型任务时，该如何应用外科手术团队的概念呢？ 关键在于提高每个部分的概念完整性。 第四章 贵族专制、民主政治和系统设计 Aristocracy、Democracy and System Design 概念的完整性 哥特式教堂上依附着诺曼底风格的十字架——上帝的荣耀、建筑师的骄傲 概念完整性在系统设计中是很重要的因素，为了反映一系列连贯的设计思路，宁可省略一些不规则的特性和改进，也不提倡独立和无法整合的系统。 获得概念的完整性 简洁和直白来自概念的完整性，每个部分必须反映相同的原理需求的一致平衡。在语法上，每个部分应使用相同的技巧；在语义上，应具有同样的相似性。因此，易用性需要设计的一致性和概念上的完整性。 贵族专制统治和民主政治 系统的体系结构是指完整和详细的用户接口说明。如Blaauw所说，体系结构陈述的是发生了什么，而实现描述的是如何实现。本书中的体系结构更偏向于现今的需求概念，而业界广泛认为的体系结构是系统的框架，属于设计层次。 结构师-&gt;贵族 是贵族专制统治，而非民主政治。 在等待时，实现人员应该做什么 整个创造性活动包括三个独立的阶段：体系结构(architecture)、设计实现(implementation)、物理实现(realization)。实际情况中，他们可以同时开始和并发地进行。 第五章 画蛇添足 The Second-System Effect Adde parvum parvo magnus acervus erit.聚沙成塔，集腋成裘。 将制定功能规格说明的责任从开发快速、成本低廉的产品的责任中分离出来，有什么准则和机制来约束结构师的创造性热情呢？ 结构师的交互准则和机制 牢记是开发人员承担创造性和发明性的实现责任，所以结构师只能建议而不能支配； 时刻准备着为所指定的说明建议一种实现的方法，同样准备接受其他任何能达到目标的方法； 对上述的建议保持低调和不公开； 准备放弃坚持所作的改进建议。 自律——开发第二个系统所带来的后果 结构师在开发第一个系统时更倾向于精炼和简洁。他知道自己对任务不够了解。 而设计第一个项目时，会有不断产生的装饰和润色功能。这些功能被暂时搁置，作为下一个项目的内容。当开发第二个系统时，信心满满。但是当着手第三个或者第四个系统时，先前的经验会相互验证，得到对此类系统通用特性的判断，而且系统之间的差异会帮助他识别出经验中不够通用的部分。一种普遍的倾向是过分地设计第二个系统。但添加的修饰功能和想法是一个“大馅饼”。 第六章 贯彻执行 文档化的规格说明——手册 形式化定义 直接整合 会议和大会 多重实现 电话日志 产品测试 第七章 为什么巴比伦塔会失败 巴比伦塔的管理教训 大型编程项目中的交流 项目工作手册 大型编程项目的组织架构 第八章 胸有成竹 Portman的数据 Aron的数据 Harr的数据 OS/360的数据 Corbato的数据 第九章 削足适履 作为成本的程序空间 规模控制 空间技能 数据的表现形式是编程的根本 第十章 提纲挈领 计算机产品的文档 大学科系的文档 软件项目的文档 为什么要有正式的文档 第十一章 未雨绸缪 试验性工厂和增大规模 唯一不变的就是变化本身 为变更设计系统 为变更计划组织架构 前进两步，后退一步 前进一步，后退一步 第十二章 干将莫邪 目标机器 辅助机器和数据服务 高级语言和交互式编程 第十三章 整体部分 提出bug的设计 构件单元测试 系统集成调试 第十四章 祸起萧墙 里程碑还是沉重的负担 “其他的部分反正会落后” 地毯的下面 第十五章 另外一面 需要什么样的文档 流程图 自文档化的程序 第十六章 没有银弹 摘要 介绍 根本困难 以往解决次要困难的一些突破 银弹的希望 针对概念上根本问题的颇具前途的方法 第十七章 再论“没有银弹” 人狼和其他恐怖传说 存在着银弹——就在这里 含糊的表达将会导致误解 Harel的分析 Jones的观点——质量带来生产率 那么，生产率的情形如何 面向对象编程——这颗铜质子弹可以吗 重用的情况怎样 学习大量的词汇——对软件重用的一个可预见但还没有被预言的问题 子弹的本质——形势没用发生改变 第十八章 《人月神话》的观点：是与非 第一章 焦油坑 The Tar Pit 第二章 人月神话 The Mythical Man Month 第三章 外科手术队伍 第四章 贵族专制、民主政治和系统设计 第五章 画蛇添足 第六章 贯彻执行 第七章 为什么巴比伦塔会失败 第八章 胸有成竹 第九章 削足适履 第十章 提纲挈领 第十一章 未雨绸缪! 第十二章 干将莫邪 第十三章 整体部分 第十四章 祸起萧墙 第十五章 另外一面 第一版结束语 第十九章 20年后的《人月神话》 为什么要出版20周年纪念版本 核心观点——概念完整性和结构师 开发第二个系统所引起的后果——盲目的功能和频率猜测 图形界面的成功 没有构建舍弃模型——瀑布模型是错误的 增量开发模型更佳——渐进地精化","link":"/%E8%AF%BB%E4%B9%A6/%E4%BA%BA%E6%9C%88%E7%A5%9E%E8%AF%9D/The-Mythical-Man-Month/"},{"title":"LRU与LFU缓存","text":"LRU与LFU缓存替换策略 LRU（Least Recently Used，最少最近使用）和 LFU（Least Frequently Used，最不经常使用）是两种常用的缓存替换策略，用于决定缓存中哪些项应该被淘汰。它们的实现和应用场景非常广泛，特别是在内存管理、数据库缓存和操作系统中。 LRU (Least Recently Used) 最少最近使用 LRU 策略用于在缓存满了时，淘汰最久没有使用的数据。即：每当一个缓存项被访问时，它就被认为是“最近使用”的，最少使用的缓存项就会被替换。 题目描述:设计并实现一个满足LRU最近最少使用缓存约束的数据结构。 实现LRUCache类： LRUCache (int capacity)以 正整数 作为容量 capacity 初始化 LRU 缓存 int get(int key) 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。 void put(int key, int value)如果关键字 key 已经存在，则变更其数据值 value ；如果不存在，则向缓存中插入该组 key-value 。如果插入操作导致关键字数量超过 capacity ，则应该 逐出 最久未使用的关键字。 函数get和put必须以O(1)的平均时间复杂度运行。} 思路： 每次访问缓存时，将该缓存项标记为“最近使用”。 当缓存满时，淘汰最久未被访问的缓存项。 实现方法： LRU 可以通过 双向链表 和 哈希表 来实现： 哈希表 用于快速访问缓存项。 双向链表 用于维护缓存项的使用顺序，最近访问的项放在链表头，最久未访问的项放在链表尾。 LRU 实现步骤： 哈希表：存储缓存的键值对，键是缓存的键，值是缓存项（值和最近使用的顺序）。 双向链表：存储缓存项的顺序，最近访问的缓存项放在头部，最久未访问的放在尾部。 插入和删除：每次访问缓存项时，将该项移动到链表头；如果缓存满了，移除链表尾部的项。 12345678910111213141516171819202122232425262728293031323334353637383940import java.util.*;class LRUCache { private int capacity; private Map&lt;Integer, Integer&gt; cache; private LinkedHashMap&lt;Integer, Long&gt; accessOrder; public LRUCache(int capacity) { this.capacity = capacity; this.cache = new HashMap&lt;&gt;(); this.accessOrder = new LinkedHashMap&lt;&gt;(capacity, 0.75f, true); // true 表示访问顺序 } public int get(int key) { if (!cache.containsKey(key)) { return -1; } // 更新访问顺序 accessOrder.put(key, System.nanoTime()); return cache.get(key); } public void put(int key, int value) { if (cache.size() &gt;= capacity) { // 找到最少使用的键 long leastUsedTime = Long.MAX_VALUE; int keyToRemove = -1; for (Map.Entry&lt;Integer, Long&gt; entry : accessOrder.entrySet()) { if (entry.getValue() &lt; leastUsedTime) { leastUsedTime = entry.getValue(); keyToRemove = entry.getKey(); } } // 移除最少使用的项 cache.remove(keyToRemove); accessOrder.remove(keyToRemove); } cache.put(key, value); accessOrder.put(key, System.nanoTime()); }}} 但这么写 过不了力扣...... 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273class LRUCache { // Node 类表示链表中的每个节点 private static class Node { int key, value; // 存储 key 和 value Node prev, next; // 前后指针，用于双向链表 Node(int k, int v) { // 构造函数初始化 key 和 value key = k; value = v; } } private final int capacity; // 缓存的最大容量 private final Node dummy = new Node(0, 0); // 哑节点，用于简化双向链表操作（头节点） private final Map&lt;Integer, Node&gt; keyToNode = new HashMap&lt;&gt;(); // 用于存储缓存中每个 key 对应的节点 // 构造函数初始化容量，并且初始化双向链表的 dummy 节点 public LRUCache(int capacity) { this.capacity = capacity; dummy.prev = dummy; // 哑节点的 prev 指向自己 dummy.next = dummy; // 哑节点的 next 指向自己 } // 获取缓存中某个 key 对应的 value public int get(int key) { Node node = getNode(key); // 查找 key 对应的节点 return node != null ? node.value : -1; // 如果找到节点，返回节点的值，否则返回 -1（表示不存在） } // 向缓存中插入新的 key-value 对 public void put(int key, int value) { Node node = getNode(key); // 查找 key 对应的节点 if (node != null) { // 如果节点存在，更新节点的值 node.value = value; return; // 直接返回，无需做其他操作 } // 如果节点不存在，创建一个新的节点并插入到缓存中 node = new Node(key, value); keyToNode.put(key, node); // 将新节点存入哈希表 pushFront(node); // 将新节点移动到链表的头部，表示最近使用 // 如果缓存的大小超过了容量，移除最不常用的节点（尾部节点） if (keyToNode.size() &gt; capacity) { Node backNode = dummy.prev; // 获取尾部节点（最久未使用的节点） keyToNode.remove(backNode.key); // 从哈希表中移除该节点 remove(backNode); // 从链表中移除该节点 } } // 根据 key 获取对应的节点 private Node getNode(int key) { if (!keyToNode.containsKey(key)) return null; // 如果 key 不存在，返回 null Node node = keyToNode.get(key); // 获取节点 remove(node); // 从链表中移除该节点 pushFront(node); // 将该节点移到链表头部，表示它是最新使用的 return node; // 返回节点 } // 从链表中移除指定的节点 private void remove(Node x) { x.prev.next = x.next; // 将前一个节点的 next 指向当前节点的下一个节点 x.next.prev = x.prev; // 将下一个节点的 prev 指向当前节点的前一个节点 } // 将指定的节点插入到链表头部 private void pushFront(Node x) { x.prev = dummy; // 新节点的 prev 指向哑节点 x.next = dummy.next; // 新节点的 next 指向哑节点的下一个节点 x.prev.next = x; // 哑节点的 next 指向新节点 x.next.prev = x; // 新节点的 next 节点的 prev 指向新节点 }}} LFU (Least Frequently Used) 最不经常使用 LFU 策略用于淘汰访问频率最低的缓存项。即：每次访问缓存时，缓存项的访问次数增加。缓存满时，淘汰访问次数最少的缓存项。 思路： 每个缓存项都有一个访问频率：当访问缓存时，增加该项的频率。 淘汰策略：当缓存满时，淘汰频率最低的缓存项。若频率相同，则淘汰最早添加的缓存项。 实现方法： LFU 通常使用 哈希表 和 最小堆（或 哈希表+双向链表）来实现。 哈希表 用于存储缓存的键值对。 频率表：哈希表将缓存项的访问次数作为键，缓存项列表作为值（即频率与缓存项的映射关系）。 最小堆：或者使用优先队列来管理访问频率，以便快速找到访问次数最少的缓存项。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364import java.util.*;class LFUCache { private int capacity; private Map&lt;Integer, Integer&gt; values; private Map&lt;Integer, Integer&gt; frequencies; private Map&lt;Integer, LinkedHashSet&lt;Integer&gt;&gt; freqList; private int minFreq; public LFUCache(int capacity) { this.capacity = capacity; this.values = new HashMap&lt;&gt;(); this.frequencies = new HashMap&lt;&gt;(); this.freqList = new HashMap&lt;&gt;(); this.minFreq = -1; } public int get(int key) { if (!values.containsKey(key)) { return -1; } int freq = frequencies.get(key); frequencies.put(key, freq + 1); freqList.get(freq).remove(key); if (freqList.get(freq).isEmpty()) { if (minFreq == freq) { minFreq++; } freqList.remove(freq); } freqList.putIfAbsent(freq + 1, new LinkedHashSet&lt;&gt;()); freqList.get(freq + 1).add(key); return values.get(key); } public void put(int key, int value) { if (capacity &lt;= 0) return; if (values.containsKey(key)) { values.put(key, value); get(key); // 更新频率 return; } if (values.size() &gt;= capacity) { // 淘汰最少频次的缓存项 int evictKey = freqList.get(minFreq).iterator().next(); freqList.get(minFreq).remove(evictKey); if (freqList.get(minFreq).isEmpty()) { freqList.remove(minFreq); } values.remove(evictKey); frequencies.remove(evictKey); } values.put(key, value); frequencies.put(key, 1); minFreq = 1; freqList.putIfAbsent(1, new LinkedHashSet&lt;&gt;()); freqList.get(1).add(key); }}} 主要思路： 频率管理：用一个哈希表 freqToDummy 存储每个访问频率对应的链表，链表的头部代表最近访问的节点，尾部代表最久未访问的节点。 双向链表：为每个访问频率维护一个双向链表，这样可以高效地管理节点的顺序，并能在常数时间内删除最不常使用的节点。 最小频率：minFreq 变量用于记录当前缓存中的最小访问频率。每当访问一个节点时，如果该节点的访问频率变化，并且该频率链表变为空，我们需要更新 minFreq。 核心操作： get 操作：查找并返回缓存中 key 对应的值，同时将该节点的访问频率加 1，并将其移动到新的频率链表中。 put 操作：如果缓存已满，先移除访问频率最少的节点。然后将新节点插入到频率为 1 的链表中，并设置 minFreq 为 1。 节点的移动：每次访问或插入时，节点会根据其访问频率被移动到对应的链表头部，从而保证频率最低的节点最先被淘汰。 性能分析： 时间复杂度：每个操作（get、put、remove、pushFront）都可以在 O(1) 时间内完成，因为链表操作和哈希表操作的时间复杂度是 O(1)。 空间复杂度：空间复杂度是 O(capacity)，因为我们只在缓存中存储最多 capacity 个节点。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899class LFUCache { // Node 类表示链表中的每个节点 private static class Node { int key, value, freq = 1; // key 是键，value 是值，freq 是访问频率，初始化为 1 Node prev, next; // prev 和 next 是双向链表的指针 Node(int key, int value) { // 构造函数初始化 key 和 value this.key = key; this.value = value; } } private final int capacity; // 缓存的最大容量 private final Map&lt;Integer, Node&gt; keyToNode = new HashMap&lt;&gt;(); // 存储缓存的 key -&gt; Node 映射 private final Map&lt;Integer, Node&gt; freqToDummy = new HashMap&lt;&gt;(); // 存储频率 -&gt; 哑节点（代表链表头） private int minFreq; // 记录当前缓存中的最小访问频率 // 构造函数初始化缓存容量 public LFUCache(int capacity) { this.capacity = capacity; } // 获取缓存中指定 key 对应的值 public int get(int key) { Node node = getNode(key); // 获取节点 return node != null ? node.value : -1; // 如果节点存在，返回其值，否则返回 -1 } // 向缓存中插入新的 key-value 对 public void put(int key, int value) { Node node = getNode(key); // 尝试从缓存中获取该节点 if (node != null) { // 如果节点已经存在，更新其值 node.value = value; return; } // 如果缓存已满，则删除访问频率最少的元素 if (keyToNode.size() == capacity) { Node dummy = freqToDummy.get(minFreq); // 获取最小频率的链表 Node backNode = dummy.prev; // 获取该链表中的最旧节点 keyToNode.remove(backNode.key); // 从哈希表中移除该节点 remove(backNode); // 从链表中移除该节点 if (dummy.prev == dummy) { // 如果该链表为空 freqToDummy.remove(minFreq); // 移除该频率的链表 } } // 创建新节点并放入缓存 node = new Node(key, value); keyToNode.put(key, node); // 添加到 keyToNode 哈希表 pushFront(1, node); // 将新节点放入频率为 1 的链表中（即最上面） minFreq = 1; // 更新最小频率为 1 } // 获取指定 key 对应的节点，并将其访问频率加 1 private Node getNode(int key) { if (!keyToNode.containsKey(key)) { // 如果没有该 key return null; } Node node = keyToNode.get(key); // 获取节点 remove(node); // 从链表中移除该节点 Node dummy = freqToDummy.get(node.freq); // 获取当前频率对应的链表 if (dummy.prev == dummy) { // 如果当前频率的链表为空 freqToDummy.remove(node.freq); // 移除该频率的链表 if (minFreq == node.freq) { // 如果当前频率是最小频率 minFreq++; // 增加最小频率 } } // 增加访问频率，并将节点放入新的频率链表的最上面 pushFront(++node.freq, node); return node; // 返回节点 } // 创建一个新的双向链表（每个频率的链表） private Node newList() { Node dummy = new Node(0, 0); // 哑节点作为双向链表的头节点 dummy.prev = dummy; dummy.next = dummy; return dummy; } // 将节点添加到指定频率的链表头部（表示该节点最近被访问） private void pushFront(int freq, Node x) { Node dummy = freqToDummy.computeIfAbsent(freq, k -&gt; newList()); // 获取该频率对应的链表头（如果不存在则创建） x.prev = dummy; // 将节点的 prev 指向该频率链表的头 x.next = dummy.next; // 将节点的 next 指向该频率链表的第一个节点 x.prev.next = x; // 连接节点到链表头 x.next.prev = x; // 连接节点到链表的下一个节点 } // 从链表中删除一个节点 private void remove(Node x) { x.prev.next = x.next; // 删除节点的前后节点的连接 x.next.prev = x.prev; // 删除节点的前后节点的连接 }}}","link":"/%E7%AE%97%E6%B3%95/LRU%E4%B8%8ELFU%E7%BC%93%E5%AD%98%E6%9B%BF%E6%8D%A2/algorithm-fundamentals/"},{"title":"STtable","text":"ST表 P3865 【模板】ST 表 &amp;&amp; RMQ 问题 - 洛谷 | 计算机科学教育新生态 静态区间最大值 给定一个长度为 N 的数列，和 M 次询问，求出每一次询问的区间内数字的最大值。 输入: 第一行包含两个整数 N,M，分别表示数列的长度和询问的个数。 第二行包含 N 个整数（记为 ai ），依次表示数列的第 i 项。 接下来 M 行，每行包含两个整数 li,ri，表示查询的区间为 [li, ri] 123456789108 89 3 1 7 5 6 0 81 61 52 72 61 84 83 71 8 输出 1234567899779879 例如数据，9 3 1 7 5 6 0 8，生成ST表为，其中第i行表示每个数后面\\math-container{2\\power{i}}个数的区间最大值。 例如i=2，那么就是每个数为基准，长度为4的区间最值。 下标j 1 2 3 4 5 6 7 8 原始i=0 9 3 1 7 5 6 0 8 i=1 9 3 7 7 6 6 8 i=2 9 7 7 7 8 i=3 9 倍增和动规 a[i][j]=max(a[i−1][j],a[i−1][j+(1≪i−1)])a[i][j]=max(a[i-1][j],a[i-1][j+(1≪i-1)])a[i][j]=max(a[i−1][j],a[i−1][j+(1≪i−1)])，1左移一位是2 查询时，例如要查询3到7区间最值，我们先计算这个区间包含几个元素，7-3+1=5个元素，再计算5对应的是2的2次方，那么可知答案就是在ST表的第二行，a[2][3]a[2][3]a[2][3]表示3为起点的4个元素的最大值，那么就是3-6区间，另外一个区间终点为7，那么起点是7-4+1，即4-7区间的4个元素，所以求a[2][3]a[2][3]a[2][3]和a[2][4]a[2][4]a[2][4]两个区间即可。 建表是nlognnlognnlogn的复杂度，查询是1的复杂度 可用AC 123456789101112131415161718192021#include&lt;bits/stdc++.h&gt;using namespace std;int n, m, x, y, a[20][100005], len;int main(){ scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for(int i = 1; i &lt;= n; i++)scanf(&quot;%d&quot;, &amp;a[0][i]); len = log2(n); for(int i = 1; i &lt;= len; i++) for(int j = 1; j &lt;= n - (1 &lt;&lt; i) + 1; j++) a[i][j] = max(a[i-1][j], a[i-1][j+(1&lt;&lt;i-1)]); for(int i = 1; i &lt;= m; i++){ scanf(&quot;%d%d&quot;, &amp;x, &amp;y); len = log2(y-x+1); printf(&quot;%d\\n&quot;, max(a[len][x], a[len][y-(1&lt;&lt;len)+1])); } return 0;}","link":"/%E7%AE%97%E6%B3%95/ST%E8%A1%A8/STtable/"},{"title":"背包问题","text":"计算机科学、算法设计和优化理论中非常著名的“背包问题”（Knapsack Problem）是一个典型的组合优化问题，也是动态规划算法的一个经典应用。 背包问题有多种变体，但最基本的形式是： 给定一组物品，每种物品都有自己的重量和价值，在限定的总重量内，如何选择装入背包的物品，使得背包内物品的总价值最大。 0-1背包 有n件物品和一个最多能背重量为w 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。每件物品只能用一次，求解将哪些物品装入背包里物品价值总和最大。 暴力解法应该是怎么样的呢？ 每一件物品其实只有两个状态，取或者不取，所以可以使用回溯法搜索出所有的情况，那么时间复杂度就是O(2^n)，这里的n表示物品数量。 背包最大重量为4。 物品为： 物品 重量 价值 0 1 15 1 3 20 2 4 30","link":"/%E7%AE%97%E6%B3%95/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/bag/"},{"title":"KMP","text":"KMP 一、简介 KMP 是一个解决模式串在文本串是否出现过，如果出现过，最早出现的位置的经典算法。 Knuth-Morris-Pratt 字符串查找算法，简称为 “KMP 算法”，常用于在一个文本串 S 内查找一个模式串 P 的出现位置，这个算法由Donald Knuth、Vaughan Pratt、James H. Morris 三人于 1977 年联合发表，故取这 3 人的姓氏命名此算法。 KMP 方法算法就利用之前判断过的信息，通过一个 next 数组，保存模式串中前后最长公共子序列的长度，每次回溯时，通过 next 数组找到，前面匹配过的位置，省去了大量的计算时间。 二、解题前的思考 关于字符串匹配，如果有两个字符串，其中一个较短的叫它子串（长度为n），较长的叫他主串（长度为m），那么该怎样确定子串在主串中的位置呢？ 最简单的笨蛋办法，暴力解，即从主串的每一个位置依次匹配子串每一位，时间复杂度是O(mn)O(mn)O(mn) 考虑优化： 在字符串匹配失败的时候，已经知道之前读过哪些字符了，那能不能避免“跳回下一个字符再重新匹配”的步骤呢？算法时间复杂度是O(m+n)O(m+n)O(m+n) 三、KMP算法思路 当发现某一个字符不匹配时，已经知道之前遍历过的字符，怎样利用已知信息避免暴力算法中的“回退”步骤呢？ 答案是跳过前边已经可以匹配的字符，继续从下一个可能匹配的字符开始匹配，那么具体需要跳过多少个字符呢？这里呢，利用next数组存储应该跳过多少个字符 next数组代表了在匹配失败的时候，子串中可以跳过匹配的字符个数。其本质即为寻找子串中“相同前后缀的最大长度”，且前后缀不能是字符串本身。 求解过程如下： 当前共同前后缀是2 如果下一个字符依然相同，那么下一个共同前后缀的长度就是2+1=3 如果下一个字符不相同，即ABA无法与下一个字符构成更长的前后缀， 那只能看看其中存不存在更短的前后缀， 因为ABA和ABA是一样的，已经知道其next数组是0 0 1， 所以现在找到位置cur_length = next[cut_length - 1] = 1 cur_length = 1, B可以匹配，所以B这里的next值为2 匹配两次才能成功的一个例子：aacaabaacaaa，最后一位需要匹配两次 四、KMP算法实现 1234567891011121314151617181920212223242526272829303132def getNext(s): ans = [0] # next数组 cur_len = 0 # 当前共同前后缀长度 i = 1 # 遍历指针 while i &lt; len(s): if s[cur_len] == s[i]: # 在已有共同前后缀长度上匹配成功 cur_len += 1 ans.append(cur_len) i += 1 else: # 匹配失败，如果当前无共同前后缀，就填0 if cur_len == 0: ans.append(0) i += 1 else: # 如果有共同前后缀，那么根据next数组跳过可以匹配的字符 cur_len = ans[cur_len - 1] return ansdef KMP_search(s, patt): pos = getNext(patt) i, j = 0, 0 # i, j分别是s和patt的指针 while i &lt; len(s): if s[i] == patt[j]: # 当前可以匹配，两个指针均后移 i += 1 j += 1 elif j &gt; 0: # 当前匹配失败，且j&gt;0，那么根据next数组跳过可以匹配的字符 j = pos[j - 1] else: # 当前匹配失败，且j&lt;=0，那么i++ i += 1 if j == len(patt): return i - j 修改版，主要是改变了大循环，while改成for，以及匹配失败，返回-1 1234567891011121314151617181920212223242526272829def getNext(s): ans = [0] # next数组 cur_len = 0 # 当前共同前后缀长度 i = 1 # 遍历指针 while i &lt; len(s): if s[cur_len] == s[i]: # 在已有共同前后缀长度上匹配成功 cur_len += 1 ans.append(cur_len) i += 1 else: # 匹配失败，如果当前无共同前后缀，就填0 if cur_len == 0: ans.append(0) i += 1 else: # 如果有共同前后缀，那么根据next数组跳过可以匹配的字符 cur_len = ans[cur_len - 1] return ansdef KMP_search(s, patt): pos = getNext(patt) i, j = 0, 0 # i, j分别是s和patt的指针 for i, c in enumerate(s): while j &gt; 0 and c != patt[j]: j = pos[j - 1] if c == patt[j]: # 当前可以匹配，两个指针均后移 j += 1 if j == len(patt): return i - j + 1 return -1 五、扩展练习 如果子串固定是ababc呢？不需要写通用版版本的KMP，怎样求解呢?","link":"/%E7%AE%97%E6%B3%95/KMP/KMP/"},{"title":"比较器","text":"比较器 Arrays.sort()：用于给数组排序，默认从小到大。 但有时候希望数组逆序排序，这需要借助比较器。在 Java 中，比较器是一个实现了 Comparator 接口的类，它定义了用于比较两个对象的方法。比较器允许我们根据自定义的比较规则对对象进行排序。Comparator 接口中最重要的方法是 compare 方法，该方法接受两个参数，分别是要比较的两个对象，并返回一个整数值，表示它们的相对顺序。定义中Comparator是使用了泛型的，泛型的本质是引用，不能传入基本数据类型（如int，long），如有需要可转换为Integer等类型。 int compare(T o1, T o2);，用于定义排序规则。该方法的参数也是泛型T，即排序的元素也不能是基本数据类型。该方法返回的整数值含义如下： 如果 obj1 小于 obj2，则返回负整数。 如果 obj1 等于 obj2，则返回零。 如果 obj1 大于 obj2，则返回正整数。 比较器允许我们在不修改对象自身的情况下，根据需要定义不同的排序规则。它通常用于对集合类（如 List、Set）中的元素进行排序。 创建比较器：需要实现Comparator接口并重写compare方法。 12345678import java.util.Comparator;public class IntegerComparator implements Comparator&lt;Integer&gt; { @Override public int compare(Integer num1, Integer num2) { return num1 - num2; // 升序 }} 创建了比较器后，可以将其传递给排序方法，例如 Collections.sort() 或 Arrays.sort()，来对对象进行排序。 降序排序 当需要逆序（从大到小排列）的时候，需要 return o2-o1。 多属性排序 在compare函数中逐一比较属性。 泛型比较器 在不同类型的对象上使用相同的比较规则。可以比较实现了Comparable接口的任何对象。 12345678import java.util.Comparator;public class GenericComparator&lt;T extends Comparable&lt;T&gt;&gt; implements Comparator&lt;T&gt; { @Override public int compare(T obj1, T obj2) { return obj1.compareTo(obj2); }} Lambda 表达式比较器 从 Java 8 开始，可以使用 Lambda 表达式更简洁地创建比较器。例如，要对字符串按长度进行排序，可以使用 Lambda 表达式： 1234567891011121314import java.util.Comparator;public class StringLengthComparator { public static void main(String[] args) { Comparator&lt;String&gt; lengthComparator = (str1, str2) -&gt; str1.length() - str2.length(); List&lt;String&gt; strings = Arrays.asList(&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;, &quot;date&quot;); Collections.sort(strings, lengthComparator); for (String str : strings) { System.out.println(str); } }} 使用注意事项 在使用比较器（Comparator）进行排序时，有一些注意事项需要牢记： 处理可能的空值：比较器应该能够处理可能为 null 的对象。如果不进行处理，可能会导致 NullPointerException 异常。可以在比较器中添加额外的逻辑来处理 null 值，或者使用 nullsFirst 和 nullsLast 方法来定义 null 值的排序规则。 一致性和传递性：确保您的比较器逻辑具有一致性和传递性。一致性意味着如果 compare(a, b) 返回零，那么 compare(b, a) 也应该返回零。传递性意味着如果 compare(a, b) 返回负数，compare(b, c) 也应该返回负数，则 compare(a, c) 应该返回负数。 避免整数溢出：在比较整数或长整数时，要小心整数溢出的问题。确保比较逻辑能够处理可能出现的整数溢出情况，或者使用更安全的方式进行比较。 考虑性能：了解比较器的性能特性并根据数据集大小选择合适的排序算法。对于大型数据集，选择更高效的排序算法可能更有利。 测试和验证：在使用比较器进行排序之前，始终测试和验证排序结果是否符合预期。尤其是在使用自定义比较器或多属性排序时，测试非常重要。 使用标准比较器：Java 提供了一些标准的比较器，如 Comparator.naturalOrder() 和 Comparator.reverseOrder()，它们可以用于常见的升序和降序排序需求。尽量使用这些标准比较器简化代码。 谨慎使用 compareTo 方法：当使用对象的 compareTo 方法进行比较时，要确保对象的 compareTo 方法已正确实现。如果不确定，最好使用自定义的比较器以确保一致性。 总之，使用比较器进行排序是 Java 中非常有用的功能，但要谨慎处理可能出现的问题，并在需要时根据特定需求编写自定义比较器。良好的比较器可以帮助您实现各种排序需求，提高代码的可维护性和可读性。","link":"/JAVA/JAVA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%AF%94%E8%BE%83%E5%99%A8/comparator/"},{"title":"位运算","text":"位运算是对整数在二进制位层面上进行直接操作的运算。它在性能敏感的程序中尤其重要，例如操作系统、嵌入式系统、加密算法等领域，通常比普通的算术运算更高效。 1. 按位“或”运算的性质（OR） 对于任意两个整数 A 和 B，按位或运算（A | B）具有以下几条重要性质： 1.1. 自反性（Idempotence） 任何数与自身做按位或运算，结果仍然是自身。例如： 5 | 5 = 5 1.2. 单调性（Monotonicity） A≤B ⟹ A∣C≤B∣C对于任意的CA \\leq B \\implies A | C \\leq B | C \\quad \\text{对于任意的} C A≤B⟹A∣C≤B∣C对于任意的C 这意味着，如果 A 小于 B，则 A 与任意数 C 做按位或运算的结果将不大于 B 与 C 的按位或结果。直观来说，按位或运算不会缩小数值。 1.3. 与任意元素按位或运算，结果大于等于自身 A∣B≥AA | B \\geq A A∣B≥A 按位或操作将 A 中的 0 变为 1，不会使 1 变回 0，因此 A | B 的每一位都大于或等于 A 的相应位。 1.4. 交换律（Commutativity） A∣B=B∣AA | B = B | AA∣B=B∣A 按位或运算是交换的，即 A 与 B 按位或运算的结果与顺序无关。 1.5. 结合律（Associativity） (A∣B)∣C=A∣(B∣C)(A | B) | C = A | (B | C)(A∣B)∣C=A∣(B∣C) 按位或运算是结合的，即对多个数进行按位或时，操作的顺序可以任意调整。 1.6. 单位元（Identity Element） A∣0=AA | 0 = A A∣0=A 任意数与 0 做按位或运算，结果仍然是该数本身。 1.7. 吸收律（Absorption） A∣(A&amp;B)=AA | (A \\&amp; B) = A A∣(A&amp;B)=A 任何数与它与另一个数按位与（&amp;）的结果做按位或，结果等于原数。这个性质的意思是，按位或操作“吸收”了按位与的结果。 1.8. 按位或与按位与的分配律（Distributivity） A∣(B&amp;C)=(A∣B)&amp;(A∣C)A | (B \\&amp; C) = (A | B) \\&amp; (A | C) A∣(B&amp;C)=(A∣B)&amp;(A∣C) 按位或和按位与之间存在分配律，类似于普通算数运算中的分配律。 2. 按位“与”运算的性质（AND） 按位与运算（A &amp; B）也有一些类似的性质： 2.1. 自反性（Idempotence） A &amp; A = A 任何数与自身做按位与运算，结果仍然是自身。 2.2. 交换律（Commutativity） A &amp; B = B &amp; A 按位与运算是交换的。 2.3. 结合律（Associativity） (A &amp; B) &amp; C = A &amp; (B &amp; C) 按位与运算是结合的。 2.4. 单位元（Identity Element） A &amp; 1 = A 任意数与 1 做按位与运算，结果仍然是该数本身。注意，1 在二进制中相当于所有位都为 1。 2.5. 零元（Null Element） A &amp; 0 = 0 任意数与 0 做按位与运算，结果为 0。这是因为与 0 按位与运算的任何结果都会是 0。 2.6. 吸收律（Absorption） A &amp; (A | B) = A 按位与与按位或之间也有吸收律，类似于上面按位或的吸收律。 3. 按位异或运算的性质（XOR） 按位异或运算（A ^ B）也具有一些特别的性质： 3.1. 自反性（Idempotence） A ^ A = 0 任何数与自身做按位异或，结果为 0。 3.2. 交换律（Commutativity） A ^ B = B ^ A 按位异或是交换的。 3.3. 结合律（Associativity） (A ^ B) ^ C = A ^ (B ^ C) 按位异或是结合的。 3.4. 单位元（Identity Element） A ^ 0 = A 任何数与 0 做按位异或运算，结果仍然是该数本身。 3.5. 对称性（Symmetry） A ^ B = B ^ A 按位异或是对称的。 4. 按位“非”运算的性质（NOT） 按位非（~）运算的性质相对简单： 4.1. 自反性（Idempotence） ∼(∼A)=A\\sim (\\sim A) = A ∼(∼A)=A 对某个数取两次按位非，结果是原数。 4.2. 按位非操作 按位非操作对二进制数的每一位取反，即 0 变 1，1 变 0。 5. 位运算的应用 位运算在编程中非常有用，特别是在涉及到大量的数值操作、标志位管理、内存优化等场景。以下是一些常见的应用： 判断某个数是否为偶数：x &amp; 1 == 0 判断某个数是否为 2 的幂：x &amp; (x - 1) == 0 提取某一位：(x &gt;&gt; n) &amp; 1，获取第 n 位的值。 设置某一位：x | (1 &lt;&lt; n)，设置第 n 位为 1。 清除某一位：x &amp; ~(1 &lt;&lt; n)，清除第 n 位。 反转某一位：x ^ (1 &lt;&lt; n)，反转第 n 位。 位运算的基本操作 Java 和大多数编程语言支持以下几种常见的位运算： 按位与（AND）：&amp; 规则：两个操作数的相同位置上的位都为 1，结果才为 1。 15 &amp; 3 5 的二进制是 0101 3 的二进制是 0011 结果：0101 &amp; 0011 = 0001 → 1 按位或（OR）：| 规则：两个操作数的相同位置上的位只要有一个为 1，结果就为 1。 15 | 3 5 的二进制是 0101 3 的二进制是 0011 结果：0101 | 0011 = 0111 → 7 按位异或（XOR）：^ 规则：两个操作数的相同位置上的位不同，结果为 1，相同则为 0。 15 ^ 3 5 的二进制是 0101 3 的二进制是 0011 结果：0101 ^ 0011 = 0110 → 6 按位非（NOT）：~ 规则：对每一位取反，0 变成 1，1 变成 0。注意，这个操作会影响符号位，在 Java 中对 int 取反后是 32 位。 1~5 5 的二进制是 00000000000000000000000000000101 结果：~5 = 11111111111111111111111111111010 → -6（二进制补码表示） 位移操作： 左移（&lt;&lt;）：将数字的所有位向左移动指定的位数，右侧用0补充。 15 &lt;&lt; 1 5 的二进制是 0101 左移一位：1010 → 10 右移（&gt;&gt;）：将数字的所有位向右移动指定的位数，对于正数，用0填补；对于负数，符号位保持不变。 15 &gt;&gt; 1 5 的二进制是 0101 右移一位：0010 → 2 无符号右移（&gt;&gt;&gt;）：与右移类似，但是对负数无符号右移时会将符号位填充为0。 1-5 &gt;&gt;&gt; 1 -5 的二进制（补码表示）是 11111111111111111111111111111011 无符号右移一位：01111111111111111111111111111101 → 2147483642 位运算的技巧与应用 快速计算乘法与除法（2 的幂） 左移：相当于乘以 2 的某个次幂。例如，x &lt;&lt; n 等价于 x * 2^n。 12 int x = 5;int result = x &lt;&lt; 2; // 相当于 5 * 4 = 20 右移：相当于除以 2 的某个次幂。例如，x &gt;&gt; n等价于 x / 2^n。 12int x = 20;int result = x &gt;&gt; 2; // 相当于 20 / 4 = 5 判断奇偶数 奇数：x &amp; 1 为 1 时，表示 x 是奇数。 偶数：x &amp; 1为 0时，表示x是偶数。 12int x = 5;boolean isOdd = (x &amp; 1) == 1; // 5 是奇数，结果为 true 判断是否是 2 的幂 一个数如果是 2 的幂，则它与它的前一个数按位与结果为 0。例如，x 是 2 的幂，当且仅当 x &amp; (x - 1) == 0。 12345678910111213 int x = 8; boolean isPowerOfTwo = (x &amp; (x - 1)) == 0; // 8 是 2 的幂，结果为 true 4. **交换两个数** - 利用异或操作可以在不使用临时变量的情况下交换两个数。 ```java int a = 5, b = 3; a = a ^ b; // a = 6 b = a ^ b; // b = 5 a = a ^ b; // a = 3 // 交换后，a=3, b=5 设置某一位 使用按位或操作来设置某一位为1 12345678910 int x = 5; // 0101 int result = x | (1 &lt;&lt; 2); // 设置第 2 位为 1 -&gt; 0111 6. **清除某一位** - 使用按位与操作和按位非操作清除某一位。 ```java int x = 5; // 0101 int result = x &amp; ~(1 &lt;&lt; 2); // 清除第 2 位 -&gt; 0001 反转某一位 使用按位异或操作来反转某一位。 12int x = 5; // 0101int result = x ^ (1 &lt;&lt; 2); // 反转第 2 位 -&gt; 0001 求平均数不带小数 位运算(a + b) &gt;&gt; 1 使用了位运算来高效地计算两个整数的平均值。通过按位与运算找到不进位的部分，按位异或运算找出进位的部分，然后将进位部分右移并与不进位部分相加，最终得到 a 和 b 的平均值。这种方法比直接使用 (a + b) / 2 更加高效。 1int result = ((a &amp; b) + (a ^ b) &gt;&gt; 1) ; 清零最低位的1 检查 n 是否是 2 的幂：如果 n &amp; (n - 1) == 0，那么 n 是 2 的幂。 清除 n 中最低位的 1。 1int result = n &amp; (n - 1) ; 位运算的常见应用场景： 图像处理：位运算用于像素的颜色深度处理和图像操作。 网络协议：许多网络协议（如 IP 地址、子网掩码）都依赖于位运算来处理二进制数据。 压缩算法：一些数据压缩算法利用位运算优化空间存储。 加密与解密：位运算被广泛应用于数据加密算法中（如 XOR 操作）。 位运算是计算机科学中非常重要且高效的工具，它使得很多操作能够以最小的成本完成，尤其在性能要求高的场景下，掌握位运算能大大提高程序的效率。","link":"/JAVA/JAVA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9/%E4%BD%8D%E8%BF%90%E7%AE%97/bitewise/"},{"title":"红楼梦","text":"终身误 都道是金玉良缘，俺只念木石前盟。 空对着，山中高士晶莹雪；终不忘，世外仙姝寂寞林。 叹人间，美中不足今方信。 纵然是齐眉举案，到底意难平。 好了歌 世人都晓神仙好，惟有功名忘不了！ 古今将相在何方？荒冢一堆草没了。 世人都晓神仙好，只有金银忘不了！ 终朝只恨聚无多，及到多时眼闭了。 世人都晓神仙好，只有娇妻忘不了！ 君生日日说恩情，君死又随人去了。 世人都晓神仙好，只有儿孙忘不了！ 痴心父母古来多，孝顺儿孙谁见了？","link":"/%E8%AF%BB%E4%B9%A6/%E7%BA%A2%E6%A5%BC%E6%A2%A6/honglou/"},{"title":"JAVA基础知识","text":"Java 基本数据类型 Java 基本数据类型对比表，涵盖了整数、浮点、字符和布尔类型： 数据类型 存储字节数 最小值 最大值 说明 byte 1 字节 -128 127 8 位带符号整数 short 2 字节 -32,768 32,767 16 位带符号整数 int 4 字节 -2,147,483,648 2,147,483,647 32 位带符号整数 long 8 字节 -9,223,372,036,854,775,808 9,223,372,036,854,775,807 64 位带符号整数 float 4 字节 ±1.4E-45 ±3.4028235E38 单精度浮点数（32 位） double 8 字节 ±4.9E-324 ±1.7976931348623157E308 双精度浮点数（64 位） char 2 字节 0 65,535 单一字符（UTF-16编码） boolean 1 字节（理论上） false true 布尔类型，通常表示为 true 或 false","link":"/JAVA/JAVA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/java-basic-data-type/"},{"title":"优先队列","text":"在 Java 中，优先队列（PriorityQueue） 是一个基于堆（通常是最小堆）的数据结构，位于 java.util 包中。优先队列的元素会按照自然顺序或提供的比较器顺序进行排序。以下是关于优先队列的详细介绍： 特点 自动排序：默认是最小优先队列（最小堆），即每次取出的元素是当前队列中最小的元素。 非线程安全：PriorityQueue 不是线程安全的，如果需要线程安全，可以使用 PriorityBlockingQueue。 不允许 null 元素。 支持自定义顺序：可以通过传入 Comparator 定义元素的排序方式。 构造方法 PriorityQueue 提供多种构造方法： 默认构造方法： 1PriorityQueue&lt;E&gt; pq = new PriorityQueue&lt;&gt;(); 创建一个初始容量为 11 的最小堆。 指定初始容量： 1PriorityQueue&lt;E&gt; pq = new PriorityQueue&lt;&gt;(int initialCapacity); 指定比较器： 1PriorityQueue&lt;E&gt; pq = new PriorityQueue&lt;&gt;(Comparator&lt;? super E&gt; comparator); 创建一个使用自定义比较器的优先队列。 通过集合初始化： 1PriorityQueue&lt;E&gt; pq = new PriorityQueue&lt;&gt;(Collection&lt;? extends E&gt; c); 常用方法 以下是 PriorityQueue 的常用方法： 方法名 说明 add(E e) 向队列中添加元素，若超出容量会抛出异常。 offer(E e) 向队列中添加元素，推荐使用。 poll() 移除并返回队列的头部元素，若队列为空则返回 null。 peek() 返回队列的头部元素但不移除，若队列为空则返回 null。 remove(Object o) 删除队列中指定的元素。 size() 返回队列中元素的数量。 isEmpty() 判断队列是否为空。 clear() 清空队列中的所有元素。","link":"/JAVA/JAVA%E5%B8%B8%E7%94%A8API/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/java-priority-queue/"},{"title":"力扣每日一题","text":"该文档仅仅自用 3066. 超过阈值的最少操作数 II 时间：2025/1/15 使用数据结构：优先队列 此题模拟即可，但要熟练掌握优先队列的使用，同时需要注意到数据范围，1&lt;=nums[i]&lt;=1091 &lt;= nums[i] &lt;= 10^91&lt;=nums[i]&lt;=109，使用long接收参数。 12345678910111213141516class Solution { public int minOperations(int[] nums, int k) { int ans = 0; PriorityQueue&lt;Long&gt; pq = new PriorityQueue&lt;&gt;(); for(long num : nums){ pq.offer(num); } while(pq.peek() &lt; k){ long x = pq.poll(), y = pq.poll(); pq.offer(x + x + y); ans++; } return ans; }} 3095. 或值至少 K 的最短子数组 I 时间：2025/1/16 枚举以i为起始位置的子数组，找到最短的符合要求的长度。 1234567891011121314151617class Solution { public int minimumSubarrayLength(int[] nums, int k) { int ans = Integer.MAX_VALUE; for(int i = 0; i &lt; nums.length; i++){ int cur = 0; for(int j = i; j &lt; nums.length; j++){ cur |= nums[j]; if(cur &gt;= k){ ans = Math.min(ans, j - i + 1); break; } } } return ans == Integer.MAX_VALUE ? -1 : ans; }} 或者可以使用滑动窗口 12345678910111213141516171819202122232425262728293031class Solution { public int minimumSubarrayLength(int[] nums, int k) { int n = nums.length; int[] bits = new int[30]; int res = Integer.MAX_VALUE; for (int left = 0, right = 0; right &lt; n; right++) { for (int i = 0; i &lt; 30; i++) { bits[i] += (nums[right] &gt;&gt; i) &amp; 1; } while (left &lt;= right &amp;&amp; calc(bits) &gt;= k) { res = Math.min(res, right - left + 1); for (int i = 0; i &lt; 30; i++) { bits[i] -= (nums[left] &gt;&gt; i) &amp; 1; } left++; } } return res == Integer.MAX_VALUE ? -1 : res; } private int calc(int[] bits) { int ans = 0; for (int i = 0; i &lt; bits.length; i++) { if (bits[i] &gt; 0) { ans |= 1 &lt;&lt; i; } } return ans; }} 3097. 或值至少为 K 的最短子数组 II 时间：2025/1/17 思路同上一道题 12345678910111213141516171819202122232425262728293031class Solution { public int minimumSubarrayLength(int[] nums, int k) { int n = nums.length; int[] bits = new int[30]; int res = Integer.MAX_VALUE; for (int left = 0, right = 0; right &lt; n; right++) { for (int i = 0; i &lt; 30; i++) { bits[i] += (nums[right] &gt;&gt; i) &amp; 1; } while (left &lt;= right &amp;&amp; calc(bits) &gt;= k) { res = Math.min(res, right - left + 1); for (int i = 0; i &lt; 30; i++) { bits[i] -= (nums[left] &gt;&gt; i) &amp; 1; } left++; } } return res == Integer.MAX_VALUE ? -1 : res; } private int calc(int[] bits) { int ans = 0; for (int i = 0; i &lt; bits.length; i++) { if (bits[i] &gt; 0) { ans |= 1 &lt;&lt; i; } } return ans; }} 2239. 找到最接近 0 的数字 时间：2025/1/20 笨蛋办法，依题意遍历 但效率较差，官解大同小异，将距0的距离也记录下来。时间上有所改进。 12345678910111213class Solution { public int findClosestNumber(int[] nums) { int ans = nums[0]; for(int i = 1; i &lt; nums.length; i++){ if (Math.abs(ans) &gt; Math.abs(nums[i])){ ans = nums[i]; } else if(Math.abs(ans) == Math.abs(nums[i])){ ans = Math.max(ans, nums[i]); } } return ans; }} 2218. 从栈中取出 K 个硬币的最大面值和 时间：2025/1/21 前缀和、背包问题、动态规划 状态定义：f[i] 表示选择了 i 个硬币时，能得到的最大价值。 转移方程：对于每个堆，我们尝试从该堆中取出不同数量的硬币（最多取堆中所有硬币）。对于每个堆中的硬币数量 t，如果当前的选择可以满足 i 个硬币（即 i &gt;= t），就尝试更新 f[i] 的值。 优化思路：每个堆中的硬币取出顺序是逐步累加的，依次计算从堆中取出 1、2、3...个硬币的总价值。 12345678910111213141516171819class Solution { public int maxValueOfCoins(List&lt;List&lt;Integer&gt;&gt; piles, int k) { int[] f = new int[k + 1]; Arrays.fill(f, -1); f[0] = 0; for (List&lt;Integer&gt; pile : piles) { for (int i = k; i &gt; 0; --i) { int value = 0; for (int t = 1; t &lt;= pile.size(); ++t) { value += pile.get(t - 1); if (i &gt;= t &amp;&amp; f[i - t] != -1) { f[i] = Math.max(f[i], f[i - t] + value); } } } } return f[k]; }} 1561. 你可以获得的最大硬币数目 时间：2025/1/22 博弈论、贪心 3n3n3n堆硬币，每轮由我选出3堆且拿走其中第二多的一个，也就是说我们直接每次最小的一堆选最小值交给bob即可，剩下的，每次可以取最大的两堆，我拿稍小的一个。 1234567891011class Solution { public int maxCoins(int[] piles) { Arrays.sort(piles); int n = piles.length / 3; int ans = 0; for(int i = 0; i &lt; n; i++){ ans += piles[3 * n - i * 2 - 2]; } return ans; }}","link":"/%E5%8A%9B%E6%89%A3/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/lcday/"},{"title":"听歌吗","text":"同花顺","link":"/%E5%A4%A9%E9%A9%AC%E8%A1%8C%E7%A9%BA/%E6%AD%8C/old-songs/"},{"title":"基础乐理","text":"基础乐理知识 一个曲谱有：调号、拍号、曲谱、歌词。 知道上述名称后，要从基础学起。 首先要明白音的性质：音高、音值、音量、音色。不同的乐器和人声都是通过这四项的不同变化才产生我们听到的音乐。 一、音及音高 音是由于物体的振动而产生的。音有高低、强弱、长短、音色等四种性质。 （1）音的高低是由于物体在一定时间内的振动次数(频率)而决定的。振动次数多，音则高;振动次数少，音则低。 （2）音的长短是由于音的延续时间的不同而决定的。音的延续时间长，音则长;音的延续时间短，音则短。 （3）音的强弱是由于振幅(音的振动范围的幅度)的大小而决定的。振幅大，音则强;振幅小，音则弱。 （4）音色则由于发音体的性质、形状及其泛音的多少等而不同。 由于音的振动状态的规则与不规则，音被分为乐音与噪音两类。音乐中所使用的主要是乐音，但噪音也是音乐表现中不可缺少的组成部分。 1、乐音体系音列音级 （1）在音乐中使用的、有固定音高的音的总和，叫做乐音体系。 （2）乐音体系中的音，按照上行或下行次序排列起来，叫做音列。 （3）乐音体系中的各音叫做音级。音级有基本音级和变化音级。 （4）乐音体系中，七个具有独立名称的音级叫做基本音级。 基本音级的名称是用字母和唱名两种方式来标记的。 字母体系：C D E F G A B 唱名体系：1 2 3 4 5 6 7 钢琴上白键所发出的音是与基本音级相符合的。钢琴上五十二个白键循环重复地使用七个基本音级名称。两个相邻的具有同样名称的音叫做八度。 升高或降低基本音级而得来的音，叫做变化音级。将基本音级升高半音用“升”或“#”来标明。降低半音用“降”或“b”来标明。升高全音用“重升”或“×”来标明。降低全音用“重降”或“bb”来标明。 如：升C或#C 降C或bC 2、音的分组 为了区分音名相同而音高不同的各音，我们将音列分成许多个“组”。 在音列中央的一组叫做小字一组。它的音级标记用小写字母并在右上方加数字1来表示。 比小字一组高的组顺次定名为：小字二组、小字三组、小字四组、小字五组。 小字二组的标记用小写字母并在右上方加数字2来表示。 比小字一组低的组，依次定名为小字组、大字组、大字一组及大字二组。 小字组各音的标记用不带数字的小写字母来表示。 大字组用不带数字的大写字母来标记。 大字一组用大写字母并在右下方加数字1来标明。 大字二组用大写字母并在右下方加数字2来标明。 3、音域及音区 总的音域是指音列的总范围，即从它的最低音(C2——c5)间的距离而言。 个别的人声或乐器的音域是指在整个音域中所能够达到的那一部分，如钢琴的音域是A2——c5。 音区是音域中的一部分，有高音区、低音区、中音区三种。 在整个音域中，小字组、小字一组和小字二组属于中音区。小字三组、小字四组和小字五组属高音区。大字组、大字一组和大字二组属低音区。 各音区的特性音色在音乐表现中，有着重大的意义。高音区一般具有清脆、嘹亮、尖锐的特性;而低音区则往往给人以浑厚、笨重之感。 二、音律 乐音体系中各音的绝对准确高度及其相互关系叫做音律。将八度分成十二个均等的部分——半音——的音律叫做十二平均律。 半音是十二平均律组织中最小的音高距离。两音间的距离等于两个半音的叫做全音。八度内包括十二个半音，也就是六个全音。 在音列中的基本音级中间，除了E到F、B到C是半音外，其余相邻两音间的距离都是全音。 根据复合音的第二分音和第三分音的纯五度关系，即由某一音开始向上推一纯五度，产生次一律，再由次一律向上推一纯五度，产生再次一律，如此继续相生所定出的音律叫做五度相生律。 纯律是于五度相生律用以构成的第二分音和第三分音之外，再加入第五分音来作为生律要素，构成和弦形式。 1、自然半音和自然全音变化半音和变化全音 由两个相邻的音级构成的半音叫做自然半音。如;e—f #e—#f #g—a 由相邻的两个音级形成的全音叫做自然全音。如：C—d C—#d ba—bB 由同一音级的两种不同形式所构成的半音，叫做变化半音。如：C—#C D—bD bbB—bB 由同一音级的两种不同形式或隔开一个音级所构成的全音，叫做变化全音。 如：B——bbB #C——bE 2、等音 音高相同而意义和记法不同的音，叫做等音。 1. 认识音符和节奏 学习内容： 音符（C、D、E、F、G、A、B）和升降音（#、b）的概念。 音名/音符是乐音体系中各音级各自的名称。现行通用音名为：CDEFGAB。除了音名还有do、re、mi、fa、sol、la、si这些音名，多用于歌唱，故又称唱名。除了音名和唱名以外，还有全音和半音，音高关系的最小计量单位，叫做“半音”，两个半音叫“全音”。 节奏符号（全音符、二分音符、四分音符等）。 节拍和拍号（如 4/4、3/4）。 练习建议： 在吉他上找到每根弦的音符位置。 打节拍器练习简单的节奏型。 2. 音阶与调式 学习内容： 自然大调音阶（C 大调）及其公式（全全半全全全半）。 自然小调音阶（A 小调）及其公式（全半全全半全全）。 了解调号和音阶关系。 练习建议： 在吉他指板上弹奏 C 大调和 A 小调音阶。 练习音阶爬格子，熟悉指板位置。 3. 和弦基础 学习内容： 什么是三和弦（大三和弦、小三和弦）。 常见和弦的构成音（如 C 和弦：C、E、G）。 和弦表记法（如 C、Am、G7）。 练习建议： 学会简单的和弦切换（如 C-G-Am-F）。 用和弦为简单的流行曲伴奏。","link":"/%E5%A4%A9%E9%A9%AC%E8%A1%8C%E7%A9%BA/%E4%B9%90%E7%90%86/musictheory/"},{"title":"诗词歌赋","text":"哲理 菩提偈 惠能 唐代 菩提本无树，明镜亦非台。 佛性常清净，何处有尘埃！ 身是菩提树，心为明镜台。 明镜本清净，何处染尘埃！ 菩提本无树，明镜亦非台。 本来无一物，何处惹尘埃！ 菩提只向心觅，何劳向外求玄？ 听说依此修行，西方只在目前！ 爱情 卜算子·赠乐婉杭妓 施酒监 宋代 相逢情便深，恨不相逢早。识尽千千万万人，终不似、伊家好。 别你登长道。转更添烦恼。楼外朱楼独倚阑，满目围芳草。 卜算子·答施 乐婉 宋代 相思似海深，旧事如天远。泪滴千千万万行，更使人、愁肠断。 要见无因见，拚了终难拚。若是前生未有缘，待重结、来生愿。 钗头凤·红酥手 陆游 宋代 红酥手，黄縢酒，满城春色宫墙柳。东风恶，欢情薄。一怀愁绪，几年离索。错、错、错。 春如旧，人空瘦，泪痕红浥鲛绡透。桃花落，闲池阁。山盟虽在，锦书难托。莫、莫、莫！ 钗头凤·世情薄 唐琬 宋代 世情薄，人情恶，雨送黄昏花易落。晓风干，泪痕残。欲笺心事，独语斜阑。难，难，难！ 人成各，今非昨，病魂常似秋千索。角声寒，夜阑珊。怕人寻问，咽泪装欢。瞒，瞒，瞒！ 山歌·亲老婆 冯梦龙 明代 天上星多月弗多。雪白样雄鸡当弗得个鹅。煮粥煮饭还是自家田里个米。有病还需亲老婆。 忽然道学。还是无病的日子多。 杂项 无题 出处暂不表，烦请自行搜索 雾不清，竹不青，斑驳光漫影。 山也明，鹿也鸣，清脆音铃铃。 雾不清，竹不青，雨打芭蕉向晚晴，蓑衣除去一身轻。 山亦凌，人亦泠，风吹钟磬越冬行，雀鸟叽喳似云聆。 竹不青，雾不明，履踏湿苔露沾襟。何处明月照我影，人鬼幢幢行。 雾不清，竹不青，何人寄我相思情。 物以清，情以清，相思买断一场清。 夜不清，天不晴，唯有相思记魂灵。 雾不清，竹不青，远山深处寄风轻。 似钟磬，似魂倾，梦中几度赴谁情。 整活组： 雾不清，竹不青，莎普爱思滴眼睛。","link":"/%E5%A4%A9%E9%A9%AC%E8%A1%8C%E7%A9%BA/%E8%AF%97%E8%AF%8D%E6%AD%8C%E8%B5%8B/poems/"},{"title":"建站过程","text":"什么是 Hexo？ Hexo 是一个快速、简洁且高效的博客框架。 Hexo 使用 Markdown（或其他标记语言）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 详情请自行翻阅官网：https://hexo.io/zh-cn/docs/ 此处仅贴出常用指令自用。 1234567891011121314151617181920212223242526272829303132333435363738# 使用 npm 安装 Hexo$ npm install -g hexo-cli# 请自行替换文件夹名,新建一个网站$ hexo init &lt;folder&gt; $ cd &lt;folder&gt;$ npm install# 新建一篇文章,文章名称和标题为 [title],文章采用 [layout] 布局$ hexo new [layout] &lt;title&gt;$ hexo new &quot;post title with whitespace&quot; # 如果标题包含空格，需加引号# 清除缓存,网页正常情况下可以忽略此条命令,执行该指令后,会删掉站点根目录下的public文件夹$ hexo clean# 生成静态文件$ hexo generate$ hexo g# 发表草稿$ hexo publish [layout] &lt;filename&gt;# 启动服务器（常用于调试）$ hexo server$ hexo s# 部署网站,将本地数据部署到远端服务器(如github、coding)$ hexo deploy$ hexo d# 创建分类选项Created: ~\\myBlog\\source\\categories\\index.md$ hexo new page categories# 需分类的文章要添加# categories: # - web前端# 注意这里的分类名前需要一个空格#如果在“- web前端”下方添加“-xxx”，hexo不会产生两个分类，而是把分类嵌套（即该文章属于 “- web前端”下的 “-xxx ”分类）。 链接Github 123456789101. 生成SSH_KEY首先在git下输入命令：cd ~/.ssh进入.ssh文件输入命令：ssh-keygen -t rsa -C ‘注册时的邮箱地址’ 将刚刚在.ssh目录下所复制的id_rsa.put文件中的信息复制进key(注意空格)（名字随意） 接着在本地绑定与Github的用户名和邮箱（git）输入命令：git config --global user.name “注册时用户名”输入命令：git config --global user.email “注册时邮箱” 在 Windows PowerShell 下重新生成 SSH 密钥并配置 GitHub，按照以下步骤操作：（出自gpt） 1. 打开 PowerShell 首先，按下 Win + X，然后选择 Windows PowerShell，或在开始菜单中搜索 &quot;PowerShell&quot; 并运行。 2. 生成 SSH 密钥 在 PowerShell 中运行以下命令来生成新的 SSH 密钥： 1ssh-keygen -t rsa -b 4096 -C &quot;your_email@example.com&quot; -t rsa：指定使用 RSA 算法。 -b 4096：指定密钥长度为 4096 位（安全性更高）。 -C &quot;your_email@example.com&quot;：添加一个注释，通常是你的电子邮件地址，方便以后识别。 执行该命令后，你会看到类似以下的提示： 1Enter file in which to save the key (C:\\Users\\your_username\\.ssh\\id_rsa): 按下 Enter，接受默认的保存位置（C:\\Users\\your_username\\.ssh\\id_rsa），或者可以输入一个新的路径。 3. 设置密码短语（可选） 接下来会提示你输入一个 密码短语。这个密码用于保护私钥，你可以选择设置一个密码，或者直接按 Enter 跳过设置密码短语。 4. 添加 SSH 密钥到 SSH 代理 生成完密钥后，接下来需要将 SSH 密钥添加到 SSH 代理。首先启动 SSH 代理，并将密钥加载到代理中。 运行以下命令启动 SSH 代理： 1eval $(ssh-agent -s) 然后，添加你的私钥（默认为 id_rsa）到 SSH 代理： 1ssh-add ~/.ssh/id_rsa 5. 复制公钥到剪贴板 接下来，你需要将公钥复制到剪贴板，以便将其添加到 GitHub。 运行以下命令来显示公钥： 1cat ~/.ssh/id_rsa.pub 将显示的公钥内容复制到剪贴板，按下 Ctrl + C 或右键点击 PowerShell 窗口并选择 复制。 6. 将公钥添加到 GitHub 登录到 GitHub。 点击右上角的头像，然后选择 Settings。 在左侧菜单中，点击 SSH and GPG keys。 点击 New SSH key。 在 Title 字段中，为你的 SSH 密钥命名（例如：“Windows SSH Key”）。 将刚才复制的公钥粘贴到 Key 字段中。 点击 Add SSH key。 7. 测试 SSH 连接 完成上述步骤后，测试 SSH 连接是否成功： 1ssh -T git@github.com 如果是第一次连接，可能会看到如下提示，询问你是否信任 GitHub 的服务器： 12The authenticity of host 'github.com (IP_ADDRESS)' can't be established.Are you sure you want to continue connecting (yes/no)? 输入 yes 后继续。 如果成功连接，你将看到类似以下的消息： 1Hi username! You've successfully authenticated, but GitHub does not provide shell access. 8. 配置 Git 使用 SSH 最后，确保你的 Git 配置使用 SSH 而不是 HTTPS 进行推送和拉取操作。可以检查你的远程 URL： 1git remote -v 如果显示的 URL 是类似于 https://github.com/username/repository.git，你可以将它改成 SSH 版本： 1git remote set-url origin git@github.com:username/repository.git 总结： 现在你已经重新生成了 SSH 密钥，并将其添加到 GitHub 上。通过 SSH 进行 Git 操作时，应该不会再遇到需要输入用户名和密码的问题。如果有任何问题，可以再次联系我！ 如无法推送至git，或许修改端口可以解决。 关于markdown中显示图片并设置大小和位置，可以使用 这里的images在source下 1&lt;img src=&quot;/images/外科队伍.svg&quot; width=&quot;50%&quot; height=&quot;50%&quot; align=&quot;center&quot;&gt; 为了居中显示图片，可以","link":"/%E5%BB%BA%E7%AB%99%E7%9B%B8%E5%85%B3/Hexo%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/use-of-theme/"}],"tags":[],"categories":[{"name":"力扣","slug":"力扣","link":"/categories/%E5%8A%9B%E6%89%A3/"},{"name":"力扣热门100","slug":"力扣/力扣热门100","link":"/categories/%E5%8A%9B%E6%89%A3/%E5%8A%9B%E6%89%A3%E7%83%AD%E9%97%A8100/"},{"name":"链表","slug":"力扣/力扣热门100/链表","link":"/categories/%E5%8A%9B%E6%89%A3/%E5%8A%9B%E6%89%A3%E7%83%AD%E9%97%A8100/%E9%93%BE%E8%A1%A8/"},{"name":"二叉树","slug":"力扣/力扣热门100/二叉树","link":"/categories/%E5%8A%9B%E6%89%A3/%E5%8A%9B%E6%89%A3%E7%83%AD%E9%97%A8100/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"堆","slug":"力扣/力扣热门100/堆","link":"/categories/%E5%8A%9B%E6%89%A3/%E5%8A%9B%E6%89%A3%E7%83%AD%E9%97%A8100/%E5%A0%86/"},{"name":"矩阵","slug":"力扣/力扣热门100/矩阵","link":"/categories/%E5%8A%9B%E6%89%A3/%E5%8A%9B%E6%89%A3%E7%83%AD%E9%97%A8100/%E7%9F%A9%E9%98%B5/"},{"name":"多维动态规划","slug":"力扣/力扣热门100/多维动态规划","link":"/categories/%E5%8A%9B%E6%89%A3/%E5%8A%9B%E6%89%A3%E7%83%AD%E9%97%A8100/%E5%A4%9A%E7%BB%B4%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"滑动窗口","slug":"力扣/力扣热门100/滑动窗口","link":"/categories/%E5%8A%9B%E6%89%A3/%E5%8A%9B%E6%89%A3%E7%83%AD%E9%97%A8100/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"},{"name":"技巧","slug":"力扣/力扣热门100/技巧","link":"/categories/%E5%8A%9B%E6%89%A3/%E5%8A%9B%E6%89%A3%E7%83%AD%E9%97%A8100/%E6%8A%80%E5%B7%A7/"},{"name":"二分查找","slug":"力扣/力扣热门100/二分查找","link":"/categories/%E5%8A%9B%E6%89%A3/%E5%8A%9B%E6%89%A3%E7%83%AD%E9%97%A8100/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"name":"栈","slug":"力扣/力扣热门100/栈","link":"/categories/%E5%8A%9B%E6%89%A3/%E5%8A%9B%E6%89%A3%E7%83%AD%E9%97%A8100/%E6%A0%88/"},{"name":"子串","slug":"力扣/力扣热门100/子串","link":"/categories/%E5%8A%9B%E6%89%A3/%E5%8A%9B%E6%89%A3%E7%83%AD%E9%97%A8100/%E5%AD%90%E4%B8%B2/"},{"name":"动态规划","slug":"力扣/力扣热门100/动态规划","link":"/categories/%E5%8A%9B%E6%89%A3/%E5%8A%9B%E6%89%A3%E7%83%AD%E9%97%A8100/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"哈希","slug":"力扣/力扣热门100/哈希","link":"/categories/%E5%8A%9B%E6%89%A3/%E5%8A%9B%E6%89%A3%E7%83%AD%E9%97%A8100/%E5%93%88%E5%B8%8C/"},{"name":"读书","slug":"读书","link":"/categories/%E8%AF%BB%E4%B9%A6/"},{"name":"回溯","slug":"力扣/力扣热门100/回溯","link":"/categories/%E5%8A%9B%E6%89%A3/%E5%8A%9B%E6%89%A3%E7%83%AD%E9%97%A8100/%E5%9B%9E%E6%BA%AF/"},{"name":"算法","slug":"算法","link":"/categories/%E7%AE%97%E6%B3%95/"},{"name":"双指针","slug":"力扣/力扣热门100/双指针","link":"/categories/%E5%8A%9B%E6%89%A3/%E5%8A%9B%E6%89%A3%E7%83%AD%E9%97%A8100/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"贪心算法","slug":"力扣/力扣热门100/贪心算法","link":"/categories/%E5%8A%9B%E6%89%A3/%E5%8A%9B%E6%89%A3%E7%83%AD%E9%97%A8100/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"},{"name":"JAVA","slug":"JAVA","link":"/categories/JAVA/"},{"name":"数组","slug":"力扣/力扣热门100/数组","link":"/categories/%E5%8A%9B%E6%89%A3/%E5%8A%9B%E6%89%A3%E7%83%AD%E9%97%A8100/%E6%95%B0%E7%BB%84/"},{"name":"图论","slug":"力扣/力扣热门100/图论","link":"/categories/%E5%8A%9B%E6%89%A3/%E5%8A%9B%E6%89%A3%E7%83%AD%E9%97%A8100/%E5%9B%BE%E8%AE%BA/"},{"name":"力扣每日一题","slug":"力扣/力扣每日一题","link":"/categories/%E5%8A%9B%E6%89%A3/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"name":"人月神话","slug":"读书/人月神话","link":"/categories/%E8%AF%BB%E4%B9%A6/%E4%BA%BA%E6%9C%88%E7%A5%9E%E8%AF%9D/"},{"name":"LRU与LFU缓存替换","slug":"算法/LRU与LFU缓存替换","link":"/categories/%E7%AE%97%E6%B3%95/LRU%E4%B8%8ELFU%E7%BC%93%E5%AD%98%E6%9B%BF%E6%8D%A2/"},{"name":"ST表","slug":"算法/ST表","link":"/categories/%E7%AE%97%E6%B3%95/ST%E8%A1%A8/"},{"name":"背包问题","slug":"算法/背包问题","link":"/categories/%E7%AE%97%E6%B3%95/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"},{"name":"KMP","slug":"算法/KMP","link":"/categories/%E7%AE%97%E6%B3%95/KMP/"},{"name":"JAVA基础知识点","slug":"JAVA/JAVA基础知识点","link":"/categories/JAVA/JAVA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"name":"红楼梦","slug":"读书/红楼梦","link":"/categories/%E8%AF%BB%E4%B9%A6/%E7%BA%A2%E6%A5%BC%E6%A2%A6/"},{"name":"JAVA常用API","slug":"JAVA/JAVA常用API","link":"/categories/JAVA/JAVA%E5%B8%B8%E7%94%A8API/"},{"name":"自定义比较器","slug":"JAVA/JAVA基础知识点/自定义比较器","link":"/categories/JAVA/JAVA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%AF%94%E8%BE%83%E5%99%A8/"},{"name":"位运算","slug":"JAVA/JAVA基础知识点/位运算","link":"/categories/JAVA/JAVA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9/%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"name":"基本数据类型","slug":"JAVA/JAVA基础知识点/基本数据类型","link":"/categories/JAVA/JAVA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"name":"优先队列","slug":"JAVA/JAVA常用API/优先队列","link":"/categories/JAVA/JAVA%E5%B8%B8%E7%94%A8API/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"},{"name":"天马行空","slug":"天马行空","link":"/categories/%E5%A4%A9%E9%A9%AC%E8%A1%8C%E7%A9%BA/"},{"name":"建站相关","slug":"建站相关","link":"/categories/%E5%BB%BA%E7%AB%99%E7%9B%B8%E5%85%B3/"},{"name":"歌","slug":"天马行空/歌","link":"/categories/%E5%A4%A9%E9%A9%AC%E8%A1%8C%E7%A9%BA/%E6%AD%8C/"},{"name":"乐理","slug":"天马行空/乐理","link":"/categories/%E5%A4%A9%E9%A9%AC%E8%A1%8C%E7%A9%BA/%E4%B9%90%E7%90%86/"},{"name":"诗词歌赋","slug":"天马行空/诗词歌赋","link":"/categories/%E5%A4%A9%E9%A9%AC%E8%A1%8C%E7%A9%BA/%E8%AF%97%E8%AF%8D%E6%AD%8C%E8%B5%8B/"},{"name":"Hexo常用指令","slug":"建站相关/Hexo常用指令","link":"/categories/%E5%BB%BA%E7%AB%99%E7%9B%B8%E5%85%B3/Hexo%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/"}],"pages":[{"title":"文章分类","text":"","link":"/categories/index.html"}]}