{"posts":[{"title":"多维动态规划","text":"","link":"/%E5%8A%9B%E6%89%A3/%E5%8A%9B%E6%89%A3%E7%83%AD%E9%97%A8100/%E5%A4%9A%E7%BB%B4%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/LC100-MDdp/"},{"title":"回溯","text":"","link":"/%E5%8A%9B%E6%89%A3/%E5%8A%9B%E6%89%A3%E7%83%AD%E9%97%A8100/%E5%9B%9E%E6%BA%AF/LC100-backtrack/"},{"title":"动态规划","text":"","link":"/%E5%8A%9B%E6%89%A3/%E5%8A%9B%E6%89%A3%E7%83%AD%E9%97%A8100/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/LC100-dp/"},{"title":"数组","text":"","link":"/%E5%8A%9B%E6%89%A3/%E5%8A%9B%E6%89%A3%E7%83%AD%E9%97%A8100/%E6%95%B0%E7%BB%84/LC100-array/"},{"title":"二叉树","text":"","link":"/%E5%8A%9B%E6%89%A3/%E5%8A%9B%E6%89%A3%E7%83%AD%E9%97%A8100/%E4%BA%8C%E5%8F%89%E6%A0%91/LC100-binary-tree/"},{"title":"二分查找","text":"","link":"/%E5%8A%9B%E6%89%A3/%E5%8A%9B%E6%89%A3%E7%83%AD%E9%97%A8100/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/LC100-binary-search/"},{"title":"双指针","text":"","link":"/%E5%8A%9B%E6%89%A3/%E5%8A%9B%E6%89%A3%E7%83%AD%E9%97%A8100/%E5%8F%8C%E6%8C%87%E9%92%88/LC100-dual-pointer/"},{"title":"堆","text":"","link":"/%E5%8A%9B%E6%89%A3/%E5%8A%9B%E6%89%A3%E7%83%AD%E9%97%A8100/%E5%A0%86/LC100-heap/"},{"title":"图论","text":"","link":"/%E5%8A%9B%E6%89%A3/%E5%8A%9B%E6%89%A3%E7%83%AD%E9%97%A8100/%E5%9B%BE%E8%AE%BA/LC100-graph/"},{"title":"贪心算法","text":"","link":"/%E5%8A%9B%E6%89%A3/%E5%8A%9B%E6%89%A3%E7%83%AD%E9%97%A8100/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/LC100-greedy/"},{"title":"矩阵","text":"","link":"/%E5%8A%9B%E6%89%A3/%E5%8A%9B%E6%89%A3%E7%83%AD%E9%97%A8100/%E7%9F%A9%E9%98%B5/LC100-matrix/"},{"title":"技巧","text":"","link":"/%E5%8A%9B%E6%89%A3/%E5%8A%9B%E6%89%A3%E7%83%AD%E9%97%A8100/%E6%8A%80%E5%B7%A7/LC100-skill/"},{"title":"链表","text":"","link":"/%E5%8A%9B%E6%89%A3/%E5%8A%9B%E6%89%A3%E7%83%AD%E9%97%A8100/%E9%93%BE%E8%A1%A8/LC100-linked-list/"},{"title":"滑动窗口","text":"","link":"/%E5%8A%9B%E6%89%A3/%E5%8A%9B%E6%89%A3%E7%83%AD%E9%97%A8100/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/LC100-sliding-window/"},{"title":"栈","text":"","link":"/%E5%8A%9B%E6%89%A3/%E5%8A%9B%E6%89%A3%E7%83%AD%E9%97%A8100/%E6%A0%88/LC100-stack/"},{"title":"力扣热门100JAVA版","text":"基础操作 put(K key, V value)：将指定的键值对插入到 HashMap 中，若键已存在，则更新值。get(Object key)：根据键获取值，如果不存在该键，返回 null。remove(Object key)：根据键删除键值对。containsKey(Object key)：检查是否包含指定的键。containsValue(Object value)：检查是否包含指定的值。size()：返回 HashMap 中键值对的数量。isEmpty()：检查 HashMap 是否为空。keySet()：返回所有键的集合。values()：返回所有值的集合。entrySet()：返回 HashMap 中所有键值对的 Set 集合。clear()：清空所有元素。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import java.util.HashMap;import java.util.Map;public class HashMapExample { public static void main(String[] args) { // 创建 HashMap 实例 HashMap&lt;String, Integer&gt; map = new HashMap&lt;&gt;(); // 1. put() - 添加或更新元素 map.put(&quot;apple&quot;, 1); // key = &quot;apple&quot;, value = 1 map.put(&quot;banana&quot;, 2); // key = &quot;banana&quot;, value = 2 map.put(&quot;orange&quot;, 3); // key = &quot;orange&quot;, value = 3 // 2. get() - 获取元素 System.out.println(&quot;Value for key 'apple': &quot; + map.get(&quot;apple&quot;)); // 输出 1 // 3. containsKey() - 检查是否包含某个键 System.out.println(&quot;Contains key 'banana': &quot; + map.containsKey(&quot;banana&quot;)); // 输出 true // 4. containsValue() - 检查是否包含某个值 System.out.println(&quot;Contains value 2: &quot; + map.containsValue(2)); // 输出 true // 5. remove() - 删除某个键值对 map.remove(&quot;banana&quot;); System.out.println(&quot;After removing 'banana': &quot; + map); // 6. size() - 获取大小 System.out.println(&quot;Size of map: &quot; + map.size()); // 输出 2 // 7. isEmpty() - 检查是否为空 System.out.println(&quot;Is map empty? &quot; + map.isEmpty()); // 输出 false // 8. keySet() - 获取所有的键 System.out.println(&quot;All keys: &quot; + map.keySet()); // 输出 [apple, orange] // 9. values() - 获取所有的值 System.out.println(&quot;All values: &quot; + map.values()); // 输出 [1, 3] // 10. entrySet() - 获取所有的键值对 for (Map.Entry&lt;String, Integer&gt; entry : map.entrySet()) { System.out.println(entry.getKey() + &quot;: &quot; + entry.getValue()); } // 11. clear() - 清空所有元素 map.clear(); System.out.println(&quot;After clearing map: &quot; + map); // 输出 {} }} 1. 两数之和12345678910111213class Solution { public int[] twoSum(int[] nums, int target) { HashMap&lt;Integer, Integer&gt; mp = new HashMap&lt;&gt;(); for (int i = 0; i &lt; nums.length; i++){ int temp = target - nums[i]; if (mp.containsKey(temp)){ return new int[]{mp.get(temp), i}; } mp.put(nums[i], i); } return new int[0]; }} 49. 字母异位词分组128. 最长连续序列1234567891011121314151617181920212223class Solution { public int longestConsecutive(int[] nums) { Set&lt;Integer&gt; num_set = new HashSet&lt;Integer&gt;(); for (int num : nums){ num_set.add(num); } int ans = 0; for (int num : num_set){ if (!num_set.contains(num - 1)){ int cur = num; int temp = 1; while (num_set.contains(cur + 1)){ cur++; temp++; } ans = Math.max(ans, temp); } } return ans; }}","link":"/%E5%8A%9B%E6%89%A3/%E5%8A%9B%E6%89%A3%E7%83%AD%E9%97%A8100/%E5%93%88%E5%B8%8C/LChot100/"},{"title":"LRU与LFU缓存","text":"LRU与LFU缓存替换策略LRU（Least Recently Used，最少最近使用）和 LFU（Least Frequently Used，最不经常使用）是两种常用的缓存替换策略，用于决定缓存中哪些项应该被淘汰。它们的实现和应用场景非常广泛，特别是在内存管理、数据库缓存和操作系统中。 LRU (Least Recently Used) 最少最近使用LRU 策略用于在缓存满了时，淘汰最久没有使用的数据。即：每当一个缓存项被访问时，它就被认为是“最近使用”的，最少使用的缓存项就会被替换。 题目描述:设计并实现一个满足LRU最近最少使用缓存约束的数据结构。实现LRUCache类：LRUCache (int capacity)以 正整数 作为容量 capacity 初始化 LRU 缓存int get(int key) 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。void put(int key, int value)如果关键字 key 已经存在，则变更其数据值 value ；如果不存在，则向缓存中插入该组 key-value 。如果插入操作导致关键字数量超过 capacity ，则应该 逐出 最久未使用的关键字。函数get和put必须以O(1)的平均时间复杂度运行。} 思路：每次访问缓存时，将该缓存项标记为“最近使用”。当缓存满时，淘汰最久未被访问的缓存项。实现方法：LRU 可以通过 双向链表 和 哈希表 来实现： 哈希表 用于快速访问缓存项。双向链表 用于维护缓存项的使用顺序，最近访问的项放在链表头，最久未访问的项放在链表尾。LRU 实现步骤：哈希表：存储缓存的键值对，键是缓存的键，值是缓存项（值和最近使用的顺序）。双向链表：存储缓存项的顺序，最近访问的缓存项放在头部，最久未访问的放在尾部。插入和删除：每次访问缓存项时，将该项移动到链表头；如果缓存满了，移除链表尾部的项。 12345678910111213141516171819202122232425262728293031323334353637383940import java.util.*;class LRUCache { private int capacity; private Map&lt;Integer, Integer&gt; cache; private LinkedHashMap&lt;Integer, Long&gt; accessOrder; public LRUCache(int capacity) { this.capacity = capacity; this.cache = new HashMap&lt;&gt;(); this.accessOrder = new LinkedHashMap&lt;&gt;(capacity, 0.75f, true); // true 表示访问顺序 } public int get(int key) { if (!cache.containsKey(key)) { return -1; } // 更新访问顺序 accessOrder.put(key, System.nanoTime()); return cache.get(key); } public void put(int key, int value) { if (cache.size() &gt;= capacity) { // 找到最少使用的键 long leastUsedTime = Long.MAX_VALUE; int keyToRemove = -1; for (Map.Entry&lt;Integer, Long&gt; entry : accessOrder.entrySet()) { if (entry.getValue() &lt; leastUsedTime) { leastUsedTime = entry.getValue(); keyToRemove = entry.getKey(); } } // 移除最少使用的项 cache.remove(keyToRemove); accessOrder.remove(keyToRemove); } cache.put(key, value); accessOrder.put(key, System.nanoTime()); }}} 但这么写 过不了力扣…… 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273class LRUCache { // Node 类表示链表中的每个节点 private static class Node { int key, value; // 存储 key 和 value Node prev, next; // 前后指针，用于双向链表 Node(int k, int v) { // 构造函数初始化 key 和 value key = k; value = v; } } private final int capacity; // 缓存的最大容量 private final Node dummy = new Node(0, 0); // 哑节点，用于简化双向链表操作（头节点） private final Map&lt;Integer, Node&gt; keyToNode = new HashMap&lt;&gt;(); // 用于存储缓存中每个 key 对应的节点 // 构造函数初始化容量，并且初始化双向链表的 dummy 节点 public LRUCache(int capacity) { this.capacity = capacity; dummy.prev = dummy; // 哑节点的 prev 指向自己 dummy.next = dummy; // 哑节点的 next 指向自己 } // 获取缓存中某个 key 对应的 value public int get(int key) { Node node = getNode(key); // 查找 key 对应的节点 return node != null ? node.value : -1; // 如果找到节点，返回节点的值，否则返回 -1（表示不存在） } // 向缓存中插入新的 key-value 对 public void put(int key, int value) { Node node = getNode(key); // 查找 key 对应的节点 if (node != null) { // 如果节点存在，更新节点的值 node.value = value; return; // 直接返回，无需做其他操作 } // 如果节点不存在，创建一个新的节点并插入到缓存中 node = new Node(key, value); keyToNode.put(key, node); // 将新节点存入哈希表 pushFront(node); // 将新节点移动到链表的头部，表示最近使用 // 如果缓存的大小超过了容量，移除最不常用的节点（尾部节点） if (keyToNode.size() &gt; capacity) { Node backNode = dummy.prev; // 获取尾部节点（最久未使用的节点） keyToNode.remove(backNode.key); // 从哈希表中移除该节点 remove(backNode); // 从链表中移除该节点 } } // 根据 key 获取对应的节点 private Node getNode(int key) { if (!keyToNode.containsKey(key)) return null; // 如果 key 不存在，返回 null Node node = keyToNode.get(key); // 获取节点 remove(node); // 从链表中移除该节点 pushFront(node); // 将该节点移到链表头部，表示它是最新使用的 return node; // 返回节点 } // 从链表中移除指定的节点 private void remove(Node x) { x.prev.next = x.next; // 将前一个节点的 next 指向当前节点的下一个节点 x.next.prev = x.prev; // 将下一个节点的 prev 指向当前节点的前一个节点 } // 将指定的节点插入到链表头部 private void pushFront(Node x) { x.prev = dummy; // 新节点的 prev 指向哑节点 x.next = dummy.next; // 新节点的 next 指向哑节点的下一个节点 x.prev.next = x; // 哑节点的 next 指向新节点 x.next.prev = x; // 新节点的 next 节点的 prev 指向新节点 }}} LFU (Least Frequently Used) 最不经常使用LFU 策略用于淘汰访问频率最低的缓存项。即：每次访问缓存时，缓存项的访问次数增加。缓存满时，淘汰访问次数最少的缓存项。 思路：每个缓存项都有一个访问频率：当访问缓存时，增加该项的频率。淘汰策略：当缓存满时，淘汰频率最低的缓存项。若频率相同，则淘汰最早添加的缓存项。实现方法：LFU 通常使用 哈希表 和 最小堆（或 哈希表+双向链表）来实现。 哈希表 用于存储缓存的键值对。频率表：哈希表将缓存项的访问次数作为键，缓存项列表作为值（即频率与缓存项的映射关系）。最小堆：或者使用优先队列来管理访问频率，以便快速找到访问次数最少的缓存项。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364import java.util.*;class LFUCache { private int capacity; private Map&lt;Integer, Integer&gt; values; private Map&lt;Integer, Integer&gt; frequencies; private Map&lt;Integer, LinkedHashSet&lt;Integer&gt;&gt; freqList; private int minFreq; public LFUCache(int capacity) { this.capacity = capacity; this.values = new HashMap&lt;&gt;(); this.frequencies = new HashMap&lt;&gt;(); this.freqList = new HashMap&lt;&gt;(); this.minFreq = -1; } public int get(int key) { if (!values.containsKey(key)) { return -1; } int freq = frequencies.get(key); frequencies.put(key, freq + 1); freqList.get(freq).remove(key); if (freqList.get(freq).isEmpty()) { if (minFreq == freq) { minFreq++; } freqList.remove(freq); } freqList.putIfAbsent(freq + 1, new LinkedHashSet&lt;&gt;()); freqList.get(freq + 1).add(key); return values.get(key); } public void put(int key, int value) { if (capacity &lt;= 0) return; if (values.containsKey(key)) { values.put(key, value); get(key); // 更新频率 return; } if (values.size() &gt;= capacity) { // 淘汰最少频次的缓存项 int evictKey = freqList.get(minFreq).iterator().next(); freqList.get(minFreq).remove(evictKey); if (freqList.get(minFreq).isEmpty()) { freqList.remove(minFreq); } values.remove(evictKey); frequencies.remove(evictKey); } values.put(key, value); frequencies.put(key, 1); minFreq = 1; freqList.putIfAbsent(1, new LinkedHashSet&lt;&gt;()); freqList.get(1).add(key); }}} 主要思路：频率管理：用一个哈希表 freqToDummy 存储每个访问频率对应的链表，链表的头部代表最近访问的节点，尾部代表最久未访问的节点。双向链表：为每个访问频率维护一个双向链表，这样可以高效地管理节点的顺序，并能在常数时间内删除最不常使用的节点。最小频率：minFreq 变量用于记录当前缓存中的最小访问频率。每当访问一个节点时，如果该节点的访问频率变化，并且该频率链表变为空，我们需要更新 minFreq。核心操作：get 操作：查找并返回缓存中 key 对应的值，同时将该节点的访问频率加 1，并将其移动到新的频率链表中。put 操作：如果缓存已满，先移除访问频率最少的节点。然后将新节点插入到频率为 1 的链表中，并设置 minFreq 为 1。节点的移动：每次访问或插入时，节点会根据其访问频率被移动到对应的链表头部，从而保证频率最低的节点最先被淘汰。性能分析：时间复杂度：每个操作（get、put、remove、pushFront）都可以在 O(1) 时间内完成，因为链表操作和哈希表操作的时间复杂度是 O(1)。空间复杂度：空间复杂度是 O(capacity)，因为我们只在缓存中存储最多 capacity 个节点。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899class LFUCache { // Node 类表示链表中的每个节点 private static class Node { int key, value, freq = 1; // key 是键，value 是值，freq 是访问频率，初始化为 1 Node prev, next; // prev 和 next 是双向链表的指针 Node(int key, int value) { // 构造函数初始化 key 和 value this.key = key; this.value = value; } } private final int capacity; // 缓存的最大容量 private final Map&lt;Integer, Node&gt; keyToNode = new HashMap&lt;&gt;(); // 存储缓存的 key -&gt; Node 映射 private final Map&lt;Integer, Node&gt; freqToDummy = new HashMap&lt;&gt;(); // 存储频率 -&gt; 哑节点（代表链表头） private int minFreq; // 记录当前缓存中的最小访问频率 // 构造函数初始化缓存容量 public LFUCache(int capacity) { this.capacity = capacity; } // 获取缓存中指定 key 对应的值 public int get(int key) { Node node = getNode(key); // 获取节点 return node != null ? node.value : -1; // 如果节点存在，返回其值，否则返回 -1 } // 向缓存中插入新的 key-value 对 public void put(int key, int value) { Node node = getNode(key); // 尝试从缓存中获取该节点 if (node != null) { // 如果节点已经存在，更新其值 node.value = value; return; } // 如果缓存已满，则删除访问频率最少的元素 if (keyToNode.size() == capacity) { Node dummy = freqToDummy.get(minFreq); // 获取最小频率的链表 Node backNode = dummy.prev; // 获取该链表中的最旧节点 keyToNode.remove(backNode.key); // 从哈希表中移除该节点 remove(backNode); // 从链表中移除该节点 if (dummy.prev == dummy) { // 如果该链表为空 freqToDummy.remove(minFreq); // 移除该频率的链表 } } // 创建新节点并放入缓存 node = new Node(key, value); keyToNode.put(key, node); // 添加到 keyToNode 哈希表 pushFront(1, node); // 将新节点放入频率为 1 的链表中（即最上面） minFreq = 1; // 更新最小频率为 1 } // 获取指定 key 对应的节点，并将其访问频率加 1 private Node getNode(int key) { if (!keyToNode.containsKey(key)) { // 如果没有该 key return null; } Node node = keyToNode.get(key); // 获取节点 remove(node); // 从链表中移除该节点 Node dummy = freqToDummy.get(node.freq); // 获取当前频率对应的链表 if (dummy.prev == dummy) { // 如果当前频率的链表为空 freqToDummy.remove(node.freq); // 移除该频率的链表 if (minFreq == node.freq) { // 如果当前频率是最小频率 minFreq++; // 增加最小频率 } } // 增加访问频率，并将节点放入新的频率链表的最上面 pushFront(++node.freq, node); return node; // 返回节点 } // 创建一个新的双向链表（每个频率的链表） private Node newList() { Node dummy = new Node(0, 0); // 哑节点作为双向链表的头节点 dummy.prev = dummy; dummy.next = dummy; return dummy; } // 将节点添加到指定频率的链表头部（表示该节点最近被访问） private void pushFront(int freq, Node x) { Node dummy = freqToDummy.computeIfAbsent(freq, k -&gt; newList()); // 获取该频率对应的链表头（如果不存在则创建） x.prev = dummy; // 将节点的 prev 指向该频率链表的头 x.next = dummy.next; // 将节点的 next 指向该频率链表的第一个节点 x.prev.next = x; // 连接节点到链表头 x.next.prev = x; // 连接节点到链表的下一个节点 } // 从链表中删除一个节点 private void remove(Node x) { x.prev.next = x.next; // 删除节点的前后节点的连接 x.next.prev = x.prev; // 删除节点的前后节点的连接 }}}","link":"/%E7%AE%97%E6%B3%95/LRU%E4%B8%8ELFU%E7%BC%93%E5%AD%98%E6%9B%BF%E6%8D%A2/algorithm-fundamentals/"},{"title":"子串","text":"","link":"/%E5%8A%9B%E6%89%A3/%E5%8A%9B%E6%89%A3%E7%83%AD%E9%97%A8100/%E5%AD%90%E4%B8%B2/LC100-substring/"},{"title":"JAVA基础知识","text":"基础项操作系统(进程，线程，锁)计算机网络(TCP/IP)JDK容器、io(参考书籍:《Java核心技术ⅱ》)数据库事务、innoDB小厂:框架SpringBoot(SpringBoot启动流程/Spring生命周期)(全栈)Vue、react中厂:分布式SpringCloud、ZooKeeper…(参考书籍：《分布式系统》)NoSqlRedis(参考书籍：《Redis设计与实现》)消息队列如RabbitMQ、Kafka设计模式如单例、工厂、责任链大厂:数据结构与算法并发编程AQSCASJVMGC内存模型系统设计如何保证缓存一致性?负载均衡?分布式锁?多服务跨数据库实例的分布式事务?","link":"/JAVA/JAVA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9/java-base/"},{"title":"力扣每日一题","text":"3066. 超过阈值的最少操作数 II使用数据结构：优先队列 1","link":"/%E5%8A%9B%E6%89%A3/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/lcday/"},{"title":"JAVA常用API","text":"优先队列PriorityQueue在 Java 中，优先队列（PriorityQueue） 是一个基于堆（通常是最小堆）的数据结构，位于 java.util 包中。优先队列的元素会按照自然顺序或提供的比较器顺序进行排序。以下是关于优先队列的详细介绍： 特点 自动排序：默认是最小优先队列（最小堆），即每次取出的元素是当前队列中最小的元素。 非线程安全：PriorityQueue 不是线程安全的，如果需要线程安全，可以使用 PriorityBlockingQueue。 不允许 null 元素。 支持自定义顺序：可以通过传入 Comparator 定义元素的排序方式。 构造方法PriorityQueue 提供多种构造方法： 默认构造方法： 1PriorityQueue&lt;E&gt; pq = new PriorityQueue&lt;&gt;(); 创建一个初始容量为 11 的最小堆。 指定初始容量： 1PriorityQueue&lt;E&gt; pq = new PriorityQueue&lt;&gt;(int initialCapacity); 指定比较器： 1PriorityQueue&lt;E&gt; pq = new PriorityQueue&lt;&gt;(Comparator&lt;? super E&gt; comparator); 创建一个使用自定义比较器的优先队列。 通过集合初始化： 1PriorityQueue&lt;E&gt; pq = new PriorityQueue&lt;&gt;(Collection&lt;? extends E&gt; c); 常用方法以下是 PriorityQueue 的常用方法： 方法名 说明 add(E e) 向队列中添加元素，若超出容量会抛出异常。 offer(E e) 向队列中添加元素，推荐使用。 poll() 移除并返回队列的头部元素，若队列为空则返回 null。 peek() 返回队列的头部元素但不移除，若队列为空则返回 null。 remove(Object o) 删除队列中指定的元素。 size() 返回队列中元素的数量。 isEmpty() 判断队列是否为空。 clear() 清空队列中的所有元素。","link":"/JAVA/JAVA%E5%B8%B8%E7%94%A8API/java-data-structure/"},{"title":"听歌吗","text":"","link":"/%E5%A4%A9%E9%A9%AC%E8%A1%8C%E7%A9%BA/%E8%AF%97%E8%AF%8D%E6%AD%8C%E8%B5%8B/old-songs/"},{"title":"诗词歌赋","text":"哲理菩提偈惠能 唐代 菩提本无树，明镜亦非台。佛性常清净，何处有尘埃！ 身是菩提树，心为明镜台。明镜本清净，何处染尘埃！ 菩提本无树，明镜亦非台。本来无一物，何处惹尘埃！ 菩提只向心觅，何劳向外求玄？听说依此修行，西方只在目前！ 诀别卜算子·赠乐婉杭妓施酒监 宋代 相逢情便深，恨不相逢早。识尽千千万万人，终不似、伊家好。别你登长道。转更添烦恼。楼外朱楼独倚阑，满目围芳草。 卜算子·答施乐婉 宋代 相思似海深，旧事如天远。泪滴千千万万行，更使人、愁肠断。要见无因见，拚了终难拚。若是前生未有缘，待重结、来生愿。 山歌·亲老婆冯梦龙 明代 天上星多月弗多。雪白样雄鸡当弗得个鹅。煮粥煮饭还是自家田里个米。有病还需亲老婆。忽然道学。还是无病的日子多。","link":"/%E5%A4%A9%E9%A9%AC%E8%A1%8C%E7%A9%BA/%E8%AF%97%E8%AF%8D%E6%AD%8C%E8%B5%8B/poems/"},{"title":"基础乐理","text":"基础乐理知识一个曲谱有：调号、拍号、曲谱、歌词。 知道上述名称后，要从基础学起。 首先要明白音的性质：音高、音值、音量、音色。不同的乐器和人声都是通过这四项的不同变化才产生我们听到的音乐。 一、音及音高 音是由于物体的振动而产生的。音有高低、强弱、长短、音色等四种性质。 （1）音的高低是由于物体在一定时间内的振动次数(频率)而决定的。振动次数多，音则高;振动次数少，音则低。 （2）音的长短是由于音的延续时间的不同而决定的。音的延续时间长，音则长;音的延续时间短，音则短。 （3）音的强弱是由于振幅(音的振动范围的幅度)的大小而决定的。振幅大，音则强;振幅小，音则弱。 （4）音色则由于发音体的性质、形状及其泛音的多少等而不同。 由于音的振动状态的规则与不规则，音被分为乐音与噪音两类。音乐中所使用的主要是乐音，但噪音也是音乐表现中不可缺少的组成部分。 1、乐音体系音列音级 （1）在音乐中使用的、有固定音高的音的总和，叫做乐音体系。 （2）乐音体系中的音，按照上行或下行次序排列起来，叫做音列。 （3）乐音体系中的各音叫做音级。音级有基本音级和变化音级。 （4）乐音体系中，七个具有独立名称的音级叫做基本音级。 基本音级的名称是用字母和唱名两种方式来标记的。 字母体系：C D E F G A B 唱名体系：1 2 3 4 5 6 7 钢琴上白键所发出的音是与基本音级相符合的。钢琴上五十二个白键循环重复地使用七个基本音级名称。两个相邻的具有同样名称的音叫做八度。 升高或降低基本音级而得来的音，叫做变化音级。将基本音级升高半音用“升”或“#”来标明。降低半音用“降”或“b”来标明。升高全音用“重升”或“×”来标明。降低全音用“重降”或“bb”来标明。 如：升C或#C 降C或bC 2、音的分组 为了区分音名相同而音高不同的各音，我们将音列分成许多个“组”。 在音列中央的一组叫做小字一组。它的音级标记用小写字母并在右上方加数字1来表示。 比小字一组高的组顺次定名为：小字二组、小字三组、小字四组、小字五组。 小字二组的标记用小写字母并在右上方加数字2来表示。 比小字一组低的组，依次定名为小字组、大字组、大字一组及大字二组。 小字组各音的标记用不带数字的小写字母来表示。 大字组用不带数字的大写字母来标记。 大字一组用大写字母并在右下方加数字1来标明。 大字二组用大写字母并在右下方加数字2来标明。 3、音域及音区 总的音域是指音列的总范围，即从它的最低音(C2——c5)间的距离而言。 个别的人声或乐器的音域是指在整个音域中所能够达到的那一部分，如钢琴的音域是A2——c5。 音区是音域中的一部分，有高音区、低音区、中音区三种。 在整个音域中，小字组、小字一组和小字二组属于中音区。小字三组、小字四组和小字五组属高音区。大字组、大字一组和大字二组属低音区。 各音区的特性音色在音乐表现中，有着重大的意义。高音区一般具有清脆、嘹亮、尖锐的特性;而低音区则往往给人以浑厚、笨重之感。 二、音律 乐音体系中各音的绝对准确高度及其相互关系叫做音律。将八度分成十二个均等的部分——半音——的音律叫做十二平均律。 半音是十二平均律组织中最小的音高距离。两音间的距离等于两个半音的叫做全音。八度内包括十二个半音，也就是六个全音。 在音列中的基本音级中间，除了E到F、B到C是半音外，其余相邻两音间的距离都是全音。 根据复合音的第二分音和第三分音的纯五度关系，即由某一音开始向上推一纯五度，产生次一律，再由次一律向上推一纯五度，产生再次一律，如此继续相生所定出的音律叫做五度相生律。 纯律是于五度相生律用以构成的第二分音和第三分音之外，再加入第五分音来作为生律要素，构成和弦形式。 1、自然半音和自然全音变化半音和变化全音 由两个相邻的音级构成的半音叫做自然半音。如;e—f #e—#f #g—a 由相邻的两个音级形成的全音叫做自然全音。如：C—d C—#d ba—bB 由同一音级的两种不同形式所构成的半音，叫做变化半音。如：C—#C D—bD bbB—bB 由同一音级的两种不同形式或隔开一个音级所构成的全音，叫做变化全音。 如：B——bbB #C——bE 2、等音 音高相同而意义和记法不同的音，叫做等音。 1. 认识音符和节奏 学习内容： 音符（C、D、E、F、G、A、B）和升降音（#、b）的概念。 音名/音符是乐音体系中各音级各自的名称。现行通用音名为：CDEFGAB。除了音名还有do、re、mi、fa、sol、la、si这些音名，多用于歌唱，故又称唱名。除了音名和唱名以外，还有全音和半音，音高关系的最小计量单位，叫做“半音”，两个半音叫“全音”。 节奏符号（全音符、二分音符、四分音符等）。 节拍和拍号（如 4/4、3/4）。 练习建议： 在吉他上找到每根弦的音符位置。 打节拍器练习简单的节奏型。 2. 音阶与调式 学习内容： 自然大调音阶（C 大调）及其公式（全全半全全全半）。 自然小调音阶（A 小调）及其公式（全半全全半全全）。 了解调号和音阶关系。 练习建议： 在吉他指板上弹奏 C 大调和 A 小调音阶。 练习音阶爬格子，熟悉指板位置。 3. 和弦基础 学习内容： 什么是三和弦（大三和弦、小三和弦）。 常见和弦的构成音（如 C 和弦：C、E、G）。 和弦表记法（如 C、Am、G7）。 练习建议： 学会简单的和弦切换（如 C-G-Am-F）。 用和弦为简单的流行曲伴奏。","link":"/%E5%A4%A9%E9%A9%AC%E8%A1%8C%E7%A9%BA/%E4%B9%90%E7%90%86/musictheory/"},{"title":"建站过程","text":"什么是 Hexo？Hexo 是一个快速、简洁且高效的博客框架。 Hexo 使用 Markdown（或其他标记语言）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 详情请自行翻阅官网：https://hexo.io/zh-cn/docs/ 此处仅贴出常用指令自用。 1234567891011121314151617181920212223242526272829303132333435363738# 使用 npm 安装 Hexo$ npm install -g hexo-cli# 请自行替换文件夹名,新建一个网站$ hexo init &lt;folder&gt; $ cd &lt;folder&gt;$ npm install# 新建一篇文章,文章名称和标题为 [title],文章采用 [layout] 布局$ hexo new [layout] &lt;title&gt;$ hexo new &quot;post title with whitespace&quot; # 如果标题包含空格，需加引号# 清除缓存,网页正常情况下可以忽略此条命令,执行该指令后,会删掉站点根目录下的public文件夹$ hexo clean# 生成静态文件$ hexo generate$ hexo g# 发表草稿$ hexo publish [layout] &lt;filename&gt;# 启动服务器（常用于调试）$ hexo server$ hexo s# 部署网站,将本地数据部署到远端服务器(如github、coding)$ hexo deploy$ hexo d# 创建分类选项Created: ~\\myBlog\\source\\categories\\index.md$ hexo new page categories# 需分类的文章要添加# categories: # - web前端# 注意这里的分类名前需要一个空格#如果在“- web前端”下方添加“-xxx”，hexo不会产生两个分类，而是把分类嵌套（即该文章属于 “- web前端”下的 “-xxx ”分类）。","link":"/%E5%BB%BA%E7%AB%99%E7%9B%B8%E5%85%B3/Hexo%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/use-of-theme/"}],"tags":[],"categories":[{"name":"力扣","slug":"力扣","link":"/categories/%E5%8A%9B%E6%89%A3/"},{"name":"力扣热门100","slug":"力扣/力扣热门100","link":"/categories/%E5%8A%9B%E6%89%A3/%E5%8A%9B%E6%89%A3%E7%83%AD%E9%97%A8100/"},{"name":"贪心算法","slug":"力扣/力扣热门100/贪心算法","link":"/categories/%E5%8A%9B%E6%89%A3/%E5%8A%9B%E6%89%A3%E7%83%AD%E9%97%A8100/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"},{"name":"数组","slug":"力扣/力扣热门100/数组","link":"/categories/%E5%8A%9B%E6%89%A3/%E5%8A%9B%E6%89%A3%E7%83%AD%E9%97%A8100/%E6%95%B0%E7%BB%84/"},{"name":"矩阵","slug":"力扣/力扣热门100/矩阵","link":"/categories/%E5%8A%9B%E6%89%A3/%E5%8A%9B%E6%89%A3%E7%83%AD%E9%97%A8100/%E7%9F%A9%E9%98%B5/"},{"name":"技巧","slug":"力扣/力扣热门100/技巧","link":"/categories/%E5%8A%9B%E6%89%A3/%E5%8A%9B%E6%89%A3%E7%83%AD%E9%97%A8100/%E6%8A%80%E5%B7%A7/"},{"name":"多维动态规划","slug":"力扣/力扣热门100/多维动态规划","link":"/categories/%E5%8A%9B%E6%89%A3/%E5%8A%9B%E6%89%A3%E7%83%AD%E9%97%A8100/%E5%A4%9A%E7%BB%B4%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"链表","slug":"力扣/力扣热门100/链表","link":"/categories/%E5%8A%9B%E6%89%A3/%E5%8A%9B%E6%89%A3%E7%83%AD%E9%97%A8100/%E9%93%BE%E8%A1%A8/"},{"name":"滑动窗口","slug":"力扣/力扣热门100/滑动窗口","link":"/categories/%E5%8A%9B%E6%89%A3/%E5%8A%9B%E6%89%A3%E7%83%AD%E9%97%A8100/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"},{"name":"二叉树","slug":"力扣/力扣热门100/二叉树","link":"/categories/%E5%8A%9B%E6%89%A3/%E5%8A%9B%E6%89%A3%E7%83%AD%E9%97%A8100/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"栈","slug":"力扣/力扣热门100/栈","link":"/categories/%E5%8A%9B%E6%89%A3/%E5%8A%9B%E6%89%A3%E7%83%AD%E9%97%A8100/%E6%A0%88/"},{"name":"哈希","slug":"力扣/力扣热门100/哈希","link":"/categories/%E5%8A%9B%E6%89%A3/%E5%8A%9B%E6%89%A3%E7%83%AD%E9%97%A8100/%E5%93%88%E5%B8%8C/"},{"name":"二分查找","slug":"力扣/力扣热门100/二分查找","link":"/categories/%E5%8A%9B%E6%89%A3/%E5%8A%9B%E6%89%A3%E7%83%AD%E9%97%A8100/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"name":"算法","slug":"算法","link":"/categories/%E7%AE%97%E6%B3%95/"},{"name":"子串","slug":"力扣/力扣热门100/子串","link":"/categories/%E5%8A%9B%E6%89%A3/%E5%8A%9B%E6%89%A3%E7%83%AD%E9%97%A8100/%E5%AD%90%E4%B8%B2/"},{"name":"回溯","slug":"力扣/力扣热门100/回溯","link":"/categories/%E5%8A%9B%E6%89%A3/%E5%8A%9B%E6%89%A3%E7%83%AD%E9%97%A8100/%E5%9B%9E%E6%BA%AF/"},{"name":"JAVA","slug":"JAVA","link":"/categories/JAVA/"},{"name":"力扣每日一题","slug":"力扣/力扣每日一题","link":"/categories/%E5%8A%9B%E6%89%A3/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"name":"双指针","slug":"力扣/力扣热门100/双指针","link":"/categories/%E5%8A%9B%E6%89%A3/%E5%8A%9B%E6%89%A3%E7%83%AD%E9%97%A8100/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"天马行空","slug":"天马行空","link":"/categories/%E5%A4%A9%E9%A9%AC%E8%A1%8C%E7%A9%BA/"},{"name":"堆","slug":"力扣/力扣热门100/堆","link":"/categories/%E5%8A%9B%E6%89%A3/%E5%8A%9B%E6%89%A3%E7%83%AD%E9%97%A8100/%E5%A0%86/"},{"name":"动态规划","slug":"力扣/力扣热门100/动态规划","link":"/categories/%E5%8A%9B%E6%89%A3/%E5%8A%9B%E6%89%A3%E7%83%AD%E9%97%A8100/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"图论","slug":"力扣/力扣热门100/图论","link":"/categories/%E5%8A%9B%E6%89%A3/%E5%8A%9B%E6%89%A3%E7%83%AD%E9%97%A8100/%E5%9B%BE%E8%AE%BA/"},{"name":"LRU与LFU缓存替换","slug":"算法/LRU与LFU缓存替换","link":"/categories/%E7%AE%97%E6%B3%95/LRU%E4%B8%8ELFU%E7%BC%93%E5%AD%98%E6%9B%BF%E6%8D%A2/"},{"name":"JAVA基础知识点","slug":"JAVA/JAVA基础知识点","link":"/categories/JAVA/JAVA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"name":"JAVA常用API","slug":"JAVA/JAVA常用API","link":"/categories/JAVA/JAVA%E5%B8%B8%E7%94%A8API/"},{"name":"诗词歌赋","slug":"天马行空/诗词歌赋","link":"/categories/%E5%A4%A9%E9%A9%AC%E8%A1%8C%E7%A9%BA/%E8%AF%97%E8%AF%8D%E6%AD%8C%E8%B5%8B/"},{"name":"乐理","slug":"天马行空/乐理","link":"/categories/%E5%A4%A9%E9%A9%AC%E8%A1%8C%E7%A9%BA/%E4%B9%90%E7%90%86/"},{"name":"建站相关","slug":"建站相关","link":"/categories/%E5%BB%BA%E7%AB%99%E7%9B%B8%E5%85%B3/"},{"name":"Hexo常用指令","slug":"建站相关/Hexo常用指令","link":"/categories/%E5%BB%BA%E7%AB%99%E7%9B%B8%E5%85%B3/Hexo%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/"}],"pages":[{"title":"文章分类","text":"","link":"/categories/index.html"}]}