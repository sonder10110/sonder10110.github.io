{"posts":[{"title":"多维动态规划","text":"","link":"/%E5%8A%9B%E6%89%A3/%E5%8A%9B%E6%89%A3%E7%83%AD%E9%97%A8100/LC100-MDdp/"},{"title":"数组","text":"","link":"/%E5%8A%9B%E6%89%A3/%E5%8A%9B%E6%89%A3%E7%83%AD%E9%97%A8100/LC100-array/"},{"title":"回溯","text":"","link":"/%E5%8A%9B%E6%89%A3/%E5%8A%9B%E6%89%A3%E7%83%AD%E9%97%A8100/LC100-backtrack/"},{"title":"二叉树","text":"","link":"/%E5%8A%9B%E6%89%A3/%E5%8A%9B%E6%89%A3%E7%83%AD%E9%97%A8100/LC100-binary-tree/"},{"title":"二分查找","text":"","link":"/%E5%8A%9B%E6%89%A3/%E5%8A%9B%E6%89%A3%E7%83%AD%E9%97%A8100/LC100-binary-search/"},{"title":"双指针","text":"","link":"/%E5%8A%9B%E6%89%A3/%E5%8A%9B%E6%89%A3%E7%83%AD%E9%97%A8100/LC100-dual-pointer/"},{"title":"图论","text":"","link":"/%E5%8A%9B%E6%89%A3/%E5%8A%9B%E6%89%A3%E7%83%AD%E9%97%A8100/LC100-graph/"},{"title":"堆","text":"","link":"/%E5%8A%9B%E6%89%A3/%E5%8A%9B%E6%89%A3%E7%83%AD%E9%97%A8100/LC100-heap/"},{"title":"动态规划","text":"","link":"/%E5%8A%9B%E6%89%A3/%E5%8A%9B%E6%89%A3%E7%83%AD%E9%97%A8100/LC100-dp/"},{"title":"链表","text":"","link":"/%E5%8A%9B%E6%89%A3/%E5%8A%9B%E6%89%A3%E7%83%AD%E9%97%A8100/LC100-linked-list/"},{"title":"矩阵","text":"","link":"/%E5%8A%9B%E6%89%A3/%E5%8A%9B%E6%89%A3%E7%83%AD%E9%97%A8100/LC100-matrix/"},{"title":"技巧","text":"","link":"/%E5%8A%9B%E6%89%A3/%E5%8A%9B%E6%89%A3%E7%83%AD%E9%97%A8100/LC100-skill/"},{"title":"滑动窗口","text":"","link":"/%E5%8A%9B%E6%89%A3/%E5%8A%9B%E6%89%A3%E7%83%AD%E9%97%A8100/LC100-sliding-window/"},{"title":"子串","text":"","link":"/%E5%8A%9B%E6%89%A3/%E5%8A%9B%E6%89%A3%E7%83%AD%E9%97%A8100/LC100-substring/"},{"title":"贪心算法","text":"","link":"/%E5%8A%9B%E6%89%A3/%E5%8A%9B%E6%89%A3%E7%83%AD%E9%97%A8100/LC100-greedy/"},{"title":"栈","text":"","link":"/%E5%8A%9B%E6%89%A3/%E5%8A%9B%E6%89%A3%E7%83%AD%E9%97%A8100/LC100-stack/"},{"title":"人月神话","text":"&quot;success without applause, diligence without reward&quot;. 关于管理大型的计算机编程项目。本文仅仅用于记录，内容来源于《人月神话》，是清华大学出版的四十周年纪念版。 第一章 焦油坑 The Tar Pit &quot;A ship on the beach is a lighthouse to the sea.&quot;前车之覆，后车之鉴。 大型项目开发-&gt;焦油坑。 编程系统产品 程序、编程系统（接口、系统集成）、编程产品（通用化、测试、文档、维护）、编程系统产品（目标） 职业的乐趣 创建事物、开发有用的东西、组件组装、持续学习、神奇且灵活的创造 职业的苦恼 追求完美 设定的目标、供给资源、提供信息 依赖于他人（无可避免的，就像我讨厌让我写注释的，也讨厌别人不写注释的） 琐碎的bug、调试和查错 完成后陈旧过时... 第二章 人月神话 The Mythical Man Month &quot;Good cooking takes time. If you are made to wait, it is to serve you better, and to please you.&quot; 缺乏合理的进度安排 -&gt; 项目滞后 乐观主义 年轻的程序员。一切都将运作良好，每一项任务仅花费它所”应该“花费的时间。 创造性活动有三个阶段：构思、实现、交流。而计算机编程基于十分容易掌握的介质，加重了乐观主义。构思总是有缺陷的，总会有各种各样的bug存在。 在单个任务中，”一切都将运作良好“是可能的，但当进行大型的编程工作时，任务数目多，且存在先后次序，导致一切正常的概率几近于零。 人月 错误的估计和进度安排中的工作量：人月。 对于成本，确实是可以以人月计，但进度并非如此。 用人月作为衡量一项项目的规模是一个危险和带有欺骗性的神话。 人数与时间仅仅在参与人员间不需要任何相互交流时可行。当任务由于次序限制无法分解时，添加人手不会对进度有帮助。 沟通增加的负担：培训和相互的交流。 月-人的关系图会呈v字形，也就是增加人数，耗时反而会增加。 系统测试 单元测试和系统测试受顺序限制最大。且时间难以估计。 时间占比 任务 1/3 计划 1/6 编码 1/4 构件测试和早期系统测试 1/4 所有构件已完成，系统测试 空泛的估算 为了满足客户需求，造成不合理的进度安排。 重复产生的进度灾难 当项目落后于进度时，增加人手、重新安排进度、削减任务都是可能的选择。 &quot;Adding manpower to a late software project makes it later.&quot; --- Brooks法则，项目的时间依赖于顺序上的限制、人员的最大数量依赖于独立子任务的数量。 第三章 外科手术队伍 如何在有意义的进度安排内创建大型的系统？ 问题 在优秀程序员和较差程序员之间存在生产率的差异。沟通增加的负担：培训和相互的交流以及更正沟通不当所引起的不良结果（系统调试）。 进退两难的境地：对于效率和概念的完整性来说，最好由少数干练的人员来设计和开发，而对于大型系统则需要大量人手，以使产品能在时间上满足要求。 Mills的建议 建议大型项目的每一个部分由一个团队解决，以类似外科手术队伍的方式组建，而非一拥而上。也就是说，同每个成员截取问题某个部分的做法相反，由一个人来完成问题的分解，其他人给予他所需要的支持以提高效率和生产力。 外科队伍 项目人员 职能 外科医生 首席程序员 定义功能和性能技术说明书，设计程序，编制源代码，测试，书写技术文档。 后备 副手 能完成任何一部分工作，但相对经验较少。主要作为设计的思考者、讨论者和评估人员。充当外科医生的保险机制。 老板 管理员 在人员、薪酬、办公室等方面具有决定权，但不能在这些方面浪费任何时间。需要有一个控制财务、人员、工作地点、办公设备的专业人员，充当与组织中其他管理机构的接口。可以服务两个团队。 编辑 考虑透明度，外科医生必须创建各种文档，编辑则根据草稿或口述进行重新分析和重新组织，提供各种参考信息和书目，对多个版本进行维护，并监督文档生成的机制。 文秘*2 管理员和编辑各一个。管理员的文秘负责非产品文件和项目协作一致。 程序职员 负责维护编程产品库中所有团队的技术记录。 工具维护人员 保证所有基本服务的可靠性，承担团队成员所需要的特殊工具（尤其是交互式计算机服务）的构建、维护和升级责任。 测试人员 设计测试用例、负责计划测试的步骤和为单元测试搭建测试平台。 语言专家 寻找一种简洁有效的使用语言的方法来解决复杂、晦涩、棘手的问题。 Mills概念的关键是“从个人艺术到公共实践”的编程观念转换。 如何运作 上述团队中7个专业人士在解决问题，而系统是一个人或两个人思考的产物，在客观上达到了概念的一致性。下图为10人程序开发队伍的沟通模式 团队的扩建 当面对大型任务时，该如何应用外科手术团队的概念呢？ 关键在于提高每个部分的概念完整性。 第四章 贵族专制、民主政治和系统设计 Aristocracy、Democracy and System Design 概念的完整性 哥特式教堂上依附着诺曼底风格的十字架——上帝的荣耀、建筑师的骄傲 概念完整性在系统设计中是很重要的因素，为了反映一系列连贯的设计思路，宁可省略一些不规则的特性和改进，也不提倡独立和无法整合的系统。 获得概念的完整性 简洁和直白来自概念的完整性，每个部分必须反映相同的原理需求的一致平衡。在语法上，每个部分应使用相同的技巧；在语义上，应具有同样的相似性。因此，易用性需要设计的一致性和概念上的完整性。 贵族专制统治和民主政治 系统的体系结构是指完整和详细的用户接口说明。如Blaauw所说，体系结构陈述的是发生了什么，而实现描述的是如何实现。本书中的体系结构更偏向于现今的需求概念，而业界广泛认为的体系结构是系统的框架，属于设计层次。 结构师-&gt;贵族 是贵族专制统治，而非民主政治。 在等待时，实现人员应该做什么 整个创造性活动包括三个独立的阶段：体系结构(architecture)、设计实现(implementation)、物理实现(realization)。实际情况中，他们可以同时开始和并发地进行。 第五章 画蛇添足 The Second-System Effect Adde parvum parvo magnus acervus erit.聚沙成塔，集腋成裘。 将制定功能规格说明的责任从开发快速、成本低廉的产品的责任中分离出来，有什么准则和机制来约束结构师的创造性热情呢？ 结构师的交互准则和机制 牢记是开发人员承担创造性和发明性的实现责任，所以结构师只能建议而不能支配； 时刻准备着为所指定的说明建议一种实现的方法，同样准备接受其他任何能达到目标的方法； 对上述的建议保持低调和不公开； 准备放弃坚持所作的改进建议。 自律——开发第二个系统所带来的后果 结构师在开发第一个系统时更倾向于精炼和简洁。他知道自己对任务不够了解。 而设计第一个项目时，会有不断产生的装饰和润色功能。这些功能被暂时搁置，作为下一个项目的内容。当开发第二个系统时，信心满满。但是当着手第三个或者第四个系统时，先前的经验会相互验证，得到对此类系统通用特性的判断，而且系统之间的差异会帮助他识别出经验中不够通用的部分。一种普遍的倾向是过分地设计第二个系统。但添加的修饰功能和想法是一个“大馅饼”。 如何避免这种画蛇添足，这需要结构师有意识地关注这个系统的特殊危险，运用特别的自我约束准则，来避免那些功能上的过多修饰，根据系统基本理念及目的变更，舍弃一些功能。 第六章 贯彻执行 Passing the Word He'll sit here and he'll say, &quot;Do this! Do that!&quot; And nothing will happen. ——Harry Truman, On Presidental Power. 他只是坐在那里，嘴里说：“做这个！做那个！”当然，什么都不会发生，光说不做是没有用的。 如果一个项目经理已经拥有行事规范、富有经验的结构师和许多编程实现人员，那么，他该如何确保每个人听到、理解并实现结构师的决策？如何保持系统概念上的完整性？ 文档化的规格说明——手册 手册/书面规格说明：描述并规定了用户所见的每一个细节，是结构师主要的工作产物。手册不仅要描述包括所有界面在内的用户可见的一切，还要避免描述用户看不见的事物。后者是编程实现人员的工作范畴，而其设计和创造是不应该被限制的。体系结构设计人员必须为自己描述的任何特性准备一种实现方法，但是他不应该试图支配具体的实现过程。 规格说明的风格必须清晰、完整、准确。用户常常会提到某个定义，所以每条说明必须重复所有的基本要素，所有文字都要相互一致。尽管这使得手册枯燥无味，但精确远比生动更加重要。 规则说明会不断地被质疑、重复准备、修改。实现人员应该在进度表上有带日期的版本信息。 形式化定义 “不要携带两个时钟出海，带一个或三个。”该原则同样适用于形式化定义和记叙性定义。如果同时具有两种方式，则必须以其中一种作为作为标准，另一种作为辅助描述，并照此明确地进行划分。 直接整合 传播和推行定义：设计被传递参数或共享存储器的声明，并要求编程实现在编译时的一些操作来包含这些声明。 会议和大会 周例会：每周半天的会议，由所有的结构师、硬件和软件实现人员代表以及市场计划人员参与，由首席系统结构师主持。建议书在会议前书面分发。新问题讨论的重点是创新而不是结论。变更决策如果不能达成共识，则由首席结构师决定。 年度大会：为解决周例会未能解决的小要求、公开问题或者不愉快。一般持续两周。出席人员包括体系结构小组和编程人员、实现人员的结构代表，还包括编程经理、市场和实现人员，由项目经理主持。 多重实现 在大多数计算机项目中，机器和手册之间往往会在某一天出现不一致，人们通常会忽略手册。因为与机器相比手册更容易改动，并且成本更低。然而，当存在多重实现时，如实地遵从手册更新机器所造成的延迟和成本的消耗，比根据机器调整手册要低。 电话日志 对于结构理解和解释方面的问题，需要文字澄清和解释，但也有仅仅是理解不当的。所以鼓励打电话询问相应的结构师，而不是一边自行猜测一边工作。同时，上述问题的答案必须是可以告知每个人的权威性结论。 一种有用的机制是由结构师保存电话日志。日志中记录问题及答案，每周进行整合分发。 产品测试 独立的产品测试机构/小组：根据规格说明检查机器和程序，充当麻烦的代言人，查明每一个可能的缺陷和相互矛盾的地方。 第七章 为什么巴比伦塔会失败 Why Did the Tower of Babel Fail? 现在整个大地都采用一种语言，只包括为数不多的单词。在一次从东方往西方迁徙的过程中，人们发现了苏美尔地区的一处平原，并在那里定居下来。接着他们奔走相告说：“来，让我们制造砖块，并把它们烧好。”于是，他们用砖块代替石头，用沥青代替灰泥（建造房屋）。然后，他们说：“来，让我们建造一座带有高塔的城市，这个塔将高达云霄，也将让我们声名远扬；同时，有了这个城市，我们就可以聚居在这里，再也不会分散在广阔的大地上了。”于是上帝决定下来看看人们建造的城市和高塔。看了以后，他说：“他们只是一个种族，使用一种语言，如果他们一开始就能建造城市和高塔，那么以后就没有什么难得倒他们了。来，让我们下去，在他们的语言里制造一些混淆，让他们相互之间不能听懂。”这样，上帝把人们分散到世界各地，于是他们不得不停止建造那座城市。 ——《创世纪》，11:1-8 巴比伦塔的管理教训 据《创世纪》记载，巴比伦塔是人类继诺亚方舟之后的第二大工程壮举，同时也是一个彻底失败的工程。单单从管理上看这个项目。 他们具有清晰的目标、充足的人力、丰富的材料、足够的时间、足够的技术。那为什么还会失败呢？ 他们缺乏交流和交流的结果——组织。交流的缺乏导致了争辩、沮丧和群体猜忌。 大型编程项目中的交流 随着工作的进行，许多小组慢慢地修改自己程序的功能、规模和速度，他们明确或者隐含地更改了一些有效输入和输出结果用法上的约定。 团队如何进行交流沟通呢？ 非正式途径。清晰定义小组内部的相互关系和充分利用电话，鼓励大量的电话沟通，从而达到对所书写文档的共同理解。 会议。常规项目会议上进行简要的技术陈述。 工作手册。项目的开始阶段。 项目工作手册 是什么？ 对项目必须产出的一系列文档进行组织的一种结构。项目所有文档都应该是该结构的一部分。包括目的、外部规格说明、接口说明、技术标准、内部说明和管理备忘录。 为什么？ 技术说明是必不可少的。 控制信息发布，确保信息能到达所有需要它的人手中。可以使用树状结构。 处理机制。 纸质版、微缩胶片、文档 大型编程项目的组织架构 如果项目有n个人，则有(n2−n)/2(n^2-n)/2(n2−n)/2个相互交流的接口，有将近2n个必须合作的潜在团队。减少交流的方法是人力划分（division of labor）和限定职责范围（specialization of function）。 树状组织架构是作为权力和责任的结构而出现的。其基本角色——管理角色的非重复性——导致了管理结构是树状的。但交流结构是网状结构的。 对于树状编程队伍，每棵子树都应具备以下基本要素： 任务（a mission） 产品负责人（a producer）：组建团队、划分工作、制定进度表。保证资源。 技术主管或结构师（a technical director or architect） 进度（a schedule） 人力的划分（a division of labor） 各部分之间的接口定义（interface definitions among the parts） 第八章 胸有成竹 Portman的数据 Aron的数据 Harr的数据 OS/360的数据 Corbato的数据 第九章 削足适履 作为成本的程序空间 规模控制 空间技能 数据的表现形式是编程的根本 第十章 提纲挈领 计算机产品的文档 大学科系的文档 软件项目的文档 为什么要有正式的文档 第十一章 未雨绸缪 试验性工厂和增大规模 唯一不变的就是变化本身 为变更设计系统 为变更计划组织架构 前进两步，后退一步 前进一步，后退一步 第十二章 干将莫邪 目标机器 辅助机器和数据服务 高级语言和交互式编程 第十三章 整体部分 提出bug的设计 构件单元测试 系统集成调试 第十四章 祸起萧墙 里程碑还是沉重的负担 “其他的部分反正会落后” 地毯的下面 第十五章 另外一面 需要什么样的文档 流程图 自文档化的程序 第十六章 没有银弹 摘要 介绍 根本困难 以往解决次要困难的一些突破 银弹的希望 针对概念上根本问题的颇具前途的方法 第十七章 再论“没有银弹” 人狼和其他恐怖传说 存在着银弹——就在这里 含糊的表达将会导致误解 Harel的分析 Jones的观点——质量带来生产率 那么，生产率的情形如何 面向对象编程——这颗铜质子弹可以吗 重用的情况怎样 学习大量的词汇——对软件重用的一个可预见但还没有被预言的问题 子弹的本质——形势没用发生改变 第十八章 《人月神话》的观点：是与非 第一章 焦油坑 The Tar Pit 第二章 人月神话 The Mythical Man Month 第三章 外科手术队伍 第四章 贵族专制、民主政治和系统设计 第五章 画蛇添足 第六章 贯彻执行 第七章 为什么巴比伦塔会失败 第八章 胸有成竹 第九章 削足适履 第十章 提纲挈领 第十一章 未雨绸缪! 第十二章 干将莫邪 第十三章 整体部分 第十四章 祸起萧墙 第十五章 另外一面 第一版结束语 第十九章 20年后的《人月神话》 为什么要出版20周年纪念版本 核心观点——概念完整性和结构师 开发第二个系统所引起的后果——盲目的功能和频率猜测 图形界面的成功 没有构建舍弃模型——瀑布模型是错误的 增量开发模型更佳——渐进地精化","link":"/%E8%AF%BB%E4%B9%A6/The-Mythical-Man-Month/"},{"title":"文件读写","text":"文件读取 遍历指定文件夹下的文件： 123456# 遍历文件夹for root, dirs, files in os.walk(folder_path): for file in files: if file.endswith('.csv'): # 检查文件扩展名是否为 .csv csv_path = os.path.join(root, file) # 获取文件的完整路径 print(f&quot;找到 CSV 文件: {csv_path}&quot;)","link":"/PYTHON/files-in-py/"},{"title":"STtable","text":"ST表 P3865 【模板】ST 表 &amp;&amp; RMQ 问题 - 洛谷 | 计算机科学教育新生态 静态区间最大值 给定一个长度为 N 的数列，和 M 次询问，求出每一次询问的区间内数字的最大值。 输入: 第一行包含两个整数 N,M，分别表示数列的长度和询问的个数。 第二行包含 N 个整数（记为 ai ），依次表示数列的第 i 项。 接下来 M 行，每行包含两个整数 li,ri，表示查询的区间为 [li, ri] 123456789108 89 3 1 7 5 6 0 81 61 52 72 61 84 83 71 8 输出 1234567899779879 例如数据，9 3 1 7 5 6 0 8，生成ST表为，其中第i行表示每个数后面\\math-container{2\\power{i}}个数的区间最大值。 例如i=2，那么就是每个数为基准，长度为4的区间最值。 下标j 1 2 3 4 5 6 7 8 原始i=0 9 3 1 7 5 6 0 8 i=1 9 3 7 7 6 6 8 i=2 9 7 7 7 8 i=3 9 倍增和动规 a[i][j]=max(a[i−1][j],a[i−1][j+(1≪i−1)])a[i][j]=max(a[i-1][j],a[i-1][j+(1≪i-1)])a[i][j]=max(a[i−1][j],a[i−1][j+(1≪i−1)])，1左移一位是2 查询时，例如要查询3到7区间最值，我们先计算这个区间包含几个元素，7-3+1=5个元素，再计算5对应的是2的2次方，那么可知答案就是在ST表的第二行，a[2][3]a[2][3]a[2][3]表示3为起点的4个元素的最大值，那么就是3-6区间，另外一个区间终点为7，那么起点是7-4+1，即4-7区间的4个元素，所以求a[2][3]a[2][3]a[2][3]和a[2][4]a[2][4]a[2][4]两个区间即可。 建表是nlognnlognnlogn的复杂度，查询是1的复杂度 可用AC 123456789101112131415161718192021#include&lt;bits/stdc++.h&gt;using namespace std;int n, m, x, y, a[20][100005], len;int main(){ scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for(int i = 1; i &lt;= n; i++)scanf(&quot;%d&quot;, &amp;a[0][i]); len = log2(n); for(int i = 1; i &lt;= len; i++) for(int j = 1; j &lt;= n - (1 &lt;&lt; i) + 1; j++) a[i][j] = max(a[i-1][j], a[i-1][j+(1&lt;&lt;i-1)]); for(int i = 1; i &lt;= m; i++){ scanf(&quot;%d%d&quot;, &amp;x, &amp;y); len = log2(y-x+1); printf(&quot;%d\\n&quot;, max(a[len][x], a[len][y-(1&lt;&lt;len)+1])); } return 0;}","link":"/%E7%AE%97%E6%B3%95/STtable/"},{"title":"背包问题","text":"计算机科学、算法设计和优化理论中非常著名的“背包问题”（Knapsack Problem）是一个典型的组合优化问题，也是动态规划算法的一个经典应用。 背包问题有多种变体，但最基本的形式是： 给定一组物品，每种物品都有自己的重量和价值，在限定的总重量内，如何选择装入背包的物品，使得背包内物品的总价值最大。 0-1背包 有n件物品和一个最多能背重量为w 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。每件物品只能用一次，求解将哪些物品装入背包里物品价值总和最大。 暴力解法应该是怎么样的呢？ 每一件物品其实只有两个状态，取或者不取，所以可以使用回溯法搜索出所有的情况，那么时间复杂度就是O(2^n)，这里的n表示物品数量。 背包最大重量为4。 物品为： 物品 重量 价值 0 1 15 1 3 20 2 4 30 问背包能背的物品最大价值是多少？ 确定dp数组以及下标的含义： 需要使用二维数组，为什么呢？因为有两个维度需要表示，分别是：物品 和 背包容量 那么这里 i,j,dp[i][j] 分别表示什么呢？ i 来表示物品、j表示背包容量。 dp[i][j] 表示从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少。 确定递推公式 对于递推公式，首先我们要明确有哪些方向可以推导出 dp[i][j]。 不放物品i：由dp[i - 1][j]推出，此时dp[i][j]就是dp[i - 1][j]。 放物品i：由dp[i - 1][j - weight[i]]推出，dp[i - 1][j - weight[i]] 为背包容量为j - weight[i]的时候不放物品i的最大价值，那么dp[i - 1][j - weight[i]] + value[i] （物品i的价值），就是背包放物品i得到的最大价值 递归公式： dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]) dp数组如何初始化 关于初始化，一定要和dp数组的定义吻合，否则到递推公式的时候就会越来越乱。 首先从dp[i][j]的定义出发，如果背包容量j为0的话，即dp[i][0]，无论是选取哪些物品，背包价值总和一定为0。 再看状态转移方程 dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]); 可以看出i 是由 i-1 推导出来，那么i为0的时候就一定要初始化。 dp[0][j]，即：i为0，存放编号0的物品的时候，各个容量的背包所能存放的最大价值。 那么很明显当 j &lt; weight[0]的时候，dp[0][j]应该是 0，因为背包容量比编号0的物品重量还小。 当j &gt;= weight[0]时，dp[0][j] 应该是value[0]，因为背包容量放足够放编号0物品。 确定遍历顺序 有两个遍历的维度：物品与背包重量 这里降维会逆序，要理解 举例推导dp数组 46. 携带研究材料（第六期模拟笔试） 二维dp代码如下： 12345678910111213141516171819202122232425262728293031def fun(n, weights, vals): nums, bag = n[0], n[1] # dp[i][j] 表示从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少 dp = [[0] * (bag + 1) for _ in range(nums)] # 背包容量j为0的话，即dp[i][0] = 0 # dp[0][j]，即：i为0，存放编号0的物品的时候，各个容量的背包所能存放的最大价值 for j in range(weights[0], bag + 1): print(j) dp[0][j] = vals[0] print(dp) # dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]) for i in range(1, nums): for j in range(bag + 1): if j &lt; weights[i]: dp[i][j] = dp[i - 1][j] else: dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weights[i]] + vals[i]) print(dp) return dp[-1][-1]if __name__ == '__main__': # n, weight, vals = ([int(x) for x in input().split()], # [int(x) for x in input().split()], # [int(x) for x in input().split()]) n = [6, 1] weights = [2, 2, 3, 1, 5, 2] vals = [2, 3, 1, 5, 4, 3] print(fun(n, weights, vals)) # 5 优化成一维dp： 其实可以发现如果把dp[i - 1]那一层拷贝到dp[i]上，表达式完全可以是：dp[i][j] = max(dp[i][j], dp[i][j - weight[i]] + value[i]); 与其把dp[i - 1]这一层拷贝到dp[i]上，不如只用一个一维数组了，只用dp[j]（一维数组，也可以理解是一个滚动数组）。即dp[j] = max(dp[j], dp[j - weight[i]] + value[i]); 这就是滚动数组的由来，需要满足的条件是上一层可以重复利用，直接拷贝到当前层。 二维dp遍历的时候，背包容量是从小到大，而一维dp遍历的时候，背包是从大到小。 为什么呢？ 倒序遍历是为了保证物品i只被放入一次！如果一旦正序遍历了，那么物品0就会被重复加入多次！ 123456789101112131415161718# https://kamacoder.com/problempage.php?pid=1046def fun(): n, weight, vals = ([int(x) for x in input().split()], [int(x) for x in input().split()], [int(x) for x in input().split()]) nums, bag = n[0], n[1] dp = [0] * (bag + 1) for j in range(weight[0], bag + 1): dp[j] = vals[0] for i in range(1, nums): for j in range(bag, weight[i] - 1, -1): dp[j] = max(dp[j], dp[j - weight[i]] + vals[i]) return dp[bag]if __name__ == '__main__': print(fun()) 416. 分割等和子集 - 力扣（LeetCode） 当做01背包做，总容量是已知的 当某个dp达到target后，就填满了背包 执行用时分布1993ms，击败26.68% 消耗内存分布38.73MB，击败5.89% 1234567891011121314151617181920212223242526class Solution(object): def canPartition(self, nums): # 1 - 100 total = sum(nums) if total % 2: return False target = total // 2 length = len(nums) # 总容量是target # 重量和价值都是num # 背包满时即为一个子集 # 另一个是剩下的就行 dp = [[0] * (target + 1) for _ in range(length)] # dp[i][j]表示背包容量为j时从0-i中任取所得到的最大总和 # dp[0][j] 表示背包容量为j时从0中任取所得到的最大总和 for j in range(nums[0], target + 1): dp[0][j] = nums[0] for i in range(1, length): for j in range(target + 1): if j &lt; nums[i]: dp[i][j] = dp[i - 1][j] else: dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - nums[i]] + nums[i]) if dp[i][j] == target: return True return False 降维： 这里可以思考下为什么遍历变成倒序了 依旧正序是错误的，127 / 143 个通过的测试用例 12345678910111213141516171819202122class Solution(object): def canPartition(self, nums): # 1 - 100 total = sum(nums) if total % 2: return False target = total // 2 length = len(nums) dp = [0] * (target + 1) # dp[j]表示背包容量为j时从0-i中任取所得到的最大总和，i被降维了，滚动数组 # dp[j] 表示背包容量为j时从0中任取所得到的最大总和 for j in range(nums[0], target + 1): dp[j] = nums[0] for i in range(1, length): for j in range(target + 1): if j &lt; nums[i]: dp[j] = dp[j] else: dp[j] = max(dp[j], dp[j - nums[i]] + nums[i]) if dp[j] == target: return True return False 如果使用一维dp数组，物品遍历的for循环放在外层，遍历背包的for循环放在内层，且内层for循环倒序遍历！ 倒序后： 执行用时分布1518ms，击败71.56% 消耗内存分布12.13MB，击败51.08% 123456789101112131415161718192021class Solution(object): def canPartition(self, nums): # 1 - 100 total = sum(nums) if total % 2: return False target = total // 2 length = len(nums) dp = [0] * (target + 1) for j in range(nums[0], target + 1): dp[j] = nums[0] for i in range(1, length): for j in range(target, -1, -1): if j &lt; nums[i]: dp[j] = dp[j] else: dp[j] = max(dp[j], dp[j - nums[i]] + nums[i]) if dp[j] == target: return True return False 去掉了没有变化的dp[j] = dp[j] 执行用时分布1579ms，击败70.24% 消耗内存分布11.97MB，击败76.67% 12345678910111213141516171819class Solution(object): def canPartition(self, nums): # 1 - 100 total = sum(nums) if total % 2: return False target = total // 2 length = len(nums) dp = [0] * (target + 1) for j in range(nums[0], target + 1): dp[j] = nums[0] for i in range(1, length): for j in range(target, -1, -1): if j &gt;= nums[i]: dp[j] = max(dp[j], dp[j - nums[i]] + nums[i]) if dp[j] == target: return True return False 1046. 最后一块石头的重量 - 力扣（LeetCode） 用堆做 1234567891011121314151617class Solution(object): def lastStoneWeight(self, stones): hq = [] for s in stones: heapq.heappush(hq, -s) while hq: v1 = -heapq.heappop(hq) if not hq: return v1 v2 = -heapq.heappop(hq) if v1 != v2: heapq.heappush(hq, -abs(v1 - v2)) return 0 执行用时分布15ms，击败63.38% 消耗内存分布11.46MB，击败43.66% v1 v2的大小关系是已知的，没必要用绝对值abs() 以及堆的初始化可以更简单 123456789101112131415class Solution(object): def lastStoneWeight(self, stones): hq = [-s for s in stones] heapq.heapify(hq) while hq: v1 = -heapq.heappop(hq) if not hq: return v1 v2 = -heapq.heappop(hq) if v1 != v2: heapq.heappush(hq, v2 - v1) return 0 1049. 最后一块石头的重量 II - 力扣（LeetCode） 提示： 把最终的答案看作是权重的总和，每个权重前面都有+或-符号。实际上，每个符号的和都是1。 使用动态规划:对于每一个可能的和N颗石头，这些和+x或-x可能与N+1颗石头，其中x是最新的石头的值。(这将多算全部为正或全部为负的总和，但这些都无关紧要。) 和分割子集完全一个思路捏 执行用时分布34ms，击败53.47% 消耗内存分布11.39MB，击败86.12% 123456789101112131415161718class Solution(object): def lastStoneWeightII(self, stones): total = sum(stones) target = total // 2 # 总容量是target # 重量和价值都是stone dp = [0] * (target + 1) # dp[j]表示背包容量为j时从0-i中任取所得到的最大总和，i被降维了，滚动数组 # dp[j] 表示背包容量为j时从0中任取所得到的最大总和 for j in range(stones[0], target + 1): dp[j] = stones[0] for i in range(1, len(stones)): for j in range(target, -1, -1): if j &gt;= stones[i]: dp[j] = max(dp[j], dp[j - stones[i]] + stones[i]) # print(dp) return total - 2 * dp[-1] 494. 目标和 - 力扣（LeetCode） 可以回溯法硬解，但为什么它也可以是背包？ 首先，确实对于每一个num都有两种选择，取正或负 dp = [0] * (m + 1) 和 dp[0] = 1： 创建一个长度为 m + 1 的列表 dp，用于存储不同和值的组合数。 初始化 dp[0] 为 1，表示空集的和为 0，只有一种方法。 两层循环： 外层循环遍历数组 nums 中的每个元素。 内层循环从 m 倒序遍历到 0。 如果当前和值 j 大于等于当前数组元素 nums[i]，说明可以选择当前元素加入子集中，此时 dp[j] 的值等于不选择当前元素的组合数（即 dp[j]）加上选择当前元素的组合数（即 dp[j - nums[i]]）。 执行用时分布39ms，击败77.99% 消耗内存分布11.30MB，击败95.60% 474. 一和零 - 力扣（LeetCode） 执行用时分布1586ms，击败65.91% 消耗内存分布11.55MB，击败74.93% 01背包，但是物品重量有两个维度 1234567891011121314class Solution(object): def findMaxForm(self, strs, m, n): # m个0, n个1 dp = [[0] * (n + 1) for _ in range(m + 1)] # dp[i][j]表示有i个0，j个1的满足条件的最大组合数 for s in strs: c0 = s.count('0') c1 = len(s) - c0 print(&quot;c0&quot;, c0, &quot;c1&quot;, c1) for i in range(m, c0 - 1, -1): for j in range(n, c1 - 1, -1): dp[i][j] = max(dp[i][j], dp[i - c0][j - c1] + 1) print(dp) return dp[-1][-1] 完全背包问题 问题描述：与0-1背包问题类似，但每种物品的数量是无限的。 解法：同样使用动态规划，但状态转移方程有所不同。由于每种物品可以无限次使用，因此在更新dp[i][j]时，需要考虑从dp[i-1][j]（不选第i个物品）和dp[i][j-wt[i]]+val[i]（选择第i个物品，且假设之前已经选择了足够的空间来放下它）中选择较大的值。 多重背包问题 每种物品有一定数量的限制。 分组背包问题 物品被划分为若干组，每组中的物品互斥（即每组中最多只能选一个物品），求解最优解。 二维背包问题：除了重量和价值外，还考虑了其他维度的限制（如体积、时间等）。 记忆中的背包 - BZOJ 4971 - Virtual Judge 构造","link":"/%E7%AE%97%E6%B3%95/bag/"},{"title":"比较器","text":"Arrays.sort()：用于给数组排序，默认从小到大。 但有时候希望数组逆序排序，这需要借助比较器。在 Java 中，比较器是一个实现了 Comparator 接口的类，它定义了用于比较两个对象的方法。比较器允许我们根据自定义的比较规则对对象进行排序。Comparator 接口中最重要的方法是 compare 方法，该方法接受两个参数，分别是要比较的两个对象，并返回一个整数值，表示它们的相对顺序。定义中Comparator是使用了泛型的，泛型的本质是引用，不能传入基本数据类型（如int，long），如有需要可转换为Integer等类型。 int compare(T o1, T o2);，用于定义排序规则。该方法的参数也是泛型T，即排序的元素也不能是基本数据类型。该方法返回的整数值含义如下： 如果 obj1 小于 obj2，则返回负整数。 如果 obj1 等于 obj2，则返回零。 如果 obj1 大于 obj2，则返回正整数。 比较器允许我们在不修改对象自身的情况下，根据需要定义不同的排序规则。它通常用于对集合类（如 List、Set）中的元素进行排序。 创建比较器：需要实现Comparator接口并重写compare方法。 12345678import java.util.Comparator;public class IntegerComparator implements Comparator&lt;Integer&gt; { @Override public int compare(Integer num1, Integer num2) { return num1 - num2; // 升序 }} 创建了比较器后，可以将其传递给排序方法，例如 Collections.sort() 或 Arrays.sort()，来对对象进行排序。 降序排序 当需要逆序（从大到小排列）的时候，需要 return o2-o1。 多属性排序 在compare函数中逐一比较属性。 泛型比较器 在不同类型的对象上使用相同的比较规则。可以比较实现了Comparable接口的任何对象。 12345678import java.util.Comparator;public class GenericComparator&lt;T extends Comparable&lt;T&gt;&gt; implements Comparator&lt;T&gt; { @Override public int compare(T obj1, T obj2) { return obj1.compareTo(obj2); }} Lambda 表达式比较器 从 Java 8 开始，可以使用 Lambda 表达式更简洁地创建比较器。例如，要对字符串按长度进行排序，可以使用 Lambda 表达式： 1234567891011121314import java.util.Comparator;public class StringLengthComparator { public static void main(String[] args) { Comparator&lt;String&gt; lengthComparator = (str1, str2) -&gt; str1.length() - str2.length(); List&lt;String&gt; strings = Arrays.asList(&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;, &quot;date&quot;); Collections.sort(strings, lengthComparator); for (String str : strings) { System.out.println(str); } }} 使用注意事项 在使用比较器（Comparator）进行排序时，有一些注意事项需要牢记： 处理可能的空值：比较器应该能够处理可能为 null 的对象。如果不进行处理，可能会导致 NullPointerException 异常。可以在比较器中添加额外的逻辑来处理 null 值，或者使用 nullsFirst 和 nullsLast 方法来定义 null 值的排序规则。 一致性和传递性：确保您的比较器逻辑具有一致性和传递性。一致性意味着如果 compare(a, b) 返回零，那么 compare(b, a) 也应该返回零。传递性意味着如果 compare(a, b) 返回负数，compare(b, c) 也应该返回负数，则 compare(a, c) 应该返回负数。 避免整数溢出：在比较整数或长整数时，要小心整数溢出的问题。确保比较逻辑能够处理可能出现的整数溢出情况，或者使用更安全的方式进行比较。 考虑性能：了解比较器的性能特性并根据数据集大小选择合适的排序算法。对于大型数据集，选择更高效的排序算法可能更有利。 测试和验证：在使用比较器进行排序之前，始终测试和验证排序结果是否符合预期。尤其是在使用自定义比较器或多属性排序时，测试非常重要。 使用标准比较器：Java 提供了一些标准的比较器，如 Comparator.naturalOrder() 和 Comparator.reverseOrder()，它们可以用于常见的升序和降序排序需求。尽量使用这些标准比较器简化代码。 谨慎使用 compareTo 方法：当使用对象的 compareTo 方法进行比较时，要确保对象的 compareTo 方法已正确实现。如果不确定，最好使用自定义的比较器以确保一致性。 总之，使用比较器进行排序是 Java 中非常有用的功能，但要谨慎处理可能出现的问题，并在需要时根据特定需求编写自定义比较器。良好的比较器可以帮助您实现各种排序需求，提高代码的可维护性和可读性。","link":"/JAVA/JAVA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9/comparator/"},{"title":"位运算","text":"位运算是对整数在二进制位层面上进行直接操作的运算。它在性能敏感的程序中尤其重要，例如操作系统、嵌入式系统、加密算法等领域，通常比普通的算术运算更高效。 1. 按位“或”运算的性质（OR） 对于任意两个整数 A 和 B，按位或运算（A | B）具有以下几条重要性质： 1.1. 自反性（Idempotence） 任何数与自身做按位或运算，结果仍然是自身。例如： 5 | 5 = 5 1.2. 单调性（Monotonicity） A≤B ⟹ A∣C≤B∣C对于任意的CA \\leq B \\implies A | C \\leq B | C \\quad \\text{对于任意的} C A≤B⟹A∣C≤B∣C对于任意的C 这意味着，如果 A 小于 B，则 A 与任意数 C 做按位或运算的结果将不大于 B 与 C 的按位或结果。直观来说，按位或运算不会缩小数值。 1.3. 与任意元素按位或运算，结果大于等于自身 A∣B≥AA | B \\geq A A∣B≥A 按位或操作将 A 中的 0 变为 1，不会使 1 变回 0，因此 A | B 的每一位都大于或等于 A 的相应位。 1.4. 交换律（Commutativity） A∣B=B∣AA | B = B | AA∣B=B∣A 按位或运算是交换的，即 A 与 B 按位或运算的结果与顺序无关。 1.5. 结合律（Associativity） (A∣B)∣C=A∣(B∣C)(A | B) | C = A | (B | C)(A∣B)∣C=A∣(B∣C) 按位或运算是结合的，即对多个数进行按位或时，操作的顺序可以任意调整。 1.6. 单位元（Identity Element） A∣0=AA | 0 = A A∣0=A 任意数与 0 做按位或运算，结果仍然是该数本身。 1.7. 吸收律（Absorption） A∣(A&amp;B)=AA | (A \\&amp; B) = A A∣(A&amp;B)=A 任何数与它与另一个数按位与（&amp;）的结果做按位或，结果等于原数。这个性质的意思是，按位或操作“吸收”了按位与的结果。 1.8. 按位或与按位与的分配律（Distributivity） A∣(B&amp;C)=(A∣B)&amp;(A∣C)A | (B \\&amp; C) = (A | B) \\&amp; (A | C) A∣(B&amp;C)=(A∣B)&amp;(A∣C) 按位或和按位与之间存在分配律，类似于普通算数运算中的分配律。 2. 按位“与”运算的性质（AND） 按位与运算（A &amp; B）也有一些类似的性质： 2.1. 自反性（Idempotence） A &amp; A = A 任何数与自身做按位与运算，结果仍然是自身。 2.2. 交换律（Commutativity） A &amp; B = B &amp; A 按位与运算是交换的。 2.3. 结合律（Associativity） (A &amp; B) &amp; C = A &amp; (B &amp; C) 按位与运算是结合的。 2.4. 单位元（Identity Element） A &amp; 1 = A 任意数与 1 做按位与运算，结果仍然是该数本身。注意，1 在二进制中相当于所有位都为 1。 2.5. 零元（Null Element） A &amp; 0 = 0 任意数与 0 做按位与运算，结果为 0。这是因为与 0 按位与运算的任何结果都会是 0。 2.6. 吸收律（Absorption） A &amp; (A | B) = A 按位与与按位或之间也有吸收律，类似于上面按位或的吸收律。 3. 按位异或运算的性质（XOR） 按位异或运算（A ^ B）也具有一些特别的性质： 3.1. 自反性（Idempotence） A ^ A = 0 任何数与自身做按位异或，结果为 0。 3.2. 交换律（Commutativity） A ^ B = B ^ A 按位异或是交换的。 3.3. 结合律（Associativity） (A ^ B) ^ C = A ^ (B ^ C) 按位异或是结合的。 3.4. 单位元（Identity Element） A ^ 0 = A 任何数与 0 做按位异或运算，结果仍然是该数本身。 3.5. 对称性（Symmetry） A ^ B = B ^ A 按位异或是对称的。 4. 按位“非”运算的性质（NOT） 按位非（~）运算的性质相对简单： 4.1. 自反性（Idempotence） ∼(∼A)=A\\sim (\\sim A) = A ∼(∼A)=A 对某个数取两次按位非，结果是原数。 4.2. 按位非操作 按位非操作对二进制数的每一位取反，即 0 变 1，1 变 0。 5. 位运算的应用 位运算在编程中非常有用，特别是在涉及到大量的数值操作、标志位管理、内存优化等场景。以下是一些常见的应用： 判断某个数是否为偶数：x &amp; 1 == 0 判断某个数是否为 2 的幂：x &amp; (x - 1) == 0 提取某一位：(x &gt;&gt; n) &amp; 1，获取第 n 位的值。 设置某一位：x | (1 &lt;&lt; n)，设置第 n 位为 1。 清除某一位：x &amp; ~(1 &lt;&lt; n)，清除第 n 位。 反转某一位：x ^ (1 &lt;&lt; n)，反转第 n 位。 位运算的基本操作 Java 和大多数编程语言支持以下几种常见的位运算： 按位与（AND）：&amp; 规则：两个操作数的相同位置上的位都为 1，结果才为 1。 15 &amp; 3 5 的二进制是 0101 3 的二进制是 0011 结果：0101 &amp; 0011 = 0001 → 1 按位或（OR）：| 规则：两个操作数的相同位置上的位只要有一个为 1，结果就为 1。 15 | 3 5 的二进制是 0101 3 的二进制是 0011 结果：0101 | 0011 = 0111 → 7 按位异或（XOR）：^ 规则：两个操作数的相同位置上的位不同，结果为 1，相同则为 0。 15 ^ 3 5 的二进制是 0101 3 的二进制是 0011 结果：0101 ^ 0011 = 0110 → 6 按位非（NOT）：~ 规则：对每一位取反，0 变成 1，1 变成 0。注意，这个操作会影响符号位，在 Java 中对 int 取反后是 32 位。 1~5 5 的二进制是 00000000000000000000000000000101 结果：~5 = 11111111111111111111111111111010 → -6（二进制补码表示） 位移操作： 左移（&lt;&lt;）：将数字的所有位向左移动指定的位数，右侧用0补充。 15 &lt;&lt; 1 5 的二进制是 0101 左移一位：1010 → 10 右移（&gt;&gt;）：将数字的所有位向右移动指定的位数，对于正数，用0填补；对于负数，符号位保持不变。 15 &gt;&gt; 1 5 的二进制是 0101 右移一位：0010 → 2 无符号右移（&gt;&gt;&gt;）：与右移类似，但是对负数无符号右移时会将符号位填充为0。 1-5 &gt;&gt;&gt; 1 -5 的二进制（补码表示）是 11111111111111111111111111111011 无符号右移一位：01111111111111111111111111111101 → 2147483642 位运算的技巧与应用 快速计算乘法与除法（2 的幂） 左移：相当于乘以 2 的某个次幂。例如，x &lt;&lt; n 等价于 x * 2^n。 12 int x = 5;int result = x &lt;&lt; 2; // 相当于 5 * 4 = 20 右移：相当于除以 2 的某个次幂。例如，x &gt;&gt; n等价于 x / 2^n。 12int x = 20;int result = x &gt;&gt; 2; // 相当于 20 / 4 = 5 判断奇偶数 奇数：x &amp; 1 为 1 时，表示 x 是奇数。 偶数：x &amp; 1为 0时，表示x是偶数。 12int x = 5;boolean isOdd = (x &amp; 1) == 1; // 5 是奇数，结果为 true 判断是否是 2 的幂 一个数如果是 2 的幂，则它与它的前一个数按位与结果为 0。例如，x 是 2 的幂，当且仅当 x &amp; (x - 1) == 0。 12345678910111213 int x = 8; boolean isPowerOfTwo = (x &amp; (x - 1)) == 0; // 8 是 2 的幂，结果为 true 4. **交换两个数** - 利用异或操作可以在不使用临时变量的情况下交换两个数。 ```java int a = 5, b = 3; a = a ^ b; // a = 6 b = a ^ b; // b = 5 a = a ^ b; // a = 3 // 交换后，a=3, b=5 设置某一位 使用按位或操作来设置某一位为1 12345678910 int x = 5; // 0101 int result = x | (1 &lt;&lt; 2); // 设置第 2 位为 1 -&gt; 0111 6. **清除某一位** - 使用按位与操作和按位非操作清除某一位。 ```java int x = 5; // 0101 int result = x &amp; ~(1 &lt;&lt; 2); // 清除第 2 位 -&gt; 0001 反转某一位 使用按位异或操作来反转某一位。 12int x = 5; // 0101int result = x ^ (1 &lt;&lt; 2); // 反转第 2 位 -&gt; 0001 求平均数不带小数 位运算(a + b) &gt;&gt; 1 使用了位运算来高效地计算两个整数的平均值。通过按位与运算找到不进位的部分，按位异或运算找出进位的部分，然后将进位部分右移并与不进位部分相加，最终得到 a 和 b 的平均值。这种方法比直接使用 (a + b) / 2 更加高效。 1int result = ((a &amp; b) + (a ^ b) &gt;&gt; 1) ; 清零最低位的1 检查 n 是否是 2 的幂：如果 n &amp; (n - 1) == 0，那么 n 是 2 的幂。 清除 n 中最低位的 1。 1int result = n &amp; (n - 1) ; 位运算的常见应用场景： 图像处理：位运算用于像素的颜色深度处理和图像操作。 网络协议：许多网络协议（如 IP 地址、子网掩码）都依赖于位运算来处理二进制数据。 压缩算法：一些数据压缩算法利用位运算优化空间存储。 加密与解密：位运算被广泛应用于数据加密算法中（如 XOR 操作）。 位运算是计算机科学中非常重要且高效的工具，它使得很多操作能够以最小的成本完成，尤其在性能要求高的场景下，掌握位运算能大大提高程序的效率。","link":"/JAVA/JAVA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9/bitewise/"},{"title":"JAVA基本数据结构","text":"Java 基本数据类型 Java 基本数据类型对比表，涵盖了整数、浮点、字符和布尔类型： 数据类型 存储字节数 最小值 最大值 说明 byte 1 字节 -128 127 8 位带符号整数 short 2 字节 -32,768 32,767 16 位带符号整数 int 4 字节 -2,147,483,648 2,147,483,647 32 位带符号整数 long 8 字节 -9,223,372,036,854,775,808 9,223,372,036,854,775,807 64 位带符号整数 float 4 字节 ±1.4E-45 ±3.4028235E38 单精度浮点数（32 位） double 8 字节 ±4.9E-324 ±1.7976931348623157E308 双精度浮点数（64 位） char 2 字节 0 65,535 单一字符（UTF-16编码） boolean 1 字节（理论上） false true 布尔类型，通常表示为 true 或 false","link":"/JAVA/JAVA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9/java-basic-data-type/"},{"title":"红楼梦","text":"诗词 终身误 都道是金玉良缘，俺只念木石前盟。 空对着，山中高士晶莹雪；终不忘，世外仙姝寂寞林。 叹人间，美中不足今方信。 纵然是齐眉举案，到底意难平。 好了歌 世人都晓神仙好，惟有功名忘不了！ 古今将相在何方？荒冢一堆草没了。 世人都晓神仙好，只有金银忘不了！ 终朝只恨聚无多，及到多时眼闭了。 世人都晓神仙好，只有娇妻忘不了！ 君生日日说恩情，君死又随人去了。 世人都晓神仙好，只有儿孙忘不了！ 痴心父母古来多，孝顺儿孙谁见了？ 唐多令·柳絮 粉堕百花洲，香残燕子楼。一团团、逐队成毬。飘泊亦如人命薄，空缱绻，说风流。 草木也知愁，韶华竟白头。叹今生、谁舍谁收！嫁与东风春不管，凭尔去，忍淹留！","link":"/%E8%AF%BB%E4%B9%A6/honglou/"},{"title":"力扣每日一题","text":"该文档仅仅自用，无记录的日期原因随意^^ 3066. 超过阈值的最少操作数 II 时间：2025/1/15 使用数据结构：优先队列 此题模拟即可，但要熟练掌握优先队列的使用，同时需要注意到数据范围，1&lt;=nums[i]&lt;=1091 &lt;= nums[i] &lt;= 10^91&lt;=nums[i]&lt;=109，使用long接收参数。 12345678910111213141516class Solution { public int minOperations(int[] nums, int k) { int ans = 0; PriorityQueue&lt;Long&gt; pq = new PriorityQueue&lt;&gt;(); for(long num : nums){ pq.offer(num); } while(pq.peek() &lt; k){ long x = pq.poll(), y = pq.poll(); pq.offer(x + x + y); ans++; } return ans; }} 3095. 或值至少 K 的最短子数组 I 时间：2025/1/16 枚举以i为起始位置的子数组，找到最短的符合要求的长度。 1234567891011121314151617class Solution { public int minimumSubarrayLength(int[] nums, int k) { int ans = Integer.MAX_VALUE; for(int i = 0; i &lt; nums.length; i++){ int cur = 0; for(int j = i; j &lt; nums.length; j++){ cur |= nums[j]; if(cur &gt;= k){ ans = Math.min(ans, j - i + 1); break; } } } return ans == Integer.MAX_VALUE ? -1 : ans; }} 或者可以使用滑动窗口 12345678910111213141516171819202122232425262728293031class Solution { public int minimumSubarrayLength(int[] nums, int k) { int n = nums.length; int[] bits = new int[30]; int res = Integer.MAX_VALUE; for (int left = 0, right = 0; right &lt; n; right++) { for (int i = 0; i &lt; 30; i++) { bits[i] += (nums[right] &gt;&gt; i) &amp; 1; } while (left &lt;= right &amp;&amp; calc(bits) &gt;= k) { res = Math.min(res, right - left + 1); for (int i = 0; i &lt; 30; i++) { bits[i] -= (nums[left] &gt;&gt; i) &amp; 1; } left++; } } return res == Integer.MAX_VALUE ? -1 : res; } private int calc(int[] bits) { int ans = 0; for (int i = 0; i &lt; bits.length; i++) { if (bits[i] &gt; 0) { ans |= 1 &lt;&lt; i; } } return ans; }} 3097. 或值至少为 K 的最短子数组 II 时间：2025/1/17 思路同上一道题 12345678910111213141516171819202122232425262728293031class Solution { public int minimumSubarrayLength(int[] nums, int k) { int n = nums.length; int[] bits = new int[30]; int res = Integer.MAX_VALUE; for (int left = 0, right = 0; right &lt; n; right++) { for (int i = 0; i &lt; 30; i++) { bits[i] += (nums[right] &gt;&gt; i) &amp; 1; } while (left &lt;= right &amp;&amp; calc(bits) &gt;= k) { res = Math.min(res, right - left + 1); for (int i = 0; i &lt; 30; i++) { bits[i] -= (nums[left] &gt;&gt; i) &amp; 1; } left++; } } return res == Integer.MAX_VALUE ? -1 : res; } private int calc(int[] bits) { int ans = 0; for (int i = 0; i &lt; bits.length; i++) { if (bits[i] &gt; 0) { ans |= 1 &lt;&lt; i; } } return ans; }} 2239. 找到最接近 0 的数字 时间：2025/1/20 笨蛋办法，依题意遍历 但效率较差，官解大同小异，将距0的距离也记录下来。时间上有所改进。 12345678910111213class Solution { public int findClosestNumber(int[] nums) { int ans = nums[0]; for(int i = 1; i &lt; nums.length; i++){ if (Math.abs(ans) &gt; Math.abs(nums[i])){ ans = nums[i]; } else if(Math.abs(ans) == Math.abs(nums[i])){ ans = Math.max(ans, nums[i]); } } return ans; }} 2218. 从栈中取出 K 个硬币的最大面值和 时间：2025/1/21 前缀和、背包问题、动态规划 状态定义：f[i] 表示选择了 i 个硬币时，能得到的最大价值。 转移方程：对于每个堆，我们尝试从该堆中取出不同数量的硬币（最多取堆中所有硬币）。对于每个堆中的硬币数量 t，如果当前的选择可以满足 i 个硬币（即 i &gt;= t），就尝试更新 f[i] 的值。 优化思路：每个堆中的硬币取出顺序是逐步累加的，依次计算从堆中取出 1、2、3...个硬币的总价值。 12345678910111213141516171819class Solution { public int maxValueOfCoins(List&lt;List&lt;Integer&gt;&gt; piles, int k) { int[] f = new int[k + 1]; Arrays.fill(f, -1); f[0] = 0; for (List&lt;Integer&gt; pile : piles) { for (int i = k; i &gt; 0; --i) { int value = 0; for (int t = 1; t &lt;= pile.size(); ++t) { value += pile.get(t - 1); if (i &gt;= t &amp;&amp; f[i - t] != -1) { f[i] = Math.max(f[i], f[i - t] + value); } } } } return f[k]; }} 1561. 你可以获得的最大硬币数目 时间：2025/1/22 博弈论、贪心 3n3n3n堆硬币，每轮由我选出3堆且拿走其中第二多的一个，也就是说我们直接每次最小的一堆选最小值交给bob即可，剩下的，每次可以取最大的两堆，我拿稍小的一个。 1234567891011class Solution { public int maxCoins(int[] piles) { Arrays.sort(piles); int n = piles.length / 3; int ans = 0; for(int i = 0; i &lt; n; i++){ ans += piles[3 * n - i * 2 - 2]; } return ans; }}","link":"/%E5%8A%9B%E6%89%A3/lcday/"},{"title":"优先队列","text":"在 Java 中，优先队列（PriorityQueue） 是一个基于堆（通常是最小堆）的数据结构，位于 java.util 包中。优先队列的元素会按照自然顺序或提供的比较器顺序进行排序。以下是关于优先队列的详细介绍： 特点 自动排序：默认是最小优先队列（最小堆），即每次取出的元素是当前队列中最小的元素。 非线程安全：PriorityQueue 不是线程安全的，如果需要线程安全，可以使用 PriorityBlockingQueue。 不允许 null 元素。 支持自定义顺序：可以通过传入 Comparator 定义元素的排序方式。 构造方法 PriorityQueue 提供多种构造方法： 默认构造方法： 1PriorityQueue&lt;E&gt; pq = new PriorityQueue&lt;&gt;(); 创建一个初始容量为 11 的最小堆。 指定初始容量： 1PriorityQueue&lt;E&gt; pq = new PriorityQueue&lt;&gt;(int initialCapacity); 指定比较器： 1PriorityQueue&lt;E&gt; pq = new PriorityQueue&lt;&gt;(Comparator&lt;? super E&gt; comparator); 创建一个使用自定义比较器的优先队列。 通过集合初始化： 1PriorityQueue&lt;E&gt; pq = new PriorityQueue&lt;&gt;(Collection&lt;? extends E&gt; c); 常用方法 以下是 PriorityQueue 的常用方法： 方法名 说明 add(E e) 向队列中添加元素，若超出容量会抛出异常。 offer(E e) 向队列中添加元素，推荐使用。 poll() 移除并返回队列的头部元素，若队列为空则返回 null。 peek() 返回队列的头部元素但不移除，若队列为空则返回 null。 remove(Object o) 删除队列中指定的元素。 size() 返回队列中元素的数量。 isEmpty() 判断队列是否为空。 clear() 清空队列中的所有元素。","link":"/JAVA/JAVA%E5%B8%B8%E7%94%A8API/java-priority-queue/"},{"title":"KMP","text":"一、简介 KMP 是一个解决模式串在文本串是否出现过，如果出现过，最早出现的位置的经典算法。 Knuth-Morris-Pratt 字符串查找算法，简称为 “KMP 算法”，常用于在一个文本串 S 内查找一个模式串 P 的出现位置，这个算法由Donald Knuth、Vaughan Pratt、James H. Morris 三人于 1977 年联合发表，故取这 3 人的姓氏命名此算法。 KMP 方法算法就利用之前判断过的信息，通过一个 next 数组，保存模式串中前后最长公共子序列的长度，每次回溯时，通过 next 数组找到，前面匹配过的位置，省去了大量的计算时间。 二、解题前的思考 关于字符串匹配，如果有两个字符串，其中一个较短的叫它子串（长度为n），较长的叫他主串（长度为m），那么该怎样确定子串在主串中的位置呢？ 最简单的笨蛋办法，暴力解，即从主串的每一个位置依次匹配子串每一位，时间复杂度是O(mn)O(mn)O(mn) 考虑优化： 在字符串匹配失败的时候，已经知道之前读过哪些字符了，那能不能避免“跳回下一个字符再重新匹配”的步骤呢？算法时间复杂度是O(m+n)O(m+n)O(m+n) 三、KMP算法思路 当发现某一个字符不匹配时，已经知道之前遍历过的字符，怎样利用已知信息避免暴力算法中的“回退”步骤呢？ 答案是跳过前边已经可以匹配的字符，继续从下一个可能匹配的字符开始匹配，那么具体需要跳过多少个字符呢？这里呢，利用next数组存储应该跳过多少个字符 next数组代表了在匹配失败的时候，子串中可以跳过匹配的字符个数。其本质即为寻找子串中“相同前后缀的最大长度”，且前后缀不能是字符串本身。 求解过程如下： 当前共同前后缀是2 如果下一个字符依然相同，那么下一个共同前后缀的长度就是2+1=3 如果下一个字符不相同，即ABA无法与下一个字符构成更长的前后缀， 那只能看看其中存不存在更短的前后缀， 因为ABA和ABA是一样的，已经知道其next数组是0 0 1， 所以现在找到位置cur_length = next[cut_length - 1] = 1 cur_length = 1, B可以匹配，所以B这里的next值为2 匹配两次才能成功的一个例子：aacaabaacaaa，最后一位需要匹配两次 四、KMP算法实现 1234567891011121314151617181920212223242526272829303132def getNext(s): ans = [0] # next数组 cur_len = 0 # 当前共同前后缀长度 i = 1 # 遍历指针 while i &lt; len(s): if s[cur_len] == s[i]: # 在已有共同前后缀长度上匹配成功 cur_len += 1 ans.append(cur_len) i += 1 else: # 匹配失败，如果当前无共同前后缀，就填0 if cur_len == 0: ans.append(0) i += 1 else: # 如果有共同前后缀，那么根据next数组跳过可以匹配的字符 cur_len = ans[cur_len - 1] return ansdef KMP_search(s, patt): pos = getNext(patt) i, j = 0, 0 # i, j分别是s和patt的指针 while i &lt; len(s): if s[i] == patt[j]: # 当前可以匹配，两个指针均后移 i += 1 j += 1 elif j &gt; 0: # 当前匹配失败，且j&gt;0，那么根据next数组跳过可以匹配的字符 j = pos[j - 1] else: # 当前匹配失败，且j&lt;=0，那么i++ i += 1 if j == len(patt): return i - j 修改版，主要是改变了大循环，while改成for，以及匹配失败，返回-1 1234567891011121314151617181920212223242526272829def getNext(s): ans = [0] # next数组 cur_len = 0 # 当前共同前后缀长度 i = 1 # 遍历指针 while i &lt; len(s): if s[cur_len] == s[i]: # 在已有共同前后缀长度上匹配成功 cur_len += 1 ans.append(cur_len) i += 1 else: # 匹配失败，如果当前无共同前后缀，就填0 if cur_len == 0: ans.append(0) i += 1 else: # 如果有共同前后缀，那么根据next数组跳过可以匹配的字符 cur_len = ans[cur_len - 1] return ansdef KMP_search(s, patt): pos = getNext(patt) i, j = 0, 0 # i, j分别是s和patt的指针 for i, c in enumerate(s): while j &gt; 0 and c != patt[j]: j = pos[j - 1] if c == patt[j]: # 当前可以匹配，两个指针均后移 j += 1 if j == len(patt): return i - j + 1 return -1 五、扩展练习 如果子串固定是ababc呢？不需要写通用版版本的KMP，怎样求解呢?","link":"/%E7%AE%97%E6%B3%95/KMP/"},{"title":"计算机网络","text":"网络基础概念 计算机网络的定义：什么是计算机网络？ 网络分类： 按范围：局域网（LAN）、广域网（WAN）、城域网（MAN）。 按拓扑结构：星型、环型、总线型、网状等。 网络设备：路由器、交换机、网关、调制解调器等。 网络协议 OSI 七层模型与四层模型 OSI七层模型：为了使全世界不同体系结构的计算机能够互联，国际化标准组织ISO提出开放系统互联基本参考模型，简称OSI，即七层协议体系结构。 OSI七层模型是一个大而全的理论模型，而TCP/IP四层模型是由实际应用发展总结出来的，但从实质上讲，TCP/IP只有最上面三层，最下面一层没有具体内容，TCP/IP参考模型没有真正描述这一层的实现，只是要求能够提供给其上层-网络互连层一个访问接口，以便在其上传递IP分组。 OSI 七层模型 1. 物理层（Physical Layer） 功能： 负责在物理介质上传输原始的比特流（0和1）。 定义电气、机械、时序和接口标准，确保数据能够通过物理介质（如电缆、光纤、无线电波）传输。 不关心数据的含义，只关注如何传输比特流。 协议/技术： 以太网（Ethernet）、USB、蓝牙、Wi-Fi（IEEE 802.11）、光纤（Fiber Optic）、RS-232等。 设备： 网卡（NIC）、集线器（Hub）、中继器（Repeater）、调制解调器（Modem）等。 实际应用： 通过网线将电脑连接到路由器。 通过Wi-Fi将手机连接到无线网络。 2. 数据链路层（Data Link Layer） 功能： 提供节点到节点的数据传输（通常是同一局域网内的设备）。 将比特流组织成帧（Frame），并进行错误检测和纠正。 管理物理地址（MAC地址），确保数据帧发送到正确的设备。 协议/技术： 以太网（Ethernet）、PPP（点对点协议）、HDLC（高级数据链路控制）、VLAN（虚拟局域网）等。 设备： 交换机（Switch）、网桥（Bridge）等。 实际应用： 交换机根据MAC地址将数据帧转发到目标设备。 在局域网中，设备通过MAC地址相互通信。 3. 网络层（Network Layer） 功能： 负责数据包的路由和转发，实现不同网络之间的通信。 使用逻辑地址（如IP地址）来标识设备，并选择最佳路径将数据包从源设备传输到目标设备。 处理拥塞控制、分段和重组。 协议/技术： IP（Internet Protocol）、ICMP（Internet控制消息协议）、ARP（地址解析协议）、RIP（路由信息协议）、OSPF（开放最短路径优先）等。 设备： 路由器（Router）、三层交换机（Layer 3 Switch）等。 实际应用： 路由器根据IP地址将数据包从你的电脑发送到远程服务器。 互联网中数据包通过多个路由器跳转到达目的地。 4. 传输层（Transport Layer） 功能： 提供端到端的数据传输服务，确保数据的可靠性和完整性。 负责流量控制、错误恢复和数据分段。 提供两种主要服务： 面向连接的服务（如TCP）：确保数据可靠传输。 无连接的服务（如UDP）：提供高效但不保证可靠性的传输。 协议/技术： TCP（传输控制协议）、UDP（用户数据报协议）、SCTP（流控制传输协议）等。 实际应用： TCP用于网页浏览（HTTP）、文件传输（FTP）等需要可靠传输的场景。 UDP用于视频流、在线游戏等对实时性要求高的场景。 5. 会话层（Session Layer） 功能： 管理应用程序之间的会话（Session），控制对话的建立、维护和终止。 提供同步点，以便在通信中断时恢复会话。 管理对话模式（全双工、半双工、单工）。 协议/技术： NetBIOS、RPC（远程过程调用）、PPTP（点对点隧道协议）等。 实际应用： 在视频会议中，会话层管理用户之间的连接和断开。 在数据库访问中，会话层管理客户端与服务器之间的会话。 6. 表示层（Presentation Layer） 功能： 负责数据的格式化、加密和解密，确保数据在不同系统间的兼容性。 将应用层的数据转换为网络格式，或将网络格式转换为应用层数据。 处理数据压缩、加密和字符编码转换。 协议/技术： SSL/TLS（加密）、JPEG（图像格式）、MPEG（视频格式）、ASCII/Unicode（字符编码）等。 实际应用： 在HTTPS通信中，表示层使用SSL/TLS对数据进行加密。 在文件传输中，表示层将数据转换为适合网络传输的格式。 7. 应用层（Application Layer） 功能： 提供用户接口和网络服务，支持应用程序之间的通信。 直接为用户提供服务，如文件传输、电子邮件、网页浏览等。 协议/技术： HTTP（网页浏览）、FTP（文件传输）、SMTP（电子邮件）、DNS（域名解析）、DHCP（动态主机配置协议）等。 实际应用： 使用浏览器访问网页时，应用层使用HTTP协议与服务器通信。 发送电子邮件时，应用层使用SMTP协议。 总结 OSI七层模型的核心思想是分层解耦，每一层只关注自己的功能，并通过标准接口与上下层交互。这种设计使得网络协议和设备的开发、维护和升级更加灵活和高效。 层级 名称 功能概述 协议示例 设备示例 7 应用层 提供用户接口和网络服务 HTTP、FTP、SMTP、DNS 应用程序 6 表示层 数据格式化、加密、压缩 SSL/TLS、JPEG、MPEG - 5 会话层 管理应用程序之间的会话 NetBIOS、RPC - 4 传输层 提供端到端的数据传输服务 TCP、UDP 网关 3 网络层 负责数据包的路由和转发 IP、ICMP、ARP 路由器 2 数据链路层 提供节点到节点的数据传输 以太网、PPP 交换机、网桥 1 物理层 在物理介质上传输原始比特流 以太网、Wi-Fi、USB 网卡、集线器 TCP/IP 四层模型 网络接口层、网络层、传输层、应用层。 常见协议： 网络层：IP（IPv4/IPv6）、ICMP、ARP。 传输层：TCP、UDP。 应用层：HTTP、HTTPS、FTP、DNS、SMTP、WebSocket 等。 IP 地址和子网划分 IP 地址： IPv4 和 IPv6 的区别。 公有 IP 和私有 IP。 子网划分： 子网掩码（Subnet Mask）。 CIDR（无类别域间路由）表示法。 NAT（网络地址转换）：原理和作用。 传输层协议 TCP（传输控制协议）： 三次握手和四次挥手。 可靠传输机制（确认、重传、流量控制、拥塞控制）。 UDP（用户数据报协议）： 无连接、不可靠传输。 适用场景（如视频流、在线游戏）。 HTTP/HTTPS HTTP 协议： 请求/响应模型。 请求方法（GET、POST、PUT、DELETE 等）。 状态码（1xx、2xx、3xx、4xx、5xx）。 Headers（如 Content-Type、Cache-Control、Authorization）。 HTTPS： SSL/TLS 加密机制。 证书和 CA（证书颁发机构）。 DNS（域名系统） DNS 的作用：将域名解析为 IP 地址。 DNS 查询过程：递归查询和迭代查询。 DNS 记录类型：A、CNAME、MX、TXT 等。 网络安全基础 加密技术： 对称加密（如 AES）。 非对称加密（如 RSA）。 认证和授权： OAuth、JWT（JSON Web Token）。 常见攻击与防御： DDoS 攻击、SQL 注入、XSS（跨站脚本攻击）、CSRF（跨站请求伪造）。 网络编程 Socket 编程： TCP Socket 和 UDP Socket。 客户端-服务器模型。 RESTful API： 设计原则（如资源、HTTP 方法、状态码）。 使用工具（如 Postman）测试 API。 网络工具 Ping：测试网络连通性。 Traceroute：追踪数据包路径。 Netstat：查看网络连接状态。 Wireshark：抓包分析工具。 云计算和网络 CDN（内容分发网络）：加速内容分发。 负载均衡：如 Nginx、HAProxy。 云服务网络：如 AWS VPC、Azure Virtual Network。 实际应用场景 Web 开发：理解 HTTP/HTTPS 请求的生命周期。 移动开发：处理网络请求和数据同步。 微服务架构：服务间通信（如 gRPC、REST）。 物联网（IoT）：设备与服务器的通信。 计算机网络基础","link":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/network/"},{"title":"基础乐理","text":"基础乐理知识 一个曲谱有：调号、拍号、曲谱、歌词。 知道上述名称后，要从基础学起。 首先要明白音的性质：音高、音值、音量、音色。不同的乐器和人声都是通过这四项的不同变化才产生我们听到的音乐。 一、音及音高 音是由于物体的振动而产生的。音有高低、强弱、长短、音色等四种性质。 （1）音的高低是由于物体在一定时间内的振动次数(频率)而决定的。振动次数多，音则高;振动次数少，音则低。 （2）音的长短是由于音的延续时间的不同而决定的。音的延续时间长，音则长;音的延续时间短，音则短。 （3）音的强弱是由于振幅(音的振动范围的幅度)的大小而决定的。振幅大，音则强;振幅小，音则弱。 （4）音色则由于发音体的性质、形状及其泛音的多少等而不同。 由于音的振动状态的规则与不规则，音被分为乐音与噪音两类。音乐中所使用的主要是乐音，但噪音也是音乐表现中不可缺少的组成部分。 1、乐音体系音列音级 （1）在音乐中使用的、有固定音高的音的总和，叫做乐音体系。 （2）乐音体系中的音，按照上行或下行次序排列起来，叫做音列。 （3）乐音体系中的各音叫做音级。音级有基本音级和变化音级。 （4）乐音体系中，七个具有独立名称的音级叫做基本音级。 基本音级的名称是用字母和唱名两种方式来标记的。 字母体系：C D E F G A B 唱名体系：1 2 3 4 5 6 7 钢琴上白键所发出的音是与基本音级相符合的。钢琴上五十二个白键循环重复地使用七个基本音级名称。两个相邻的具有同样名称的音叫做八度。 升高或降低基本音级而得来的音，叫做变化音级。将基本音级升高半音用“升”或“#”来标明。降低半音用“降”或“b”来标明。升高全音用“重升”或“×”来标明。降低全音用“重降”或“bb”来标明。 如：升C或#C 降C或bC 2、音的分组 为了区分音名相同而音高不同的各音，我们将音列分成许多个“组”。 在音列中央的一组叫做小字一组。它的音级标记用小写字母并在右上方加数字1来表示。 比小字一组高的组顺次定名为：小字二组、小字三组、小字四组、小字五组。 小字二组的标记用小写字母并在右上方加数字2来表示。 比小字一组低的组，依次定名为小字组、大字组、大字一组及大字二组。 小字组各音的标记用不带数字的小写字母来表示。 大字组用不带数字的大写字母来标记。 大字一组用大写字母并在右下方加数字1来标明。 大字二组用大写字母并在右下方加数字2来标明。 3、音域及音区 总的音域是指音列的总范围，即从它的最低音(C2——c5)间的距离而言。 个别的人声或乐器的音域是指在整个音域中所能够达到的那一部分，如钢琴的音域是A2——c5。 音区是音域中的一部分，有高音区、低音区、中音区三种。 在整个音域中，小字组、小字一组和小字二组属于中音区。小字三组、小字四组和小字五组属高音区。大字组、大字一组和大字二组属低音区。 各音区的特性音色在音乐表现中，有着重大的意义。高音区一般具有清脆、嘹亮、尖锐的特性;而低音区则往往给人以浑厚、笨重之感。 二、音律 乐音体系中各音的绝对准确高度及其相互关系叫做音律。将八度分成十二个均等的部分——半音——的音律叫做十二平均律。 半音是十二平均律组织中最小的音高距离。两音间的距离等于两个半音的叫做全音。八度内包括十二个半音，也就是六个全音。 在音列中的基本音级中间，除了E到F、B到C是半音外，其余相邻两音间的距离都是全音。 根据复合音的第二分音和第三分音的纯五度关系，即由某一音开始向上推一纯五度，产生次一律，再由次一律向上推一纯五度，产生再次一律，如此继续相生所定出的音律叫做五度相生律。 纯律是于五度相生律用以构成的第二分音和第三分音之外，再加入第五分音来作为生律要素，构成和弦形式。 1、自然半音和自然全音变化半音和变化全音 由两个相邻的音级构成的半音叫做自然半音。如;e—f #e—#f #g—a 由相邻的两个音级形成的全音叫做自然全音。如：C—d C—#d ba—bB 由同一音级的两种不同形式所构成的半音，叫做变化半音。如：C—#C D—bD bbB—bB 由同一音级的两种不同形式或隔开一个音级所构成的全音，叫做变化全音。 如：B——bbB #C——bE 2、等音 音高相同而意义和记法不同的音，叫做等音。 1. 认识音符和节奏 学习内容： 音符（C、D、E、F、G、A、B）和升降音（#、b）的概念。 音名/音符是乐音体系中各音级各自的名称。现行通用音名为：CDEFGAB。除了音名还有do、re、mi、fa、sol、la、si这些音名，多用于歌唱，故又称唱名。除了音名和唱名以外，还有全音和半音，音高关系的最小计量单位，叫做“半音”，两个半音叫“全音”。 节奏符号（全音符、二分音符、四分音符等）。 节拍和拍号（如 4/4、3/4）。 练习建议： 在吉他上找到每根弦的音符位置。 打节拍器练习简单的节奏型。 2. 音阶与调式 学习内容： 自然大调音阶（C 大调）及其公式（全全半全全全半）。 自然小调音阶（A 小调）及其公式（全半全全半全全）。 了解调号和音阶关系。 练习建议： 在吉他指板上弹奏 C 大调和 A 小调音阶。 练习音阶爬格子，熟悉指板位置。 3. 和弦基础 学习内容： 什么是三和弦（大三和弦、小三和弦）。 常见和弦的构成音（如 C 和弦：C、E、G）。 和弦表记法（如 C、Am、G7）。 练习建议： 学会简单的和弦切换（如 C-G-Am-F）。 用和弦为简单的流行曲伴奏。","link":"/%E5%A4%A9%E9%A9%AC%E8%A1%8C%E7%A9%BA/musictheory/"},{"title":"奇奇怪怪的思维方式","text":"大多数内容来自gpt。 罗生门效应 “罗生门效应” 指的是在一个事件中，由于不同的当事人或目击者基于自身的利益、立场、记忆、情感等因素，对同一事件给出相互矛盾、截然不同的描述和说法，使得事件的真实情况变得模糊不清、难以确定的现象。就像黑泽明电影《罗生门》中所展现的那样，每个角色都从自己的角度出发讲述故事，导致真相被重重迷雾所掩盖。 在电影《罗生门》中讲述了一起发生在森林中的强奸杀人案，案件的主要人物包括武士、武士的妻子、强盗以及樵夫等，不同人物对事件的描述大相径庭： 强盗的说法：强盗多襄丸承认自己见武士妻子美貌，起了歹心，将武士骗至丛林深处绑了起来，然后当着武士的面强奸了他的妻子。之后，他与武士进行了一场公平的决斗，并最终用剑杀死了武士。他把自己描绘成一个有胆有识、敢于承认罪行的人，甚至在讲述过程中还流露出对自己行为的某种得意。 武士妻子的说法：她声称自己被强盗强奸后，强盗离去，她悲痛欲绝，请求丈夫原谅她，但丈夫却以冷漠和轻蔑的眼神看着她，让她感到绝望。在极度的痛苦和羞耻之下，她拿起短刀想要和丈夫同归于尽，但在混乱中自己晕倒了，醒来后发现丈夫已经死了，暗示丈夫可能是她误杀的，但她又表现出对自己行为的懊悔和自责。 武士的说法：通过灵媒之口，武士称自己被强盗绑住后，看着妻子被强奸，心中充满了愤怒和无奈。妻子被强奸后，竟然跟着强盗走了，还要求强盗杀了他。强盗听后，反而将她推倒在地，问武士要不要杀了这个女人。妻子的行为让他感到无比绝望和耻辱，于是他用短刀自杀了，但死后却感觉有人拔掉了他身上的短刀，暗示他的死可能还有其他隐情，把自己塑造成一个受害者和被背叛者的形象。 樵夫的说法：樵夫最初隐瞒了一些关键信息，只说发现了武士的尸体。后来在影片结尾才透露，他其实目睹了整个事件的经过。他看到强盗强奸了武士的妻子后，请求她跟自己走，妻子要求强盗和武士决斗，谁赢了她就跟谁走。强盗与武士的决斗过程狼狈不堪，两人都很怯懦，最后强盗侥幸用剑刺死了武士。樵夫的版本似乎更接近真相，但他也因为想拿走武士身上的短刀而心生愧疚，所以一开始有所隐瞒。 这四个不同版本的叙述，充分展示了“罗生门效应”。每个当事人都从自己的利益、情感和立场出发，对同一事件进行了不同的解读和歪曲，使得事件的真相变得扑朔迷离，观众也难以分辨到底谁说的是真话，深刻地揭示了人性的复杂和真相的难以捉摸。 洞穴隐喻 洞穴隐喻是柏拉图在《理想国》中提出的一个重要哲学概念。 想象有一群囚犯，自出生起就被囚禁在一个洞穴中。他们的身体被铁链锁住，只能面朝洞穴的墙壁，无法转头。在他们身后有一堆火在燃烧，在火和囚犯之间有一条通道，沿着通道有一堵矮墙。一些人在矮墙后面走过，举着各种物体，这些物体的影子被火光投射在囚犯们面对的墙壁上。囚犯们只能看到这些影子，他们认为这些影子就是真实的世界，给这些影子命名，并根据影子的移动来预测未来等。 直到有一天，一个囚犯挣脱了锁链，转身看到了火光和那些物体，才发现原来之前看到的只是影子，是虚幻的。他继续走出洞穴，看到了外面真实的世界，有太阳、山川、树木等真实的事物，他才认识到真正的实在。但当他回到洞穴，试图告诉其他囚犯真相时，其他囚犯却不相信他，甚至觉得他疯了。 忒修斯之船 很久很久以前，在古希腊的海岸线，忒修斯是一位伟大的英雄。他的船，是他征战四方的利器，航行在大海上，背负着国家的荣耀与命运。传说中的这艘船，不仅是航海的工具，还承载了神话般的力量。每当船的木板出现磨损，船匠们就会在港口上替换掉坏掉的部分，精心修复，确保船体始终能保持航行的能力。 然而，随着时间的推移，情况发生了变化。船上坏掉的木板越来越多，修理也越来越频繁，甚至有一天，整艘船上的所有木板都被完全替换过了，连一点原本的木材也不剩下了。 这时，围绕着忒修斯之船的一个深刻问题悄然浮现：这艘船，还是当初的那艘船吗？ 有一个好奇心强的学者，名叫阿尔基比亚德斯，他在一个月光皎洁的夜晚，坐上了这艘完全重建过的船，开始了自己的航行。他走到船头，望着星空，开始沉思：“如果我能回到故乡，见到昔日的朋友，我能否说：‘这是我曾乘坐的忒修斯之船’？” 这时，一位哲学家突然出现在船上，他留着长长的胡须，手里拿着一卷羊皮纸。看到阿尔基比亚德斯困惑的眼神，哲学家笑了笑，开始给他讲解这个古老的悖论。“你要知道，船虽然看起来和原来的完全一样，但它的‘身份’早已发生了改变。你看，船体的每一块木板都是一个独立的部分，经过替换后，它就不再是那个起初航行的忒修斯之船。而‘忒修斯之船’的身份，是否还存在呢？我们或许可以说，原来的船已经消失在历史的长河中了。” 阿尔基比亚德斯皱了皱眉，觉得有些困惑：“那么，‘船’的身份到底是什么？难道是它的结构吗？还是它所承载的历史？” 哲学家点了点头：“这正是问题的核心。如果说结构决定了身份，那么这艘船现在就不再是忒修斯之船了。但如果我们认为，船的身份和它所承载的意义和故事紧密相连，那么我们也可以说，这艘船依然是那艘曾在波涛中征战过的忒修斯之船，只不过它经历了时间的洗礼。” 阿尔基比亚德斯沉默了，渐渐地，月光映照在船的木板上，船继续在大海中航行。这时候，海风吹过，哲学家突然问道：“如果一块块替换的木板被收集起来，重新组装成一艘船，那又是什么呢？” 这个问题，像一道闪电，划过了阿尔基比亚德斯的心头——如果这块块被替换掉的木板重新被拼接，那么它难道不也可以称为忒修斯之船吗？ 于是，哲学家带着微笑离开了，而阿尔基比亚德斯则继续航行，在大海中，寻找着自己的答案。 “忒修斯之船”不仅是关于物体身份的问题，它也探讨了变化与持续性、时间与记忆的关系。实际上，它也启发了我们如何看待个人的身份——在我们不断改变和成长的过程中，哪些部分是“我们”真正的核心，哪些又是外在的、可以更替的部分？ 布里丹之驴 “布里丹之驴”（Buridan's Donkey）是一个由中世纪法国哲学家让·布里丹（Jean Buridan）提出的经典悖论，旨在探讨自由意志和理性选择的问题。这个悖论的核心是关于决策和行动的困境。 故事背景： 设想有一头非常饿的驴，站在一堆干草和一桶水的正中央，距离它的每一侧的食物和水的距离完全相等。驴非常渴望吃干草，也非常渴望喝水，但它并没有偏好哪一个——它同时对干草和水的需求是一样强烈的。 由于干草和水的距离相同，且它不能做出任何理性判断来选择先吃哪一个，因此它陷入了一个无法做出决定的困境。最终，驴因为过于犹豫，既没有吃干草也没有喝水，最终饿死了。 哲学意义： 这个悖论的深层含义在于，它提出了一个关于自由意志和理性选择的问题：如果一个个体在理性上没有偏好，也没有外部因素能使它做出选择，那么它是否能做出选择？ 布里丹用这个悖论来挑战当时关于决策和自由意志的传统观点。他的意思是，如果驴完全理性，且对两者完全没有偏好，它就会处于“选择不出来”的困境。这就像一个在理论上无可选择的状态，意味着它完全无法采取行动。 扩展讨论： 自由意志与理性选择： 布里丹之驴实际上提出了自由意志是否真的存在的疑问。如果在某些情况下，人或动物没有外部因素或内心偏好来促使选择，那它们是否仍然能够行动？这个问题可以扩展到人类的决策上，特别是在面对选择困难症、决策拖延症时。例如，当一个人面临两种完全相等的选择时，是否也会陷入类似的困境，难以作出决定？ 决策和行动： 从另一个角度看，这个悖论也反映了人在某些情况下可能因为无法选择而无法采取行动。现实中，我们经常会因为过于权衡各种可能性，最终失去做决策的能力。比如，有人因为过于理性地分析不同的选择而最终没有做出任何决定，这种现象叫做“分析麻痹”（analysis paralysis）。 现代解读： 有些现代学者认为，布里丹之驴实际上是在挑战“理性主义”过度依赖推理的观念，提出我们可能在某些情况下并不完全依赖理性来做出选择，而是会受到感性、情感或环境因素的影响。现代社会中的很多决策其实并不像布里丹之驴那么完全理性，很多时候我们的选择往往带有一些无形的倾向性。 现代应用： 虽然这个悖论最早是用来探讨动物和人类的自由意志的，但它在现代也有一些有趣的应用。比如，在人工智能领域，决策算法有时也可能面临类似的困境。如果一个AI系统没有明确的优先级或规则，它就可能陷入“选择困境”，无法做出决策。这个问题在自动驾驶、机器学习等领域都会遇到，如何设计能“做出决策”的算法，是一个持续的挑战。 “布里丹之驴”通过其极端且有趣的设定，表明在理性选择的过程中，决定并不总是那么简单。也许，有时我们的困境并不是缺乏理性，而是因为理性本身并不足以引导我们做出选择。在这一点上，情感、环境、甚至直觉，往往在我们做决策时扮演了更重要的角色。 缸中之脑 “缸中之脑”（Brain in a Vat）是一个非常著名的现代哲学思想实验，主要用来探讨怀疑主义、知觉与现实之间的关系。它通常用来质疑我们如何确定自己所感知的世界是否真实，或者我们是否只是被某种力量或存在所误导。这个思想实验由美国哲学家希尔（Hilary Putnam）在20世纪提出，并且广泛地与“模拟假设”相关联。 故事设定： 想象一下，一个大脑被从人体中取出，并放入一个充满营养液体的玻璃缸中。这个大脑通过电极与计算机系统相连，计算机通过向大脑传递信号来模拟感官输入。这些信号可以让大脑产生所有的感知，包括视觉、听觉、触觉等。因此，大脑能够“体验”一个虚拟世界，像它原本在肉体中一样感知周围的一切。 现在，假设你（或者你所扮演的主体）是这个大脑中的一部分。你从你的视角来看，你感知到的世界和你以前的世界几乎没有区别。你看到树木、街道、建筑、甚至是与人交谈的朋友。但实际上，这一切都只是计算机制造的虚拟现实，所有的感知都仅仅是由电信号和计算机程序生成的模拟。 哲学意义： “缸中之脑”实验的目的在于挑战我们对现实的信念。这个思想实验质疑了以下几个关键问题： 怀疑主义： 它揭示了极端怀疑主义的可能性，即我们如何能够确定自己感知到的世界是真的？如果我们只是一个“缸中之脑”，那么所有的感知，包括对自我的认识、对外部世界的理解，甚至我们的思想和记忆，可能都只是虚假的或被控制的。换句话说，我们无法通过感官来证明我们所处的世界是不虚假的。 感知与现实的关系： 这个实验也引发了关于感知与现实的关系的讨论。我们所感知到的世界是否等同于“真实世界”？如果我们能通过某种方式“感知”虚拟世界，而没有任何区分，那我们应该如何定义“现实”？我们的知觉是否能作为我们了解世界的可靠依据？ 心灵-身体问题： 这个思想实验也触及了心灵与身体的关系问题。大脑虽然与身体分离，但依然能够通过感知“生活”，这让人思考意识是否仅仅依赖于身体，或者它是否可以独立于身体存在。假如我们可以在不依赖身体的情况下拥有意识，那它又是如何运作的呢？ 现代解读与影响： 模拟假设： “缸中之脑”常常与“模拟假设”（Simulation Hypothesis）相提并论，这是一种观点，认为我们可能生活在一个高科技文明创造的虚拟现实中。这个假设与科幻电影《黑客帝国》（The Matrix）密切相关，它提出了一个问题：我们是否只是计算机程序中的一部分，而所感知的世界仅仅是模拟的？ 例如，著名的物理学家尼克·博斯特罗姆（Nick Bostrom）提出过“模拟宇宙”的理论，认为某些文明可能已经能够创造出完全逼真的虚拟现实，如果一个文明发展到足够高的技术水平，它们甚至可能会选择模拟整个历史或现实世界。根据这种理论，我们生活的世界可能就是某种超高级文明所创建的一个虚拟世界。 认知科学与哲学： 在认知科学中，“缸中之脑”实验被用来探讨意识、知觉和自我认知的本质。它强调了知觉的相对性——我们不能仅仅依赖感官经验来判断现实的真实性。它也促使人们思考如何在没有感官输入的情况下构建一个“真实”的世界观，或者如何通过理性推理、科学实验等方式去验证外部世界的存在。 神经科学与AI： 随着神经科学和人工智能技术的发展，“缸中之脑”的问题越来越引人关注。如果人类的意识只是由大脑神经元的活动构成，那么我们是否有可能通过模拟这些活动，在计算机中重建一个“大脑”？如果将来我们能够通过机器完全模拟人类的感知与思维，虚拟现实又会变成怎样的一种体验？这些问题在今天的科技背景下，显得尤为迫切。 哲学回应： 对“缸中之脑”这一悖论，许多哲学家提出了不同的回应： 希尔（Hilary Putnam）：他通过反对“缸中之脑”悖论来发展了“语义外部主义”的理论。他认为，如果我们真的是缸中之脑，那么我们不可能有语言和思想去描述我们感知的世界，因为我们的语言和感知总是与外部世界紧密联系的。换句话说，我们的语言和思维无法脱离实际的外部环境，因此“缸中之脑”本身就无法有效地进行自我描述和理解。 笛卡尔（René Descartes）：笛卡尔的怀疑主义可以与“缸中之脑”悖论相提并论，他提出了著名的“我思故我在”。即使他怀疑自己所感知的世界是真实的，他仍然能够确定自己作为一个思考的主体的存在。在这个角度上，笛卡尔的怀疑主义与“缸中之脑”构成了有趣的对比。 总的来说，“缸中之脑”悖论深入探讨了怀疑主义、知觉的可靠性和我们如何认识现实的问题。它挑战了我们对于世界的信任，也引发了关于虚拟现实、意识和自我认知等领域的广泛讨论。它不仅在哲学上富有深刻的洞察，也为当代科技和人工智能的未来发展提供了思考的基础。 理发师悖论 “理发师悖论”（Barber Paradox）是由数学家和哲学家伯特兰·罗素（Bertrand Russell）提出的一个悖论，目的是探讨集合论中的自指和矛盾。这个悖论的核心问题与自指的集合和定义有关，特别是如何避免在系统中出现自相矛盾的情况。 故事设定： 假设有一个理发师，他的职业是“给那些不自己剃须的男人理发”。也就是说，理发师的规则是：如果一个男人不自己剃须，他就必须由理发师剃须；如果一个男人自己剃须，那么他就不应该由理发师来剃须。 那么问题来了：理发师自己理发吗？ 如果理发师自己理发，那么根据规则，他应该是“自己剃须”的人，因此他不应该由自己来理发。这就产生了矛盾，因为理发师不应该给自己剃须。 另一方面，如果理发师不自己理发，那么根据规则，他应该是“那些不自己剃须的男人”之一，这意味着理发师应该由自己来理发，但这又会导致矛盾。 这个悖论形成了一个自相矛盾的循环：如果理发师自己理发，那么他不应该理发；如果他不自己理发，那么他应该由自己理发。 数学和逻辑背景： 这个悖论实际上是集合论中的一个经典问题，特别是罗素提出的“类型论”问题。它反映了自指的危险性，尤其是在建立集合论的公理体系时。如果一个集合能够包含自己，那么就可能引发逻辑上的自相矛盾。具体地，它类似于“理发师”所指代的集合，它自身就被包含在它所定义的规则中，从而导致逻辑上的冲突。 在数学上，罗素的悖论揭示了早期集合论的一个致命问题，即在“任意集合”之下，允许构造“所有不包含自己的集合”这个集合，这会导致无法避免的矛盾。这个悖论促使了对集合论的重新审视，并推动了像“类型论”和“公理化集合论”等新的数学体系的发展。 哲学意义与影响： 自指与矛盾： 理发师悖论体现了自指所带来的逻辑难题。在某些情况下，当一个定义或规则试图引用自己时，可能会导致无法解决的矛盾。例如，“这句话是假的”就是一个类似的自指悖论，它表明语言和逻辑中，某些规则如果试图自我引用，可能会引发无法避免的循环和冲突。 集合论中的悖论： 罗素的悖论直接影响了集合论的发展。集合论是一种描述集合（对象的集合）数学性质的理论，但它也必须小心如何定义集合，以避免某些集合能够“包含自己”从而产生矛盾。罗素的悖论特别表明，当集合能够自我引用时，就会导致逻辑上的困境。为了解决这个问题，数学家提出了像“公理化集合论”（例如，策梅洛-弗兰克尔集合论，ZFC）这样的理论，这些理论通过限制集合的定义方式来避免产生这种矛盾。 逻辑和语言的限制： 理发师悖论还启发了哲学家和语言学家对于语言和逻辑系统自指问题的讨论。在语言中，自指是不可避免的，但如何合理地构建语法和语义规则，以避免这些自指导致悖论，成为了一个重要的问题。比如，在构建形式系统时，如何避免“自我包含的”定义，如何确保定义的一致性和可操作性，都是这一悖论所揭示的重要问题。 解答与解决方案： 虽然理发师悖论本身没有一个“直接”的解答，但它为现代逻辑和集合论的发展提供了启示。通过限制集合的构造方式（例如，类型理论中的“层次限制”）可以避免这种自指的情况。例如，罗素的类型理论就提出，集合和元素应该被分为不同的类型，每个类型的集合不能包含属于同一类型的元素，从而避免了自指的问题。 在现代集合论中，像策梅洛-弗兰克尔集合论（Zermelo-Fraenkel set theory，简称ZF）采用了一系列公理来避免这样的矛盾，确保每个集合只能包含属于它的“低级”集合，而不能包含自己。这样，悖论就得到了有效的规避。 笛卡尔的恶魔 “笛卡尔的恶魔”是法国哲学家勒内·笛卡尔提出的一个思想实验，旨在探讨怀疑主义以及我们如何能够确信自己的感知和思想是准确的。 简要设定： 笛卡尔假设，有一个全能且极其狡猾的恶魔，它能够完全控制和欺骗我们的一切感官。恶魔通过操控我们的感官，使我们错误地感知现实，甚至连我们自身的思想和自我意识也可能是虚假的。在这种情况下，笛卡尔提出的问题是：我们如何能够确信我们所体验的世界、我们自己、以及我们的思想都是真实的？ 哲学意义： 这个思想实验的核心目的是强调感官和经验的不可靠性。通过假设一个强大的恶魔能够欺骗我们的每一感官输入，笛卡尔挑战了我们如何知道我们所认为的“现实”是准确的。在这一前提下，他引出了最著名的哲学命题——“我思故我在”（Cogito, ergo sum）。即使恶魔能够欺骗我所有的感官输入，甚至让我怀疑自己的存在，至少我能够确信我自己在思考，因此我的思维是存在的。 通过这个恶魔的假设，笛卡尔强调了怀疑主义的重要性，并指出即使在极端怀疑的情况下，我们依然可以找到不容置疑的真理。笛卡尔的恶魔也启发了后来的哲学家对于“现实”与“感知”的深刻讨论，影响了认识论、怀疑主义和现代哲学的许多领域。 薛定谔的猫 量子力学中的一个著名思想实验，由物理学家埃尔温·薛定谔于1935年提出，旨在展示量子力学中“不确定性原理”和“叠加态”概念的怪异性。 思想实验设定： 设想你把一只猫放进一个封闭的盒子里，盒子内有一个放射性物质、一个盖革计数器、一个锤子和一瓶氰化物。当放射性物质衰变时，盖革计数器会触发锤子，打破氰化物瓶，释放毒气，导致猫死掉。否则，猫会活着。 根据量子力学的解释，放射性物质的衰变过程是一个量子事件，它在未被观测之前是处于“叠加态”的：既衰变又未衰变。由于衰变和未衰变的状态分别导致猫死亡或存活，所以在盒子没有被打开之前，猫既是死的，又是活的——直到盒子被打开观察，猫才会“坍缩”到一个确定的状态（活着或死了）。 哲学与物理意义： 量子叠加态： 在量子力学中，粒子可以同时存在于多种可能的状态中，直到被测量或观察。这种现象在宏观世界（如猫的例子）中看起来是荒谬的，因此薛定谔提出这个实验来揭示量子力学的“荒谬性”与我们的直觉冲突。 观察者效应： 这个实验也引出了“观察者效应”——即在量子力学中，系统的状态是由观测行为本身决定的。在没有观察之前，系统处于叠加状态，只有观察后才“坍缩”到一个确定的状态。这引发了关于观察与现实之间关系的哲学问题：是否现实的存在依赖于我们的观察？ 量子力学与经典物理学的区别： 薛定谔的猫实验展示了量子力学和经典物理学的本质区别。在经典物理学中，物体的状态是独立于观察的，而在量子物理中，粒子的状态会受到观察行为的影响。这让人们质疑我们对“现实”本身的理解。 影响与解读： 哥本哈根解释与多世界解释： 薛定谔的猫实验的困惑促使了量子力学中不同解释的发展。哥本哈根解释认为，系统的波函数在被观测时坍缩到一个确定的状态。而多世界解释则提出，每一个可能的结果都会在不同的“平行宇宙”中发生，猫既死又活，只是在不同的世界中。 宏观世界的适用性： 虽然薛定谔的猫实验表现出量子力学的奇异性，但它并不意味着猫在实际生活中会同时处于死活状态。因为量子效应在宏观世界中通常被“去相干”，所以我们不会在日常生活中看到这种叠加态。然而，这个实验仍然帮助我们理解量子世界和经典世界之间的差异。 拉塞尔的茶壶 英国哲学家伯特兰·罗素提出的一个著名思想实验，用来讨论信仰和可证伪性的关系。 思想实验设定： 罗素假设，在太阳和地球之间有一颗非常小的茶壶，它的大小非常微小，以至于我们无法用任何现有的望远镜看到它。这颗茶壶不会被任何人发现，且它的存在无法被任何证据证明。罗素指出，如果他声称这颗茶壶存在，并要求每个人都相信它的存在，那么这些人应该如何反驳这一信仰呢？如果不能证明它不存在，那么是不是就应当接受它的存在？ 哲学意义： 不可证伪的信仰： 罗素用这个比喻说明了一个重要观点：某些信仰或理论如果无法被证伪，那么它们就没有科学意义。换句话说，任何不能被实验证明为错误的信仰（如神话、宗教信仰等）并不值得我们理性地接受。罗素的茶壶是对宗教信仰、迷信以及无法证伪的假设的一种挑战，尤其是对那些主张某种无法被证伪的存在的论点。 证明责任： 这个思想实验也提出了一个问题：在讨论任何信仰或主张时，责任应当落在谁身上？罗素认为，提出某个主张的人有责任提供证据，而不是要求别人去证明其主张是错误的。如果没有证据支持一个主张，那么就不能合理地要求人们去相信它。 怀疑主义与证据： 拉塞尔的茶壶体现了怀疑主义的重要性，强调了科学、哲学和日常生活中应依赖证据来支持信念。罗素的这一思想实验对于任何要求信仰的事物，都提出了一个挑战：如果你不能证明某个事物的存在，那么你就不应当期望别人相信它。 影响与解读： 拉塞尔的茶壶通常被用来讨论那些无法证伪的宗教或哲学信仰，特别是在面对没有实质证据支持的理论时。这个实验强调了理性、怀疑和证据在信仰体系中的重要性。它不仅影响了哲学领域，也对科学、宗教和日常思维产生了深远影响。 庄周梦蝶 中国古代哲学家庄子提出的一个哲学故事，出自《庄子·齐物论》篇，旨在探讨“现实”与“梦境”、个体身份与变幻之间的关系。 故事内容： 庄子曾经梦见自己变成了一只快乐的蝴蝶，飞舞在花丛中，自由自在，完全忘记了自己是庄子。醒来后，庄子不禁思考：我到底是庄子做梦时变成了蝴蝶，还是蝴蝶做梦时变成了庄子？ 他感到现实与梦境之间的界限变得模糊不清，难以确定哪一个是“真实的”。 哲学意义： 现实与梦境的模糊界限： 这个故事揭示了“现实”与“梦境”之间的相对性。庄子通过梦境与现实的对比，表达了对存在的怀疑。在庄子看来，无论是梦境还是现实，都无法用绝对的标准来确定哪个更为“真实”。这使得我们对“真实”本身的定义变得不那么明确。 个体与身份的相对性： 故事中，庄子既是“庄子”，也可能是“蝴蝶”。这一思考表明了个体身份的相对性。我们可能在不同的情境、不同的认知层面上，经历不同的身份与角色，而这种变化的状态并不意味着身份的本质发生了根本改变。 道家哲学中的“齐物论”： 在庄子哲学中，齐物论（所有事物本质上是平等的）是其核心思想之一。庄周梦蝶的故事反映了这一思想：一切事物都是相对的，梦境与现实、人生与死亡、是与非等都是相对存在的。我们无法绝对区分它们的“本质”，因为所有事物在本质上都是“齐”的，都是“道”的一部分。 “道”的无为与自然： 庄子的这一思想实验还体现了道家哲学中“无为而治”的思想。对于人生和宇宙的种种变幻，庄子提倡顺应自然、放下执念，认为对现实的认知应该是流动的、非固定的，正如蝴蝶与庄子之间无法完全分辨的身份一样。 影响与解读： “庄周梦蝶”被广泛认为是庄子思想中的经典之作，影响了后来的哲学家，尤其是对存在主义和相对主义有深刻的启发。它不仅启发了我们对现实和认知的反思，还引发了关于梦境、意识、身份以及“真理”的哲学讨论。庄周梦蝶成为了中国哲学中一个标志性的象征，表达了对生命与存在的深刻思索。 图灵测试 图灵测试（Turing Test）是由英国数学家和计算机科学家阿兰·图灵在1950年提出的一种用于判断机器是否具备智能的测试。图灵测试的核心思想是：如果一台机器能够在与人类进行交互时，表现得与人类几乎无法区分，那么我们可以认为这台机器具有“智能”。 思想实验设定： 图灵在他的论文《计算机与智能》里提出了这个测试，具体过程如下： 三方对话： 测试由三方组成：一个人类评审员（A），一台机器（B），以及一个人类（C）。评审员与机器和人类通过文本进行交流，不能通过外貌或声音等因素分辨两者。 交互与判断： 评审员的任务是通过与两者的对话，判断哪个是人类，哪个是机器。评审员不能看到或听到被测试的对象，只能通过文字交流。机器的目标是尽可能模仿人类，避免被识别为机器。 测试结果： 如果评审员不能在规定的时间内准确分辨出哪个是机器，哪个是人类，或者误判了机器为人类，那么就可以认为机器通过了图灵测试，表现出类似人类的智能。 哲学与技术意义： 人工智能的定义： 图灵测试最初的目的是解决“机器能否思考？”这个问题。图灵提出，我们不需要知道机器内部的工作原理或是否“意识”，只需要看它是否能够模拟出与人类类似的智能行为。因此，图灵测试强调行为上的智能，而非内部的意识或感知。 “模仿游戏”： 图灵的测试实际上是一种“模仿游戏”。它关注的是外部行为的相似性，而非机器是否真正拥有感知或自我意识。这一观点对后来的人工智能发展产生了深远的影响，使得我们对“智能”这一概念的理解更加侧重于行为表现而非内在机制。 批评与争议： 尽管图灵测试在人工智能领域具有重要影响，但它也面临一些批评。有人认为，机器即使能够通过图灵测试，也不代表它具备真正的意识或理解能力，只是在表面上模仿人类行为。这种观点被称为“模仿并不等同于理解”，即测试只是评估了机器的“外在表现”，而非其内在认知过程。 后续发展： 随着人工智能技术的发展，图灵测试的局限性逐渐显现。例如，早期的“聊天机器人”如ELIZA、Siri等就曾经通过某些简单对话欺骗评审员，尽管它们并不具备真正的智能。因此，图灵测试在当代的人工智能研究中不再是唯一的衡量标准，但它依然是一个经典的思想实验，促使人们思考人工智能和人类智能之间的关系。 影响与解读： 图灵测试为人工智能的研究提供了一个明确的目标——让机器能够“通过人类的测试”，以证明它们具备某种形式的智能。尽管它并非一个完美的衡量标准，但图灵测试仍然是讨论机器智能和意识的重要哲学起点，并激发了关于人工智能本质、道德和伦理等方面的广泛讨论。 黑猩猩的无知 黑猩猩的无知（The Ignorance of the Chimpanzee）是由哲学家卡尔·波普尔（Karl Popper）提出的一个思想实验，旨在探讨科学知识和认识论中的“无知”概念。这个实验的核心是，黑猩猩由于无法理解复杂的抽象概念，它的“无知”在某种程度上代表了人类知识局限性的一个反面。 思想实验设定： 假设一只黑猩猩对一组问题或任务进行尝试，它在面对未知问题时没有足够的知识去做出理性的判断。黑猩猩没有能力理解这些问题的含义，也无法通过逻辑推理来解决它们。它的行为是完全依赖于直觉、经验或者是随机行为，而没有任何关于知识的反思或推理。 哲学意义： 无知与知识的界限： 黑猩猩的无知反映了人类在某些领域或情况下的认知局限性。即使我们在许多领域拥有高度发展的知识和技术，我们仍然可能面临无法理解或无法解答的复杂问题。通过这个思想实验，波普尔提示我们要谦虚地认识到人类所知道的只是局部的，远远没有涵盖整个宇宙的所有奥秘。 科学理论的可证伪性： 波普尔的哲学思想强调科学理论应该具有可证伪性。他认为，科学理论的价值不在于证明它们的正确性，而在于能够通过实验或观察被证明是错误的。通过黑猩猩的无知，波普尔想要阐明，科学研究是不断地从无知中寻找答案的过程，任何看似“真理”的理论，可能在未来通过新的发现被推翻或修正。 人类智慧与动物的差异： 虽然黑猩猩与人类在生物学上有许多相似之处，但其思维和推理能力与人类之间的巨大差异展示了人类智能的独特性。这个实验让我们反思人类如何在某些情境下依赖深思熟虑的逻辑推理和复杂的抽象思维，而动物则通常依赖简单的直觉和行为模式。 认识论的深刻反思： 波普尔通过黑猩猩的无知表达了一个重要的哲学观点：我们在认识世界时，面对的并不仅仅是知识的积累，更多的是如何认识“无知”的问题。科学的进步往往是通过揭示人类无知的边界，推动我们继续探索那些尚未理解的领域。 影响与解读： “黑猩猩的无知”强调了认识论中的一个重要问题：人类知识的局限性。虽然人类与动物有着显著的认知差异，但我们仍然面临着许多未解之谜，这种无知激励了科学探索和哲学思考。波普尔通过这个实验促使我们反思科学的本质，认识到科学理论的相对性和探索的无止境性。 永恒回归 永恒回归这一概念最早源于古代哲学，但在现代哲学中，由德国哲学家尼采的提出而广为人知。尼采在其著作《查拉图斯特拉如是说》（Also sprach Zarathustra）中，借主人公查拉图斯特拉之口，深入探讨了这一哲学命题。永恒回归的命题本质上提出了一种宇宙观：时间和宇宙的过程是循环的，一切在时间的长河中将无休止地重复。根据这一观点，历史的每个事件、每个细节，甚至每个人的生命，都将在某个时刻以完全相同的方式再次发生。 故事 在《查拉图斯特拉如是说》中，尼采让查拉图斯特拉对他自己的生命进行反思，他发现自己若接受“永恒回归”的命题，他所经历的一切都将不再是偶然，而是生命本身的意义所在。故事的重点是通过这个哲学挑战，呼唤人们面对自己的生命时，放下对时间的恐惧，去追求真正的自由与力量。 查拉图斯特拉思考着，假设有一个魔鬼出现在他面前，告诉他：“你的生命将永远重复，你的一切行为、所有的苦难、所有的快乐都将不断地在同样的方式下重演，直到时间的尽头。”这时，查拉图斯特拉问自己，是否会因为无法逃避这份命运而感到绝望？还是他能够全然接受这一事实，甚至热爱自己的生命？ 这个命题通过查拉图斯特拉的探索，让人们意识到——如果每一刻都将被无数次地重复，那么我们应该怎样度过它？这不仅是对查拉图斯特拉个人的挑战，也是在暗示读者：只有接受并热爱这一无止境的循环，人类才能够真正超越平凡、走向一种更高的精神境界。 文化背景 尼采所提出的永恒回归，虽然从古代的哲学和宗教中汲取了不少元素，但他赋予了这一命题新的精神内涵。在古代文化中，特别是印度教、佛教等宗教中，轮回思想是一个重要的概念，即生命会在死亡后不断再生，直到最终超脱或觉悟。尼采的永恒回归可以看作是对这些古老轮回思想的“现代化”，他并不把这一轮回视为一种宗教性的重生，而是看作是对生命态度的哲学挑战。 在尼采的永恒回归中，并没有涉及到灵魂的转世或再生，他关注的焦点是个人的行为和态度。如果你接受永恒回归的命题，那么你应该学会如何从内心深处热爱每一瞬间，因为它们将永远存在。 影响 尼采的永恒回归不仅在哲学上产生了巨大的影响，它还被许多后来的思想家和作家广泛引用和反思。许多文学作品、电影和艺术作品也都在不同程度上探讨了类似的时间循环主题。例如，电影《土拨鼠之日》（Groundhog Day）就以类似的方式表达了永恒回归的思想。影片中的主人公陷入了时间循环中，每天都在重复同一天。随着他逐渐接受这一命运，他开始改变自己的人生态度，最终实现自我超越。 总的来说，尼采的永恒回归不仅仅是一个哲学命题，它更像是对人生、对时间、对选择的深刻反思。它激励人们勇敢地面对生命的每一刻，去迎接挑战，并在不断的重复中找到意义。 宇宙大爆炸悖论 宇宙大爆炸悖论（Big Bang Paradox）通常指的是与宇宙起源和时间、因果关系相关的一些哲学或物理学上的悖论。它并不像传统的逻辑悖论那样直接产生自逻辑推理，而更多是由大爆炸理论及其引发的一系列深刻问题所引发的。 大爆炸理论简介： 大爆炸理论是目前宇宙学中最广泛接受的宇宙起源模型。它提出，宇宙起源于约138亿年前的一个极为密集和高温的点——一个称为“奇点”的状态，并从那时起，宇宙开始膨胀并持续扩展。这一理论得到了来自天文学、物理学和观测数据的广泛支持，例如宇宙背景辐射的存在、星系的红移现象等。 然而，这一理论也引发了许多深刻的问题，尤其是关于时间、因果关系和宇宙的起源的哲学与科学悖论。 宇宙大爆炸悖论的几种解释： 时间的起点悖论： 根据大爆炸理论，宇宙的膨胀始于一个奇点，所有的物质和能量都在这个奇点中极度压缩。当宇宙从这个奇点开始膨胀时，时间也被认为是从这里开始的。这就引出了一个悖论：如果时间从大爆炸那一刻开始，那么大爆炸之前到底发生了什么？ 在经典的因果律中，每个事件都应该有一个原因，然而在大爆炸的奇点之前，时间和空间本身都不存在，因此，似乎没有“之前”的概念。 这一悖论提出了一个深刻的哲学问题：如果没有时间，那么因果关系如何存在？ 这让我们无法用常规的因果思维去解释宇宙的起源。 “空无”悖论： 另一个相关的悖论是关于“空无”的概念。宇宙大爆炸理论认为，整个宇宙曾经处于一个极其紧密、无限小的点中，那么这个点是如何从“空无”中诞生的？ 如果一切从一个奇点中开始，那么这个奇点又如何从空无中“诞生”？更进一步，空无本身是否可能存在？如果宇宙的诞生没有时间和空间的背景，那它又如何能够自发地开始膨胀？ 这个悖论触及了哲学中最基本的存在问题，挑战了我们对“空无”以及“起源”的理解。 宇宙的边界问题： 根据大爆炸理论，宇宙的空间本身是在膨胀的过程中。如果宇宙没有边界，那么宇宙的“外面”在哪里？ 或者说，宇宙膨胀到极限时会发生什么？如果没有外部空间，宇宙膨胀的意义又是什么？这个问题引发了关于宇宙边界的深层哲学与物理学探讨。 尽管一些现代物理学理论，如弦理论或多重宇宙理论，提出了可能的解决方案（例如宇宙可能是一个封闭的曲面，或者宇宙是无限的），但这些解释依然无法完全消除这个悖论。 因果律与大爆炸的因果关系： 根据大爆炸理论，所有物质、能量甚至时间和空间都起源于大爆炸。然而，大爆炸本身如何能成为宇宙的“起点”？ 如果时间本身是从大爆炸时刻开始的，那么它似乎无从谈起“因果律”——即没有时间，如何有因果关系？这似乎违背了我们对因果律的常规理解。 宇宙的膨胀速度与奇点的悖论： 大爆炸理论中的一个关键要素是宇宙从奇点开始膨胀。然而，这个膨胀过程非常迅速，尤其是在宇宙初期的“暴涨”阶段（Inflation），宇宙膨胀速度远远超过光速。这就带来了一个悖论：如果宇宙膨胀超过光速，那么信息传递和因果关系是否依然成立？ 这违背了经典的相对论，因为根据相对论，信息不能传播超过光速。 时间和空间的起源： 大爆炸理论提出时间和空间是一起“诞生”的，时间并非从一个外部的、更高层次的存在开始，而是与宇宙本身的诞生密不可分。那么问题来了：如果时间是宇宙的产物，谁或什么给了时间“开始”？ 时间和空间的概念本身是我们理解宇宙的基础，而大爆炸理论让我们无法回答这个“时间从何而来”的根本问题。 解决思路和现代物理学的进展 尽管大爆炸悖论看起来很难解决，现代物理学，特别是量子力学和弦理论的研究，提出了若干可能的解决途径： 量子引力理论： 量子引力试图结合量子力学和广义相对论，这或许能为大爆炸的奇点提供一个新的视角。量子力学认为，空间和时间并不是绝对连续的，而是具有离散性质的，因此奇点的概念可能需要重新定义。 多重宇宙与平行宇宙理论： 一些物理学家提出多重宇宙理论，认为大爆炸并非宇宙的唯一起点，宇宙的诞生可能是一系列不断发生的过程之一。在这种理论下，宇宙不仅仅是从一个奇点爆发，而可能是从一个更广阔的多重宇宙中脱颖而出的。 暴涨理论（Inflation）： 暴涨理论提出，宇宙在大爆炸后的一瞬间经历了极为迅速的膨胀。这一过程可能帮助解决一些关于宇宙起源的悖论，比如均匀性和各向同性的问题，虽然它仍然未能彻底消解大爆炸悖论中的哲学问题。 莱布尼茨的单子 莱布尼茨的单子（Leibniz's Monads）是德国哲学家戈特弗里德·威廉·莱布尼茨（Gottfried Wilhelm Leibniz）提出的一个哲学概念，属于他的形而上学体系中的重要部分。单子是莱布尼茨关于宇宙和物质本质的核心观点，涉及到他的形而上学、心灵哲学和宇宙论。 单子的定义 莱布尼茨提出，单子是构成宇宙的最基本元素，是不可分割的、永恒的、简单的实体。在他的理论中，单子不等同于传统意义上的物质粒子或物理实体，而是非物质的精神性单位。单子本身没有任何扩展（即没有长度、宽度或高度），它没有物质的属性，但却是宇宙的一种基本存在形式。 莱布尼茨的单子的特性 不可分割性： 单子是最基本的实体，它没有组成部分，因此无法被分割。每一个单子都是一个“最小的单位”，不能再进一步分解。 内在的活力： 每个单子都是“有生命的”，具有内在的动力。这种动力意味着单子会根据它的内在原则（如它的特性和属性）自我发展。每个单子在其内部就包含了它的变化和运动的原因。 无空间扩展： 与传统物质不同，单子是非空间的，也就是说它不占有空间。它没有形状、大小或质地，无法通过物理的方式直接感知到。 反映整个宇宙： 每个单子都是一个微观的宇宙，是宇宙总体结构的反映。单子是“镜像”的，它们以不同的方式反映宇宙的全貌，但每一个单子都包含了宇宙的某种“视角”。这意味着，尽管它们是微小的，它们却包含了整个宇宙的无限丰富性和复杂性。 预定和谐： 莱布尼茨认为，单子的行为是由上帝预先设定的“和谐”所引导的。每个单子在其内部有着一套自我发展和运动的程序，这些程序并不是随机的，而是与其他单子相互协调，形成一个和谐的整体。这种和谐被称为预定和谐，即上帝在创造时已将宇宙中的所有单子和它们的行为安排得井井有条，尽管这些单子互不干涉，最终会产生一种统一的秩序。 无感知和知觉： 尽管单子是精神性的，它们并非完全无知或无意识。莱布尼茨认为，单子具有不同程度的“知觉”（perception）。一些单子（例如我们的人类心灵）具有高度复杂的知觉和感知，而其他的单子（例如无生命的物质）则具有较低的知觉，但仍然拥有某种内在的感知能力。 单子的宇宙观 莱布尼茨的单子论主要是用来解释宇宙的存在和运动的方式。根据莱布尼茨的观点，整个宇宙由无数个单子构成，而这些单子并不是互相之间有直接的物理联系，它们各自独立，但它们的行为却是相互协调的。这种协调来自于上帝在宇宙创生时所设定的“预定和谐”——每个单子都按着某种秩序发展，并最终表现出和谐的整体。 这种观点与牛顿的宇宙观不同，牛顿认为物质在空间中相互作用，并通过物理力（如重力、电磁力等）发生相互作用。而莱布尼茨认为，单子之间的关系是内在的、精神性的，而不是直接的物质交互。物质世界的运动和现象并不是通过直接的物理作用力发生的，而是通过每个单子的内在状态和它们之间的和谐协调来维持的。 单子与其他哲学家的关系 与笛卡尔的区分： 笛卡尔的哲学体系中有物质（res extensa）和精神（res cogitans）两种实体，而莱布尼茨的单子则融合了精神与物质的属性。莱布尼茨的单子既不是物质的，也不是纯粹的精神，它们是灵性和物质属性的结合。 与斯宾诺莎的关系： 莱布尼茨的单子概念也与荷兰哲学家斯宾诺莎的“实体”概念有所相似。斯宾诺莎认为宇宙是由一个无形的、无限的实体（即上帝）构成的，而莱布尼茨的单子也是在某种程度上反映了一个整体宇宙观。不同之处在于，莱布尼茨认为每个单子是一个独立的实体，而不是所有存在都来自一个统一的“神”。 与现代物理学的关系： 尽管莱布尼茨的单子理论是形而上学的，它也与现代物理学中的一些思想产生了共鸣。例如，量子力学中的量子态可以类比为莱布尼茨的单子，因为量子态是独立的、非连续的，并且存在于一个自我发展、内在协调的状态。 莱布尼茨的单子与心灵哲学 莱布尼茨的单子论不仅影响了形而上学，还对他的心灵哲学产生了重要影响。莱布尼茨提出的“单子”概念与他的心灵与物质的二元论有关。他认为，单子不仅是物理世界的基本构成单元，它们还与心灵世界、意识和知觉密切相关。人类的心灵可以被看作是由更高级的单子组成的，这些单子有能力进行自我反思、感知和思考。 结论 莱布尼茨的单子理论是一种关于宇宙本质的深刻探索，提出了一个非物质、非空间化的宇宙观。它强调内在的和谐、预定的协调以及每个单子都拥有某种形式的知觉或意识，这些观点不仅影响了当时的哲学思潮，也为后来的心灵哲学、形而上学和物理学提供了重要的启示。尽管这一理论在现代物理学和哲学中并未得到完全接受，它依然为理解宇宙的本质、物质与精神的关系提供了有趣的哲学思路。 存在的怀疑 存在的怀疑是一个哲学命题，主要指的是对“存在”本身的真实性、确定性和理解的深刻怀疑。它在哲学史上有着悠久的传统，尤其是在笛卡尔的怀疑主义和尼采的虚无主义中表现得尤为突出。存在的怀疑不仅探讨我们如何知晓世界、理解世界，还探讨我们是否能知道我们所感知到的世界是否真实存在。 笛卡尔的怀疑主义 笛卡尔（René Descartes）是西方哲学史上的重要人物，他在《第一哲学沉思》中提出了著名的怀疑一切的方法。他试图通过怀疑来找出一个无可怀疑的真理。他通过“怀疑一切”的方式，逐步深入到一种极端的怀疑态度：怀疑感官知觉、怀疑自己周围的世界、怀疑其他人的存在，最终，他怀疑到连自己的身体和物理世界是否存在都无法确定。笛卡尔的核心怀疑包括了“我思故我在”（Cogito, ergo sum），即尽管我可以怀疑一切，但我无法怀疑我正在怀疑这一行为，因此可以确定自己作为思考者的存在。 笛卡尔的怀疑主义本质上是想通过推翻一切先入为主的观念和假设，最终找到一个不容怀疑的真理基础。虽然他怀疑了许多事物的存在，但他最终找到的唯一无可怀疑的真理便是“我在思考，所以我存在”。这个观点为现代西方哲学奠定了怀疑主义和认识论的基础。 怀疑一切的极端：笛卡尔的恶魔（恶意天才） 笛卡尔进一步提出了恶意天才假设（Evil Demon Hypothesis），这个假设说，假如有一个全能的恶魔，专门欺骗我们，使我们相信我们所知的一切都是假的，甚至包括我们的思想和感觉。这一假设引发了对于感知、现实和知识的更深层次怀疑。笛卡尔的恶魔思想表明，感官无法为我们提供绝对的真理，因为它们可能受到误导。 这一假设不仅挑战了我们对感官世界的信任，还提出了一个问题：如果我们连我们的感官世界都无法确信，那我们如何能够确定我们所知的一切是真的？ 存在的怀疑与现代哲学 在现代哲学中，存在的怀疑逐渐演变为对知识的边界和客观现实的可知性的反思。以下是一些影响深远的哲学观点： a) 海德格尔的存在与时间： 马丁·海德格尔（Martin Heidegger）是20世纪重要的存在主义哲学家，他在《存在与时间》一书中对“存在”提出了根本的质疑。他强调存在本身（Being）是我们无法完全理解和把握的，许多哲学流派关注的是“存在之物”，而忽视了存在本身的难以言说性。海德格尔认为，人类是存在的“存在者”，但我们无法脱离对存在本身的迷惑，因而我们对存在的理解总是有限的。 b) 尼采的虚无主义： 弗里德里希·尼采（Friedrich Nietzsche）提出了著名的虚无主义观念，他认为，在传统的基督教世界观崩溃后，世界变得没有了固有的意义和目的。尼采的虚无主义深刻挑战了我们对存在意义的信仰，他认为人类无法找到一种超越个人的普遍意义，因此，个体在面对宇宙和生命的无意义时，会感到深深的迷茫和困惑。尼采的“上帝已死”这一命题，正是指向了西方社会传统信仰体系的崩塌，从而带来了对存在的怀疑和对意义的追寻。 c) 后结构主义与后现代哲学的怀疑： 后结构主义者（如米歇尔·福柯、雅克·德里达等）对传统哲学的怀疑更加深入，尤其是在对语言、权力、身份等概念的批判上。后现代哲学认为，人类的知识是由语言、文化、社会权力结构塑造的，而并非反映客观的、真实的世界。福柯特别强调历史与权力的关系，他认为“知识”并非中立的，它总是与权力相联系的，因此我们对存在、真理的理解也充满了偏见和操控。 存在的怀疑与科学 即使在现代科学的背景下，存在的怀疑依然具有深远的影响。在科学中，怀疑精神被视为推动科学发现的动力之一。科学家常常必须怀疑和验证先前的假设和理论，直到通过实验和证据建立起更加可靠的知识体系。科学怀疑主义就是对所有知识、特别是自称为“客观真理”的知识的怀疑，认为这些知识可能受到局限、误导甚至偏见的影响。 科学中的怀疑也体现在对“现实”的定义上。例如，量子力学的发现让我们质疑了我们对物质世界的传统认知。量子世界的奇特现象（如粒子的波粒二象性、量子纠缠等）使得我们不得不怀疑，我们所知道的“物质”世界，是否真的是我们感知到的那样。 结语 存在的怀疑作为哲学的一个基本议题，贯穿了从古希腊到现代的哲学传统。它不仅是对感官世界的怀疑，也触及到知识、意义、真实性、意识等核心问题。从笛卡尔的怀疑主义到尼采的虚无主义，再到后现代哲学对知识和权力的批判，存在的怀疑持续影响着我们对世界的认识。它提醒我们：无论我们如何努力理解世界，存在本身总是含有某种不可知的神秘性，甚至让我们在面对它时深感困惑和迷茫。而这种怀疑，也许正是人类哲学探索的一种动力源泉，推动着我们不断追问和探索存在的真相。 盲人摸象 盲人摸象是一个源自印度的古老寓言，它通过一个简单的故事揭示了不同的角度对真理认知的局限性。这则寓言不仅在哲学中被广泛引用，也常用于阐述认识论、相对主义以及科学和社会观察中不同观点的碰撞。 故事内容 故事大致内容如下： 几个盲人（或者说视力受损的人）站在一只大象旁边，每个人分别触摸到大象身体的不同部位，并根据触摸到的部分，描述他所认为的“大象”。由于他们每个人接触到的大象部分不同，因此每个人对大象的理解也大相径庭： 一个摸到象腿的盲人说：“大象像一根大柱子，坚硬且直。” 一个摸到象耳的盲人说：“不对！大象像一把扇子，柔软而又能摆动。” 一个摸到象尾的盲人说：“你们错了！大象像一根绳子，又细又长。” 一个摸到象鼻的盲人说：“你们都不对！大象像一根管子，弯曲而灵活。” 于是，他们开始争论，每个人都认为自己触摸到的部分就是整个大象的真实样子，并认为其他人的看法是错误的。 寓意与哲学意义 “盲人摸象”寓言的深层意义是，每个人的理解都是有限的，无法完全代表事物的全貌。这个故事主要传达了几个哲学和认知学的观点： 局部与整体的关系： 故事表明，如果只从某一个局部来判断整体，往往会得出片面甚至错误的结论。每个盲人只看到了大象的一部分，而他们将自己局限的观察当作了全面的真相。这个寓言揭示了局部和整体之间的区别，提醒我们要注意从多个角度全面观察问题，才能得出接近真理的结论。 感知的局限性： 故事中的盲人象征着我们每个人在感知世界时的局限性。我们的知识、经验和观察通常受到自身条件的限制，比如视角、感官、背景、文化等。因此，我们每个人对同一事物的理解往往只是从自身条件出发的一部分看法。 认识的相对性： 盲人摸象寓言也常常被用来说明相对主义的观点，即不同的观察者基于不同的经验和立场，可能会得出不同甚至相互冲突的结论。每个人的认知都是相对的，无法单凭一方的观点来断定其他所有人的看法都是错误的。这种思想不仅在哲学中被用来讨论真理，也影响了许多社会、文化和政治领域。 多元化视角的重要性： 这个故事也提醒我们，在面对复杂问题时，往往需要多角度的理解和多种视角的整合。不同的观察者从不同的角度出发，可能会得到不同的认识，合并这些不同的观察视角，有助于我们更全面地了解事物的全貌。 批评与局限 尽管“盲人摸象”作为一个比喻极具启发性，但也有人批评它过于强调不同视角的对立，忽视了通过理性分析和证据逐步接近真理的可能性。毕竟，大象作为一个物体，最终仍然是存在的，其整体形态是可以通过适当的方法（如综合多个感知角度）来揭示的。因此，某些批评者认为，故事也许过于强调了认知的局限性，而忽视了通过方法和沟通克服这些局限、寻求共识的重要性。 多重宇宙理论 多重宇宙理论（Multiverse Theory）是一个极具吸引力且具有高度争议的科学和哲学概念，指的是宇宙不仅仅是唯一的，而是存在多个平行的宇宙。每个宇宙都可能拥有不同的物理常数、物理法则，甚至可能表现出完全不同的物理现象。多重宇宙理论挑战了我们对宇宙的常规理解，并为我们提供了一种可能的宇宙模型：宇宙不仅是一个孤立的系统，而是一个广袤的多元体系。 多重宇宙理论的起源和发展 多重宇宙的概念最早并非来源于现代物理学，而是在哲学和神话中有类似的表述。在古代神话中，常常有关于平行世界或多个宇宙存在的传说。例如，印度的宇宙论和希腊哲学中就有类似的宇宙观念。 现代的多重宇宙理论起源于量子力学、宇宙学和弦理论等领域。20世纪中期以来，随着对量子物理和宇宙起源的研究逐步深入，科学家们逐渐提出了一些关于平行宇宙的假设，并在不同的物理框架下加以探讨。 多重宇宙理论的不同版本 多重宇宙理论的具体形式因学派和理论而异，以下是几种较为著名的版本： a) 量子多重宇宙（多世界解释） 量子力学中的多世界解释（Many-Worlds Interpretation，MWI）由物理学家休·埃弗雷特（Hugh Everett）在1957年提出。根据这种解释，量子事件不是单一的，而是每一个量子决策都会导致宇宙的分裂。举个例子，当一个量子系统处于不确定态（比如粒子是同时处于多个位置），多世界解释认为宇宙会“分裂”成多个平行宇宙，每个宇宙对应于不同的量子结果。 这种解释的一个核心观点是量子叠加态和波函数塌缩的概念，在经典的哥本哈根解释中，波函数在观测时会“塌缩”到一个确定状态，而在多世界解释中，每个可能的观测结果都在一个独立的分支中得以实现，因此宇宙实际上在每一个量子事件中都“分裂”了。 b) 弦理论与宇宙泡沫模型 弦理论是另一种解释多重宇宙的方式，特别是在超弦理论中。根据弦理论，宇宙不再是由粒子构成，而是由极小的“弦”构成的。这些弦振动的方式决定了不同的物质和力。弦理论的一个重要结果是，宇宙可能不仅有三维空间和一维时间，而是存在更多的维度，甚至可能有11个维度（如M理论所提出的）。 在弦理论的框架下，宇宙泡沫模型（Bubble Multiverse）被提出。根据这一理论，我们的宇宙只不过是一个更大“宇宙泡沫”中的一部分，每个泡沫对应着一个独立的宇宙，且这些宇宙可能有不同的物理法则和常数。例如，有些宇宙可能在空间尺度、时间进程或物理常数上有所不同。 c) 宇宙膨胀与无限宇宙 宇宙膨胀理论（Inflationary Theory）是对宇宙起源的广泛接受的理论之一。根据这一理论，宇宙在极短的时间内经历了剧烈的膨胀，从一个极小的点扩展成我们现在所见的广阔宇宙。 这种膨胀理论的一个衍生模型是永恒膨胀（Eternal Inflation）。在永恒膨胀的框架下，宇宙的膨胀并不是一次性完成的，而是在不断的过程中。在某些区域，膨胀可能会停止，形成一个新的宇宙，而其他区域则继续膨胀，形成更多的宇宙。因此，宇宙膨胀不仅在我们的宇宙中发生，也可能在多个独立的区域中进行，每个区域对应一个新的宇宙。 d) 数学宇宙假说 由物理学家马克斯·泰格马克（Max Tegmark）提出，数学宇宙假说认为，所有的数学结构都代表着一个实际存在的宇宙。在这一观点下，宇宙不仅仅是物理的，它还可以是数学的。根据这种观点，宇宙的结构完全由数学公式和规律所决定，所有可能的数学结构都对应着一个物理宇宙。这意味着，无论我们是否能够观测到，所有数学上可能存在的宇宙都会实际存在。 多重宇宙理论的哲学和科学挑战 尽管多重宇宙理论提供了对宇宙和现实的激动人心的解释，但它同样面临一些巨大的挑战，尤其是科学和哲学上的挑战。 a) 不可证伪性 多重宇宙理论面临的一个最大挑战是不可证伪性。科学理论需要能够通过实验或观测来证实或否定。然而，由于多重宇宙中的其他宇宙和我们的宇宙相互隔离，它们彼此无法直接交互或观测，这使得多重宇宙理论很难通过实验证据来验证。因此，这一理论目前仍然属于一种假设性理论，尚未获得广泛的实证支持。 b) 哲学的“宇宙中心主义”问题 多重宇宙理论还引发了关于我们在宇宙中的地位的哲学讨论。如果我们的宇宙只是无限多宇宙中的一个，且这些宇宙都可能具有不同的物理法则，那么这将使得我们的宇宙显得极其微不足道。这种想法挑战了人类对于“特殊性”或“中心”的传统观念，可能对一些人的世界观产生深远影响。 c) 物理常数的选择性问题 如果存在多个宇宙，那么这些宇宙中每个宇宙的物理常数和法则是否是随机选择的，还是遵循某种规律？如果它们是随机的，这将导致“人择原理”（Anthropic Principle）的出现，即只有适合生命存在的宇宙才会被观察到。这个问题涉及到如何理解宇宙的自然法则及其随机性。 结论 多重宇宙理论是一个充满想象力和创新的概念，它试图解释我们宇宙的起源、结构和性质，并且提供了一个更加宽广的宇宙观。无论是量子力学的多世界解释，还是宇宙膨胀和永恒膨胀的模型，都展示了现代物理学对宇宙极限的探讨。然而，尽管多重宇宙理论提供了丰富的思考和可能性，但由于其不可证伪性以及一些哲学和科学上的难题，它依然是一个充满争议和探索空间的领域。在未来，随着科学技术的进步，或许我们能够进一步验证这些大胆的假设，探索更广阔的宇宙秘密。 安布罗斯的螺旋 安布罗斯的螺旋（Ambrose's Spiral）是一个哲学性和思维实验性质的命题，通常被用来探索无穷和自我增殖的概念。这个概念并不指向某一特定的哲学或科学理论，而是通过一种假设的螺旋形结构来隐喻无限递归、无止境的延续和时间的循环等主题。 背景和来源 “安布罗斯的螺旋”这个名称本身并没有历史上的具体事件或著名人物作为背景，但它可以被视为对某些经典悖论或哲学命题的抽象表述。这种“螺旋”通常象征着一个递归或无限重复的过程，代表着一种没有尽头或无法穷尽的运动或逻辑。 该概念与一些经典的哲学问题相关，比如时间的无限性、自我意识的递归、空间的无穷等，类似于古希腊的无限悖论，或现代数学中的无限集和递归理论。 安布罗斯的螺旋：无限的象征 在“安布罗斯的螺旋”这个假设中，螺旋本身代表着一种无限的进程，每一圈都会不断向外扩展，但又始终处于一个不断向中心收缩的过程。这种螺旋的形状暗示着几个哲学上重要的主题： 递归与自指：螺旋的每一圈都可以被看作是前一圈的延续，类似于递归过程中的自我调用。在这个过程中，每一层次的存在都是对先前层次的重复与延伸，形成了一个没有终点的回路。这一结构可能象征着自我意识的不断更新和循环，例如人类在探索自己的存在时，总是不断回溯并重新定义自我。 时间的循环：如果将螺旋视为时间的比喻，它暗示着时间并非是线性的，而是呈现出某种“循环”的性质。每一圈的“延伸”都表示着一个周期的开始与结束，而螺旋的形式意味着这种循环永无止境，始终在时间的延续中回到某些基本的主题或状态。 无限的拓展：螺旋的不断展开象征着宇宙的无限性，它没有明确的边界或终点，每一圈都比上一圈更广阔。类似地，科学中对宇宙的理解总是在不断扩展，无论是在物理尺度上还是在认知深度上，人类总是在探索未知。 与其他哲学和科学悖论的关联 “安布罗斯的螺旋”与一些经典的哲学和科学悖论有相似之处： 无限回归（Infinite Regress）：螺旋形的结构隐含着某种形式的无限回归，即每一层次或每一圈的展开都依赖于前一圈，且没有终点。这个思维方式类似于无限回归悖论，它在哲学中提出了这样一个问题：如果一切都需要某个前提或原因，那这个前提本身又需要另一个前提，这种回归是无法停止的。 巴拿赫-塔斯基悖论：数学中的巴拿赫-塔斯基悖论表明，某些物体（如球体）可以被拆分并重新组合成多个相同的物体。这个悖论与螺旋的无限展开有相似之处，它揭示了无限和分裂的关系。 哥德尔不完备定理：哥德尔的定理指出，在任何足够复杂的数学体系中，总有一些命题是无法被证明或反驳的，意味着系统的局限性和递归的无止境。这与螺旋的递归性质相关，揭示了某些过程和问题无法达到终极的答案或解答。 螺旋的哲学意义 安布罗斯的螺旋象征了多个哲学主题： 自我与他者的关系：螺旋不仅仅是一个空间上的形状，它还象征着“自我”与“他者”之间的关系。每一圈的回旋既是对自己内在状态的反思，也可能是对外部世界的适应。它反映了个体在不断变化的过程中寻找自己定位的难题。 无尽的探寻：就像螺旋不会有固定的终点一样，这个寓言暗示着人类对于真理、意义、存在等问题的探索也可能永远没有最终的答案。每一次的探索都可能带来新的问题和新的发现，从而推动思考的无止境延续。 巴纳姆效应 巴纳姆效应（Barnum Effect），也称为福勒效应（Forer Effect），是指人们倾向于接受一些模糊而普遍的描述，认为它们非常符合自己的个性和情况，尽管这些描述可以适用于绝大多数人。这个效应得名于19世纪美国著名的马戏团老板P.T. 巴纳姆（Phineas Taylor Barnum），他以“每个人都有喜欢的事物”以及“展示无数千奇百怪的事物”为特色，成功吸引了观众。他的名言“每个人都会喜欢看他自己”也反映了巴纳姆效应的核心。 巴纳姆效应的历史背景 巴纳姆效应的概念最早由心理学家伯特兰·福勒（Bertram Forer）在1948年提出。福勒做了一个心理学实验，要求一组学生填写个性测试问卷，并承诺根据他们的答案提供个性化的结果。然后，他给每个学生提供了一段个性分析，这段分析非常宽泛、模糊，而且适用于绝大多数人，例如： “你有时会对自己不够自信，但在某些时刻，你也会感到非常自豪和有成就感。” 虽然这段分析并不针对任何特定的人，学生们却普遍认为它非常准确地反映了自己的性格。大多数学生在回顾分析时给出了高分，认为它非常符合自己的情况。 巴纳姆效应的基本机制 巴纳姆效应揭示了人们如何被模糊和普遍的描述所误导。以下是这种现象的几个关键特征： 普适性：描述通常很宽泛，可以适用于许多不同的人。例如，“你有时过于担心别人怎么看你”或“你有时觉得自己在某些方面做得不够好”，这些陈述听起来像是对个人的准确描述，但其实几乎每个人都有类似的感受。 自我中心：人们对自己有强烈的兴趣，尤其是对了解自己个性的描述。即使是模糊的、广泛的描述，也会被当作是特别定制的，符合自己个性或生活状况的内容。 确认偏误：巴纳姆效应背后的心理学原理之一是确认偏误（Confirmation Bias），即人们倾向于接受那些符合自己已有信念或感知的消息，忽视那些与之不符的信息。当人们看到一个模糊但正面的个性描述时，他们会更容易聚焦于其中符合自己经历的部分，而忽视不相关的内容。 巴纳姆效应的应用 巴纳姆效应的应用非常广泛，尤其在一些看似精准的心理学分析、星座预测、占卜以及自我帮助书籍中体现得尤为明显： a) 星座和占卜 星座学和占卜是巴纳姆效应的经典应用领域。星座分析和占卜往往采用普适性强、模糊的语言，适用于大多数人。例如，星座运势中的描述常常如此： “今天，你可能会遇到一些挑战，但也会发现自己有足够的力量克服困难。” 无论是哪个星座的人，都可能会在某个时刻遇到挑战或感到自己有足够的力量应对，所以这一描述对于每个人都是有效的。 b) 心理测试和性格分析 许多性格测试和心理分析（尤其是那些没有科学依据的测试）也依赖巴纳姆效应。比如一些网上测试，提供的“个性分析”经常包含这种类型的模糊陈述： “你是一个很有创造力的人，虽然你外表看起来自信，但有时候你也会怀疑自己。” 这些看似深刻的分析，实际上适用于绝大多数人，因此人们容易认为自己符合这些个性特征。 c) 广告和营销 在广告中，巴纳姆效应也得到了应用，尤其是在那些针对消费者心理进行个性化营销的领域。例如，某些品牌通过宽泛的标签或情感化的广告来吸引顾客，使顾客产生共鸣，觉得这些广告是特别为他们量身定制的。 d) 心理学和自我帮助书籍 许多心理学和自我帮助书籍使用巴纳姆效应来让读者感到这些内容非常符合他们的需求或困惑。这些书籍常常采用普适性强的语言，给出普遍适用的建议或生活哲理。例如，建议“你应该相信自己，但也不要过于自负”，这些言辞看似深刻，但对于大多数人而言，它们都是适用的。 为什么巴纳姆效应有效 巴纳姆效应之所以能够产生如此强大的心理效应，主要是由于人们对自我的极大关注和对个性化认知的需求。我们通常认为自己是独特的，渴望能够通过某些方式了解自己更多。模糊的描述，尽管适用于所有人，但我们更倾向于将其解释为对自己个性和生活状况的精确反映。 此外，确认偏误也在其中起到了重要作用。当人们看到一些正面且模糊的描述时，往往会过度认同并强化这些信息，忽视或低估其中不适用的部分。 巴纳姆效应的科学研究 关于巴纳姆效应的研究揭示了人类认知的某些特点，例如： 自我认同：人们倾向于接受任何与自己相关的信息，尤其是那些看似正面的信息，即使这些信息实际上非常普遍。 心灵感应的错觉：巴纳姆效应帮助解释了为什么一些人相信超自然的现象（例如占卜、心灵感应等）。人们容易接受那些模糊的、不具备具体证据的“预言”，尤其是当它们符合自己的愿望或当前的情境时。","link":"/%E5%A4%A9%E9%A9%AC%E8%A1%8C%E7%A9%BA/philosophy/"},{"title":"诗词歌赋","text":"哲理 菩提偈 惠能 唐代 菩提本无树，明镜亦非台。 佛性常清净，何处有尘埃！ 身是菩提树，心为明镜台。 明镜本清净，何处染尘埃！ 菩提本无树，明镜亦非台。 本来无一物，何处惹尘埃！ 菩提只向心觅，何劳向外求玄？ 听说依此修行，西方只在目前！ 爱情 卜算子·赠乐婉杭妓 施酒监 宋代 相逢情便深，恨不相逢早。识尽千千万万人，终不似、伊家好。 别你登长道。转更添烦恼。楼外朱楼独倚阑，满目围芳草。 卜算子·答施 乐婉 宋代 相思似海深，旧事如天远。泪滴千千万万行，更使人、愁肠断。 要见无因见，拚了终难拚。若是前生未有缘，待重结、来生愿。 钗头凤·红酥手 陆游 宋代 红酥手，黄縢酒，满城春色宫墙柳。东风恶，欢情薄。一怀愁绪，几年离索。错、错、错。 春如旧，人空瘦，泪痕红浥鲛绡透。桃花落，闲池阁。山盟虽在，锦书难托。莫、莫、莫！ 钗头凤·世情薄 唐琬 宋代 世情薄，人情恶，雨送黄昏花易落。晓风干，泪痕残。欲笺心事，独语斜阑。难，难，难！ 人成各，今非昨，病魂常似秋千索。角声寒，夜阑珊。怕人寻问，咽泪装欢。瞒，瞒，瞒！ 山歌·亲老婆 冯梦龙 明代 天上星多月弗多。雪白样雄鸡当弗得个鹅。煮粥煮饭还是自家田里个米。有病还需亲老婆。 忽然道学。还是无病的日子多。 杂项 无题 出处暂不表，烦请自行搜索 雾不清，竹不青，斑驳光漫影。 山也明，鹿也鸣，清脆音铃铃。 雾不清，竹不青，雨打芭蕉向晚晴，蓑衣除去一身轻。 山亦凌，人亦泠，风吹钟磬越冬行，雀鸟叽喳似云聆。 竹不青，雾不明，履踏湿苔露沾襟。何处明月照我影，人鬼幢幢行。 雾不清，竹不青，何人寄我相思情。 物以清，情以清，相思买断一场清。 夜不清，天不晴，唯有相思记魂灵。 雾不清，竹不青，远山深处寄风轻。 似钟磬，似魂倾，梦中几度赴谁情。 整活组： 雾不清，竹不青，莎普爱思滴眼睛。","link":"/%E5%A4%A9%E9%A9%AC%E8%A1%8C%E7%A9%BA/poems/"},{"title":"建站过程","text":"什么是 Hexo？ Hexo 是一个快速、简洁且高效的博客框架。 Hexo 使用 Markdown（或其他标记语言）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 详情请自行翻阅官网：https://hexo.io/zh-cn/docs/ 此处仅贴出常用指令自用。 1234567891011121314151617181920212223242526272829303132333435363738# 使用 npm 安装 Hexo$ npm install -g hexo-cli# 请自行替换文件夹名,新建一个网站$ hexo init &lt;folder&gt; $ cd &lt;folder&gt;$ npm install# 新建一篇文章,文章名称和标题为 [title],文章采用 [layout] 布局$ hexo new [layout] &lt;title&gt;$ hexo new &quot;post title with whitespace&quot; # 如果标题包含空格，需加引号# 清除缓存,网页正常情况下可以忽略此条命令,执行该指令后,会删掉站点根目录下的public文件夹$ hexo clean# 生成静态文件$ hexo generate$ hexo g# 发表草稿$ hexo publish [layout] &lt;filename&gt;# 启动服务器（常用于调试）$ hexo server$ hexo s# 部署网站,将本地数据部署到远端服务器(如github、coding)$ hexo deploy$ hexo d# 创建分类选项Created: ~\\myBlog\\source\\categories\\index.md$ hexo new page categories# 需分类的文章要添加# categories: # - web前端# 注意这里的分类名前需要一个空格#如果在“- web前端”下方添加“-xxx”，hexo不会产生两个分类，而是把分类嵌套（即该文章属于 “- web前端”下的 “-xxx ”分类）。 链接Github 123456789101. 生成SSH_KEY首先在git下输入命令：cd ~/.ssh进入.ssh文件输入命令：ssh-keygen -t rsa -C ‘注册时的邮箱地址’ 将刚刚在.ssh目录下所复制的id_rsa.put文件中的信息复制进key(注意空格)（名字随意） 接着在本地绑定与Github的用户名和邮箱（git）输入命令：git config --global user.name “注册时用户名”输入命令：git config --global user.email “注册时邮箱” 在 Windows PowerShell 下重新生成 SSH 密钥并配置 GitHub，按照以下步骤操作：（出自gpt） 1. 打开 PowerShell 首先，按下 Win + X，然后选择 Windows PowerShell，或在开始菜单中搜索 &quot;PowerShell&quot; 并运行。 2. 生成 SSH 密钥 在 PowerShell 中运行以下命令来生成新的 SSH 密钥： 1ssh-keygen -t rsa -b 4096 -C &quot;your_email@example.com&quot; -t rsa：指定使用 RSA 算法。 -b 4096：指定密钥长度为 4096 位（安全性更高）。 -C &quot;your_email@example.com&quot;：添加一个注释，通常是你的电子邮件地址，方便以后识别。 执行该命令后，你会看到类似以下的提示： 1Enter file in which to save the key (C:\\Users\\your_username\\.ssh\\id_rsa): 按下 Enter，接受默认的保存位置（C:\\Users\\your_username\\.ssh\\id_rsa），或者可以输入一个新的路径。 3. 设置密码短语（可选） 接下来会提示你输入一个 密码短语。这个密码用于保护私钥，你可以选择设置一个密码，或者直接按 Enter 跳过设置密码短语。 4. 添加 SSH 密钥到 SSH 代理 生成完密钥后，接下来需要将 SSH 密钥添加到 SSH 代理。首先启动 SSH 代理，并将密钥加载到代理中。 运行以下命令启动 SSH 代理： 1eval $(ssh-agent -s) 然后，添加你的私钥（默认为 id_rsa）到 SSH 代理： 1ssh-add ~/.ssh/id_rsa 5. 复制公钥到剪贴板 接下来，你需要将公钥复制到剪贴板，以便将其添加到 GitHub。 运行以下命令来显示公钥： 1cat ~/.ssh/id_rsa.pub 将显示的公钥内容复制到剪贴板，按下 Ctrl + C 或右键点击 PowerShell 窗口并选择 复制。 6. 将公钥添加到 GitHub 登录到 GitHub。 点击右上角的头像，然后选择 Settings。 在左侧菜单中，点击 SSH and GPG keys。 点击 New SSH key。 在 Title 字段中，为你的 SSH 密钥命名（例如：“Windows SSH Key”）。 将刚才复制的公钥粘贴到 Key 字段中。 点击 Add SSH key。 7. 测试 SSH 连接 完成上述步骤后，测试 SSH 连接是否成功： 1ssh -T git@github.com 如果是第一次连接，可能会看到如下提示，询问是否信任 GitHub 的服务器： 12The authenticity of host 'github.com (IP_ADDRESS)' can't be established.Are you sure you want to continue connecting (yes/no)? 输入 yes 后继续。 如果成功连接，将看到类似以下的消息： 1Hi username! You've successfully authenticated, but GitHub does not provide shell access. 8. 配置 Git 使用 SSH 最后，确保 Git 配置使用 SSH 而不是 HTTPS 进行推送和拉取操作。检查远程 URL： 1git remote -v 如果显示的 URL 是类似于 https://github.com/username/repository.git，可以将它改成 SSH 版本： 1git remote set-url origin git@github.com:username/repository.git 如无法推送至git，或许修改端口可以解决。 关于markdown中显示图片并设置大小和位置，可以使用 这里的images在source下 1&lt;img src=&quot;/images/test.svg&quot; width=&quot;50%&quot; height=&quot;50%&quot; align=&quot;center&quot;&gt; 为了居中显示图片，可以 123&lt;div align=&quot;center&quot;&gt; &lt;img src=&quot;/images/test.svg&quot; width=&quot;50%&quot; height=&quot;50%&quot; align=&quot;center&quot;&gt;&lt;/div&gt; Icarus 伊卡洛斯，希腊神话中：“必须在半空中飞行。你如果飞得太低，羽翼会碰到海水，沾湿了会变得沉重，你就会被拽在大海里；要是飞得太高，翅膀上的羽毛会因靠近太阳而着火。”他努力接近太阳，羽毛着火落入海水而死。 数学公式渲染 当在markdown中使用数学公式，会出现渲染两次 123$$L = -\\frac{1}{N} \\sum_{i=1}^{N} \\left[ y_i \\log(\\hat{y}_i) + (1 - y_i) \\log(1 - \\hat{y}_i) \\right]$$ 依据deepseek的提示和试错，找到一种可能的解决方法。 12345678这是一个行内公式：\\\\( E = mc^2 \\\\)\\\\(a+b=c\\\\)### 块级公式这是一个块级公式：\\\\[E = mc^2\\\\] 渲染得到下图，问题解决。 相关配置，在_config.yml文件中 123mathjax: enable: true auto_render: false # 禁用自动渲染 在_config.icarus.yml文件中 12# MathJax 配置mathjax: true 然而，在使用时发现当渲染复杂公式时可能会失败。 于是又考虑另一个方法：使用katex。在markdown中，正常使用&quot;$&quot;符号。无论是行内还是块内均可。 12345$$y = f\\left( \\sum_{i=1}^{n} w_i x_i + b \\right)$$$a+b=c$ 渲染得到下图，问题解决。 相关配置，在_config.yml文件中 123katex: enable: true auto_render: false # 禁用自动渲染 在_config.icarus.yml文件中 12katex: truemathjax: false 注意：KaTeX对 $ 后的空格是敏感的，但它的行为与 LaTeX 稍有不同。在LaTeX中，空格通常会被自动忽略，而KaTeX则在某些情况下可能会导致渲染问题。","link":"/%E5%BB%BA%E7%AB%99%E7%9B%B8%E5%85%B3/use-of-theme/"},{"title":"Redis","text":"Redis 简介 Redis（Remote Dictionary Server）是一个开源的内存数据库，遵守 BSD 协议（Berkeley Software Distribution license），它提供了一个高性能的键值（key-value）存储系统，常用于缓存、消息队列、会话存储等应用场景。 性能极高：Redis 以其极高的性能而著称，能够支持每秒数十万次的读写操作。这使得Redis成为处理高并发请求的理想选择，尤其是在需要快速响应的场景中，如缓存、会话管理、排行榜等。 丰富的数据类型：Redis 不仅支持基本的键值存储，还提供了丰富的数据类型，包括字符串、列表、集合、哈希表、有序集合等。这些数据类型为开发者提供了灵活的数据操作能力，使得Redis可以适应各种不同的应用场景。 原子性操作：Redis 的所有操作都是原子性的，这意味着操作要么完全执行，要么完全不执行。这种特性对于确保数据的一致性和完整性至关重要，尤其是在高并发环境下处理事务时。 持久化：Redis 支持数据的持久化，可以将内存中的数据保存到磁盘中，以便在系统重启后恢复数据。这为 Redis 提供了数据安全性，确保数据不会因为系统故障而丢失。 支持发布/订阅模式：Redis 内置了发布/订阅模式（Pub/Sub），允许客户端之间通过消息传递进行通信。这使得 Redis 可以作为消息队列和实时数据传输的平台。 单线程模型：尽管 Redis 是单线程的，但它通过高效的事件驱动模型来处理并发请求，确保了高性能和低延迟。单线程模型也简化了并发控制的复杂性。 主从复制：Redis 支持主从复制，可以通过从节点来备份数据或分担读请求，提高数据的可用性和系统的伸缩性。 应用场景广泛：Redis 被广泛应用于各种场景，包括但不限于缓存系统、会话存储、排行榜、实时分析、地理空间数据索引等。 社区支持：Redis 拥有一个活跃的开发者社区，提供了大量的文档、教程和第三方库，这为开发者提供了强大的支持和丰富的资源。 跨平台兼容性：Redis 可以在多种操作系统上运行，包括 Linux、macOS 和 Windows，这使得它能够在不同的技术栈中灵活部署。 Redis 与其他 key-value 存储有什么不同？ Redis 与其他 key-value 存储系统的主要区别在于其提供了丰富的数据类型、高性能的读写能力、原子性操作、持久化机制、以及丰富的特性集。 以下是 Redis 的一些独特之处： 丰富的数据类型：Redis 不仅仅支持简单的 key-value 类型的数据，还提供了 list、set、zset（有序集合）、hash 等数据结构的存储。这些数据类型可以更好地满足特定的业务需求，使得 Redis 可以用于更广泛的应用场景。 高性能的读写能力：Redis 能读的速度是 110000次/s，写的速度是 81000次/s。这种高性能主要得益于 Redis 将数据存储在内存中，从而显著提高了数据的访问速度。 原子性操作：Redis 的所有操作都是原子性的，这意味着操作要么完全执行，要么完全不执行。这种特性对于确保数据的一致性和完整性非常重要。 持久化机制：Redis 支持数据的持久化，可以将内存中的数据保存在磁盘中，以便在系统重启后能够再次加载使用。这为 Redis 提供了数据安全性，确保数据不会因为系统故障而丢失。 丰富的特性集：Redis 还支持 publish/subscribe（发布/订阅）模式、通知、key 过期等高级特性。这些特性使得 Redis 可以用于消息队列、实时数据分析等复杂的应用场景。 主从复制和高可用性：Redis 支持 master-slave 模式的数据备份，提供了数据的备份和主从复制功能，增强了数据的可用性和容错性。 支持 Lua 脚本：Redis 支持使用 Lua 脚本来编写复杂的操作，这些脚本可以在服务器端执行，提供了更多的灵活性和强大的功能。 单线程模型：尽管 Redis 是单线程的，但它通过高效的事件驱动模型来处理并发请求，确保了高性能和低延迟。 Redis 数据类型 Redis 主要支持以下几种数据类型： string（字符串）: 基本的数据存储单元，可以存储字符串、整数或者浮点数。 hash（哈希）:一个键值对集合，可以存储多个字段。 list（列表）:一个简单的列表，可以存储一系列的字符串元素。 set（集合）:一个无序集合，可以存储不重复的字符串元素。 zset(sorted set：有序集合): 类似于集合，但是每个元素都有一个分数（score）与之关联。 位图（Bitmaps）：基于字符串类型，可以对每个位进行操作。 超日志（HyperLogLogs）：用于基数统计，可以估算集合中的唯一元素数量。 地理空间（Geospatial）：用于存储地理位置信息。 发布/订阅（Pub/Sub）：一种消息通信模式，允许客户端订阅消息通道，并接收发布到该通道的消息。 流（Streams）：用于消息队列和日志存储，支持消息的持久化和时间排序。 模块（Modules）：Redis 支持动态加载模块，可以扩展 Redis 的功能。 String（字符串） string 是 redis 最基本的类型，可以理解成与 Memcached（一个高性能、分布式内存对象缓存系统） 一模一样的类型，一个 key 对应一个 value。 string 类型是二进制安全的。意思是 redis 的 string 可以包含任何数据，比如jpg图片或者序列化的对象。 任意数据存储：Redis 的字符串可以存储任何二进制数据，包括文本、图片、音频等，不受限于可打印字符。 无编码转换：数据存储和检索时，Redis 不会对其进行编码或解码，保证数据的原始性。 长度明确：Redis 通过长度而非终止符（如 C 语言中的 \\0）来确定字符串的边界，因此可以包含空字符等特殊字节。 string 类型是 Redis 最基本的数据类型，string 类型的值最大能存储 512MB。 常用命令 SET key value：设置键的值。 GET key：获取键的值。 INCR key：将键的值加 1。 DECR key：将键的值减 1。 APPEND key value：将值追加到键的值之后。 注意：一个键最大能存储 512MB。 Hash（哈希） Redis hash 是一个键值(key=&gt;value)对集合，类似于一个小型的 NoSQL 数据库。 Redis hash 是一个 string 类型的 field 和 value 的映射表，hash 特别适合用于存储对象。 每个哈希最多可以存储 2^32 - 1 个键值对。 常用命令 HSET key field value：设置哈希表中字段的值。 HGET key field：获取哈希表中字段的值。 HGETALL key：获取哈希表中所有字段和值。 HDEL key field：删除哈希表中的一个或多个字段。 List（列表） Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。 列表最多可以存储 2^32 - 1 个元素。 常用命令 LPUSH key value：将值插入到列表头部。 RPUSH key value：将值插入到列表尾部。 LPOP key：移出并获取列表的第一个元素。 RPOP key：移出并获取列表的最后一个元素。 LRANGE key start stop：获取列表在指定范围内的元素。 Set（集合） Redis 的 Set 是 string 类型的无序集合。 集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。 常用命令 SADD key value：向集合添加一个或多个成员。 SREM key value：移除集合中的一个或多个成员。 SMEMBERS key：返回集合中的所有成员。 SISMEMBER key value：判断值是否是集合的成员。 sadd 命令 添加一个 string 元素到 key 对应的 set 集合中，成功返回 1，如果元素已经在集合中返回 0。 1sadd key member 注意：以上实例中 rabbitmq 添加了两次，但根据集合内元素的唯一性，第二次插入的元素将被忽略。 集合中最大的成员数为 232 - 1(4294967295, 每个集合可存储40多亿个成员)。 zset(sorted set：有序集合) Redis zset 和 set 一样也是string类型元素的集合,且不允许重复的成员。 不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。 zset的成员是唯一的,但分数(score)却可以重复。 常用命令 ZADD key score value：向有序集合添加一个或多个成员，或更新已存在成员的分数。 ZRANGE key start stop [WITHSCORES]：返回指定范围内的成员。 ZREM key value：移除有序集合中的一个或多个成员。 ZSCORE key value：返回有序集合中，成员的分数值。 zadd 命令 添加元素到集合，元素在集合中存在则更新对应score 1zadd key score member 其他高级数据类似 HyperLogLog 用于基数估计算法的数据结构。 常用于统计唯一值的近似值。 Bitmaps 位数组，可以对字符串进行位操作。 常用于实现布隆过滤器等位操作。 Geospatial Indexes 处理地理空间数据，支持地理空间索引和半径查询。 Streams 日志数据类型，支持时间序列数据。 用于消息队列和实时数据处理。 Redis 命令 Redis 命令用于在 redis 服务上执行操作。 要在 redis 服务上执行命令需要一个 redis 客户端。Redis 客户端在我们之前下载的的 redis 的安装包中。 语法 Redis 客户端的基本语法为： 1$ redis-cli 实例 以下实例讲解了如何启动 redis 客户端： 启动 redis 服务器，打开终端并输入命令 redis-cli，该命令会连接本地的 redis 服务。 12345$ redis-cliredis 127.0.0.1:6379&gt;redis 127.0.0.1:6379&gt; PINGPONG 在以上实例中连接到本地的 redis 服务并执行 PING 命令，该命令用于检测 redis 服务是否启动。 在远程服务上执行命令 如果需要在远程 redis 服务上执行命令，同样使用 redis-cli 命令。 语法 1$ redis-cli -h host -p port -a password 实例 以下实例演示了如何连接到主机为 127.0.0.1，端口为 6379 ，密码为 mypass 的 redis 服务上。 12345$redis-cli -h 127.0.0.1 -p 6379 -a &quot;mypass&quot;redis 127.0.0.1:6379&gt;redis 127.0.0.1:6379&gt; PINGPONG Redis 键(key) Redis 键命令用于管理 redis 的键。 语法 Redis 键命令的基本语法如下： 1redis 127.0.0.1:6379&gt; COMMAND KEY_NAME 实例 1234redis 127.0.0.1:6379&gt; SET mykey redisOKredis 127.0.0.1:6379&gt; DEL mykey(integer) 1 在以上实例中DEL 是一个命令， mykey 是一个键。 如果键被删除成功，命令执行后输出 (integer) 1，否则将输出 (integer) 0 Redis keys 命令 下表给出了与 Redis 键相关的基本命令： 命令 描述 DEL key 用于在 key 存在时删除 key。 DUMP key 序列化给定 key ，并返回被序列化的值。 EXISTS key 检查给定 key 是否存在。 EXPIRE key seconds 为给定 key 设置过期时间，以秒计。 EXPIREAT key timestamp EXPIREAT 作用和 EXPIRE 类似，都用于为 key 设置过期时间。 不同在于 EXPIREAT 命令接受的时间参数是 UNIX 时间戳(unix timestamp)。 PEXPIRE key milliseconds 设置 key 的过期时间以毫秒计。 PEXPIREAT key milliseconds-timestamp 设置 key 过期时间的时间戳(unix timestamp) 以毫秒计 KEYS pattern 查找所有符合给定模式(pattern)的 key 。 MOVE key db 将当前数据库的 key 移动到给定的数据库 db 当中。 PERSIST key 移除 key 的过期时间，key 将持久保持。 PTTL key 以毫秒为单位返回 key 的剩余的过期时间。 TTL key 以秒为单位，返回给定 key 的剩余生存时间(TTL, time to live)。 RANDOMKEY 从当前数据库中随机返回一个 key 。 RENAME key newkey 修改 key 的名称 RENAMENX key newkey 仅当 newkey 不存在时，将 key 改名为 newkey 。 SCAN cursor [MATCH pattern] [COUNT count]] 迭代数据库中的数据库键。 TYPE key 返回 key 所储存的值的类型。","link":"/%E6%95%B0%E6%8D%AE%E5%BA%93/redis/"},{"title":"深度学习","text":"AI/ML/DL的基本概念 人工智能（Artificial Intelligence）—— 是指是设计和构建智能代理，从环境中感知并采取行动，最大限度地提高实现目标的机会。但目前的科研工作都集中在弱人工智能这部分，强人工智能还遥遥无期。 机器学习（Machine Learning）—— 使用算法来解析数据、从中学习，然后对真实世界中的事件做出决策和预测。与传统的为解决特定任务、硬编码的软件程序不同，机器学习是用大量的数据来“训练”，通过各种算法从数据中学习如何完成任务。 深度学习（Deep Leaning）—— 最初的深度学习是利用深度神经网络来解决特征表达的一种学习过程。但由于近几年该领域发展迅猛，一些特有的学习手段相继被提出（如残差网络），因此越来越多的人将其单独看作一种学习的方法。 三者的关系如下图所示，三者之间是包含和被包含的关系。 感知机——神经网络的雏形 感知机(Perceptron) 是神经网络的起源算法，由两层神经元组成，如下图所示， 输入层接收外界输入信号后传递给输出层 输出层是M-P神经元 感知机（Perceptron）是一种简单的二分类线性分类模型，由Frank Rosenblatt在1957年提出。它是神经网络和支持向量机的基础模型之一。感知机通过学习输入数据的特征，找到一个超平面将数据分为两类。 基本结构 感知机的基本结构包括： 输入层：接收输入特征向量 x=(x1,x2,…,xn)x=(x1,x2,…,xn)x=(x1,x2,…,xn)。 权重：每个输入特征对应一个权重 w=(w1,w2,…,wn)w=(w1,w2,…,wn)w=(w1,w2,…,wn)。 偏置：一个额外的参数 bbb，用于调整模型的输出。 激活函数：通常使用阶跃函数（Step Function）作为激活函数，输出二分类结果。 数学模型 感知机的输出 yyy 可以表示为： y=f(∑i=1nwixi+b)y = f\\left( \\sum_{i=1}^{n} w_i x_i + b \\right) y=f(i=1∑n​wi​xi​+b) 其中，fff 是激活函数。对于二分类问题，激活函数通常定义为： f(z)={1if z≥00if z&lt;0f(z) = \\begin{cases} 1 &amp; \\text{if } z \\geq 0 \\\\ 0 &amp; \\text{if } z &lt; 0 \\end{cases} f(z)={10​if z≥0if z&lt;0​ 学习过程 感知机的学习过程通过迭代更新权重和偏置来实现，目标是使分类错误最小化。具体步骤如下： 初始化：随机初始化权重 www 和偏置 bbb。 计算输出：对于每个训练样本 (x,d)(x,d)(x,d)，计算感知机的输出 yyy。 更新权重：如果输出 yyy 与真实标签 ddd不一致，则更新权重和偏置： wi←wi+η(d−y)xib←b+η(d−y)w_i \\leftarrow w_i + \\eta (d - y) x_i b \\leftarrow b + \\eta (d - y) wi​←wi​+η(d−y)xi​b←b+η(d−y) 其中，ηηη 是学习率，控制更新的步长。 重复：重复上述步骤，直到所有训练样本被正确分类或达到最大迭代次数。 优缺点 优点： 简单易懂，易于实现。 在线学习，可以逐步更新模型。 缺点： 只能处理线性可分的数据。 对于非线性问题，无法有效分类。 扩展 感知机是单层神经网络的基础。多层感知机（MLP）通过引入隐藏层和非线性激活函数，可以解决非线性分类问题，并成为深度学习的重要组成部分。 神经网络 神经网络（Neural Networks）是一类受到生物神经系统启发的机器学习模型，用于模拟人类或动物的大脑神经元之间的连接和信息处理方式。它是深度学习的核心结构之一，广泛应用于图像识别、自然语言处理、推荐系统等领域。 神经网络的基本组成 神经元（Neurons）：神经网络的基本单元，模拟生物神经元的功能。每个神经元接收输入信号，通过激活函数处理后，输出结果。 细胞体是神经元的主体，它包括细胞核、细胞质和细胞膜三部分 树突主要接受来自其他神经元的信号，是接受器 轴突用来输出细胞体产生的电脉冲信号，是发射器 轴突的末端形成许多分支，称作神经末梢，每条神经末梢与其他神经元通过突触相连并传递信号 髓鞘是包裹在神经细胞轴突外面的一层膜 神经元的工作过程 ：其他神经元的信号（输入信号）通过树突传递到细胞体（也就是神经元本体）中，细胞体把从其他多个神经元传递进来的输入信号进行合并加工，然后再通过轴突前端的突触传递给别的神经元。神经元就是这样借助突触结合而形成网络的。 如果输入信号之和超过神经元固有的边界值（阈值），细胞体就会做出反应，向与轴突连接的其他神经元传递信号，这称为点火。 点火时神经元输出的信号大小是固定的。即便从邻近的神经元接收到很大的刺激，或者轴突连接着多个神经元，这个神经元也只输出固定大小的信号。点火的输出信号是由&quot;0&quot; 或 &quot;1&quot;表示的数字信息： 无输出信号，y=0 有输出信号，y=1 1943年， [McCulloch and Pitts, 1943] 将神经元的工作过程抽象为上图所示的简单模型，这就是一直沿用至今的 &quot;M-P神经元模型&quot; 。 在这个模型中，神经元接收到来自 mmm 个其他神经元传递过来的输入信号，这些输入信号通过带权重（weights）的连接进行传递，神经元接收到的总输入值将与神经元的阈值进行比较，然后通过&quot;激活函数&quot; (activation function) 处理以产生神经元的输出。神经元在信号之和超过阈值时点火，不超过阈值时不点火。 所以点火的函数可以表示为：y=φ(ω1x1+ω2x2+ω3x3+...+ωmxm−b)y=\\varphi(\\omega_1x_1+\\omega_2x_2+\\omega_3x_3+...+\\omega_mx_m-b)y=φ(ω1​x1​+ω2​x2​+ω3​x3​+...+ωm​xm​−b) 其中，φ(z)\\varphi(z)φ(z)称为激活函数。理想中的激活函数是下图所示的阶跃函数，它将输入值映射为输出值 &quot;0&quot; 或 &quot;1&quot; ，显然， &quot;1&quot; 对应于神经元兴奋（点火成功） &quot;0&quot; 对应于神经元抑制（点火不成功） 然而，阶跃函数具有不连续、不光滑等不太好的性质，因此实际常用Sigmoid函数作为激活函数。 层（Layers）： 神经网络由多层神经元组成，每一层的神经元通过权重和偏置连接，并通过激活函数引入非线性。通常包括： 输入层（Input Layer）：接收输入数据。 隐藏层（Hidden Layers）：位于输入层和输出层之间，通过非线性变换提取特征。负责数据的特征抽象和转换。神经网络的深度（深度学习）指的就是隐藏层的数量。 输出层（Output Layer）：生成最终的输出结果。 权重（Weights）和偏置（Biases）：神经元之间的连接通过权重来调整输入信号的强度，偏置项则用于调整输出的基准。 激活函数（Activation Function）：决定神经元是否激活的函数。常见的激活函数有： Sigmoid：将输出限制在0到1之间，适用于二分类问题。 ReLU (Rectified Linear Unit)：输出为输入的正部分，负部分为0，适用于隐藏层。 Softmax：常用于多分类问题，输出一个概率分布。 神经网络的工作原理 前向传播（Forward Propagation）： 前向传播是指输入数据通过神经网络的每一层，通过权重和偏置加权求和，再通过激活函数处理，最终得到输出的过程。 对于第 lll 层的输出 a(l)a^{(l)}a(l)，计算公式为： z(l)=W(l)a(l−1)+b(l)a(l)=f(z(l)) z^{(l)} = W^{(l)} a^{(l-1)} + b^{(l)} a^{(l)} = f(z^{(l)}) z(l)=W(l)a(l−1)+b(l)a(l)=f(z(l)) 其中： W(l)W^{(l)}W(l) 是第 lll 层的权重矩阵。 b(l)b^{(l)}b(l) 是第 lll 层的偏置向量。 fff 是激活函数（如 ReLU、Sigmoid、Tanh 等）。 a(l−1)a^{(l-1)}a(l−1) 是第 l−1l-1l−1层的输出（即第 lll 层的输入）。 最终输出 y^\\hat{y}y^​ 是输出层的激活值 a(L)a^{(L)}a(L)，其中 LLL 是神经网络的层数。 损失函数（Loss Function）： 损失函数用于衡量模型预测值 y^\\hat{y}y^​与真实值yyy 之间的差距。常见的损失函数包括： 均方误差（MSE）（用于回归问题）： L=1N∑i=1N(yi−y^i)2L = \\frac{1}{N} \\sum_{i=1}^{N} (y_i - \\hat{y}_i)^2 L=N1​i=1∑N​(yi​−y^​i​)2 交叉熵损失（Cross-Entropy Loss）（用于分类问题）： L=−1N∑i=1N[yilog⁡(y^i)+(1−yi)log⁡(1−y^i)]L = -\\frac{1}{N} \\sum_{i=1}^{N} \\left[ y_i \\log(\\hat{y}_i) + (1 - y_i) \\log(1 - \\hat{y}_i) \\right] L=−N1​i=1∑N​[yi​log(y^​i​)+(1−yi​)log(1−y^​i​)] 反向传播（Backpropagation） 神经网络通过反向传播算法来优化参数（权重和偏置）。反向传播通过梯度下降等优化方法来减少损失函数值，逐步调整网络中的参数。 反向传播是通过链式法则计算损失函数对每个参数的梯度，从而更新权重和偏置的过程。 梯度计算 对于第lll层的权重 W(l)W^{(l)}W(l)和偏置b(l)b^{(l)}b(l)，梯度计算如下： 计算输出层的误差 δ(L){\\delta^{(L)}}δ(L)： δ(L)=∂L∂a(L)⋅f′(z(L))\\delta^{(L)} = \\frac{\\partial L}{\\partial a^{(L)}} \\cdot f'(z^{(L)}) δ(L)=∂a(L)∂L​⋅f′(z(L)) 计算第lll 层的误差 δ(l)\\delta^{(l)}δ(l)： δ(l)=((W(l+1))Tδ(l+1))⋅f′(z(l))\\delta^{(l)} = \\left( (W^{(l+1)})^T \\delta^{(l+1)} \\right) \\cdot f'(z^{(l)}) δ(l)=((W(l+1))Tδ(l+1))⋅f′(z(l)) 计算权重和偏置的梯度： ∂L∂W(l)=δ(l)(a(l−1))T∂L∂b(l)=δ(l)\\frac{\\partial L}{\\partial W^{(l)}} = \\delta^{(l)} (a^{(l-1)})^T \\frac{\\partial L}{\\partial b^{(l)}} = \\delta^{(l)} ∂W(l)∂L​=δ(l)(a(l−1))T∂b(l)∂L​=δ(l) 参数更新 使用梯度下降法更新参数： W(l)←W(l)−η∂L∂W(l)b(l)←b(l)−η∂L∂b(l)W^{(l)} \\leftarrow W^{(l)} - \\eta \\frac{\\partial L}{\\partial W^{(l)}} b^{(l)} \\leftarrow b^{(l)} - \\eta \\frac{\\partial L}{\\partial b^{(l)}} W(l)←W(l)−η∂W(l)∂L​b(l)←b(l)−η∂b(l)∂L​ 其中，η\\etaη 是学习率。 训练过程 神经网络的训练过程通常包括以下步骤： 初始化参数：随机初始化权重和偏置。 前向传播：计算网络的输出。 计算损失：通过损失函数衡量预测值与真实值的差距。 反向传播：计算梯度并更新参数。 重复迭代：重复上述步骤，直到损失函数收敛或达到最大迭代次数。 输出层设计 神经网络输出层的设计是神经网络架构中的关键部分，它直接影响模型的预测能力和适用场景。输出层的设计需要根据具体任务（如分类、回归、生成等）来确定。以下是输出层设计的详细说明，包括数学公式和代码示例。 1. 输出层的作用 输出层的主要作用是将隐藏层的输出映射到最终的预测结果。具体设计取决于任务类型： 分类任务：输出类别概率或类别标签。 回归任务：输出连续值。 生成任务：输出生成的数据（如图像、文本等）。 2. 输出层的常见设计 2.1 分类任务 二分类任务 输出层神经元数量：1 个神经元。 激活函数：Sigmoid 函数，将输出映射到 [0, 1] 区间，表示概率。 σ(z)=11+e−z\\sigma(z) = \\frac{1}{1 + e^{-z}} σ(z)=1+e−z1​ 损失函数：二元交叉熵损失（Binary Cross-Entropy Loss）。 L=−1N∑i=1N[yilog⁡(y^i)+(1−yi)log⁡(1−y^i)]L = -\\frac{1}{N} \\sum_{i=1}^{N} \\left[ y_i \\log(\\hat{y}_i) + (1 - y_i) \\log(1 - \\hat{y}_i) \\right] L=−N1​i=1∑N​[yi​log(y^​i​)+(1−yi​)log(1−y^​i​)] 多分类任务 输出层神经元数量：等于类别数量 ( C )。 激活函数：Softmax 函数，将输出映射为概率分布。 Softmax(zi)=ezi∑j=1Cezj\\text{Softmax}(z_i) = \\frac{e^{z_i}}{\\sum_{j=1}^{C} e^{z_j}} Softmax(zi​)=∑j=1C​ezj​ezi​​ 损失函数：交叉熵损失（Cross-Entropy Loss）。 L=−1N∑i=1N∑j=1Cyijlog⁡(y^ij)L = -\\frac{1}{N} \\sum_{i=1}^{N} \\sum_{j=1}^{C} y_{ij} \\log(\\hat{y}_{ij}) L=−N1​i=1∑N​j=1∑C​yij​log(y^​ij​) 2.2 回归任务 输出层神经元数量：等于输出值的维度（通常为 1）。 激活函数：无激活函数（线性输出），或使用 ReLU 等非线性函数（如果输出为非负值）。 损失函数：均方误差（Mean Squared Error, MSE）。 L=1N∑i=1N(yi−y^i)2L = \\frac{1}{N} \\sum_{i=1}^{N} (y_i - \\hat{y}_i)^2 L=N1​i=1∑N​(yi​−y^​i​)2 2.3 生成任务 输出层神经元数量：取决于生成数据的维度。例如： 生成图像：输出像素值，神经元数量等于图像宽度 × 高度 × 通道数。 生成文本：输出词汇表中每个词的概率，神经元数量等于词汇表大小。 激活函数： 生成图像：通常使用 Tanh（输出范围 [-1, 1]）或 Sigmoid（输出范围 [0, 1]）。 生成文本：通常使用 Softmax。 损失函数： 生成图像：均方误差（MSE）或对抗损失（如 GAN 中的判别器损失）。 生成文本：交叉熵损失。 3. 输出层设计的注意事项 任务类型：根据任务类型（分类、回归、生成）选择合适的输出层结构和激活函数。 输出范围：确保输出层的激活函数能够满足任务的需求（如概率值在 [0, 1] 区间）。 损失函数：选择与任务匹配的损失函数，确保模型能够正确优化。 多任务学习：如果模型需要同时完成多个任务（如分类和回归），可以为每个任务设计独立的输出层。 4. 总结 分类任务：使用 Sigmoid（二分类）或 Softmax（多分类）作为激活函数，配合交叉熵损失。 回归任务：使用线性输出（无激活函数），配合均方误差损失。 生成任务：根据生成数据的类型选择合适的激活函数和损失函数。 通过合理设计输出层，可以使神经网络更好地适应不同的任务需求。 神经网络的分类 前馈神经网络（Feedforward Neural Networks, FNN）：最基本的神经网络结构，信息从输入层传递到输出层，中间没有循环。 卷积神经网络（Convolutional Neural Networks, CNN）：主要用于处理图像数据，通过卷积层提取局部特征，广泛应用于计算机视觉领域。 循环神经网络（Recurrent Neural Networks, RNN）：适用于处理时间序列数据（如语音、文本）。它通过循环连接保持记忆，能够处理序列信息。 生成对抗网络（Generative Adversarial Networks, GAN）：由生成器和判别器两部分组成，通过对抗训练生成逼真的样本，广泛用于图像生成、数据增强等任务。 神经网络的优势 自适应学习：神经网络能够从数据中自动学习特征，不需要手动提取特征。 强大的表达能力：特别是深度神经网络（深度学习）具有强大的拟合能力，能处理复杂的非线性关系。 通用性：神经网络能够应用于多种任务，如图像分类、语音识别、自然语言处理等。 神经网络的挑战 训练时间长：深度神经网络需要大量的数据和计算资源进行训练，训练时间可能非常长。 过拟合：如果模型过于复杂，可能会在训练数据上表现得很好，但在未见过的测试数据上表现差。通常需要通过正则化、早停等技术来避免。 解释性差：神经网络通常被认为是“黑箱”模型，难以解释它们做出决策的具体原因。 优化算法 为了提高训练效率和效果，通常会使用一些优化算法： 随机梯度下降（SGD）：每次更新使用一个样本或一个小批量样本。 动量法（Momentum）：引入动量项加速收敛。 Adam：结合动量和自适应学习率的优化算法。 总结 神经网络通过模仿人类大脑神经元之间的连接方式，能够学习和抽象复杂的模式和关系，广泛应用于各种领域。随着计算力的提升和大数据的可获得，神经网络（尤其是深度学习）在多个领域取得了显著的成功。 监督学习一般方法 深度学习一般方法","link":"/AI/deep-learning/"},{"title":"听歌吗","text":"出处或许是错的，仅为个人所听版本 中文歌 同花顺 《致：黯淡星》——傲七爷&amp;哦漏 《爱人》——莉莉周她说 《如是我闻》——Winky诗 《第三十八年夏至》——河图 《琴师》—— 《知我》——哦漏 《时间长河》——苏玮 《千年》——吉克隽逸&amp; 《一样的月光》——徐佳莹 英文歌 《time machine》——mj apanay&amp;aren park 《Scarborough Fair》——Sarah Brightman 纯音乐 《我将在何处游荡》—— AniFace 《当原野的风拥抱我》 ——知晏 《counter attack》——老伙计 《鸟之诗（长笛）》——老伙计 《诀别书》——邓垚 《Eutopia/乌托邦》——Yooh 《Calls of Silence/静谧的呼吸》——Haru 《Merry Christmas Mr.Lawrence》——坂本龍一 《Letter》——iris 《复刻回忆》——Pianoboy高至豪 江畔何人初见月，江月何年初照人？ 《Flower Dance》——DJ Okawari 《Felicity》——Isaac Shepard 《Refrain》——阿南亮子 《fish in the pool》 《夏 烟火》——LIKPIA","link":"/%E5%A4%A9%E9%A9%AC%E8%A1%8C%E7%A9%BA/songs/"},{"title":"哈希表","text":"基础操作 put(K key, V value)：将指定的键值对插入到 HashMap 中，若键已存在，则更新值。 get(Object key)：根据键获取值，如果不存在该键，返回 null。 remove(Object key)：根据键删除键值对。 containsKey(Object key)：检查是否包含指定的键。 containsValue(Object value)：检查是否包含指定的值。 size()：返回 HashMap 中键值对的数量。 isEmpty()：检查 HashMap 是否为空。 keySet()：返回所有键的集合。 values()：返回所有值的集合。 entrySet()：返回 HashMap 中所有键值对的 Set 集合。 clear()：清空所有元素。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import java.util.HashMap;import java.util.Map;public class HashMapExample { public static void main(String[] args) { // 创建 HashMap 实例 HashMap&lt;String, Integer&gt; map = new HashMap&lt;&gt;(); // 1. put() - 添加或更新元素 map.put(&quot;apple&quot;, 1); // key = &quot;apple&quot;, value = 1 map.put(&quot;banana&quot;, 2); // key = &quot;banana&quot;, value = 2 map.put(&quot;orange&quot;, 3); // key = &quot;orange&quot;, value = 3 // 2. get() - 获取元素 System.out.println(&quot;Value for key 'apple': &quot; + map.get(&quot;apple&quot;)); // 输出 1 // 3. containsKey() - 检查是否包含某个键 System.out.println(&quot;Contains key 'banana': &quot; + map.containsKey(&quot;banana&quot;)); // 输出 true // 4. containsValue() - 检查是否包含某个值 System.out.println(&quot;Contains value 2: &quot; + map.containsValue(2)); // 输出 true // 5. remove() - 删除某个键值对 map.remove(&quot;banana&quot;); System.out.println(&quot;After removing 'banana': &quot; + map); // 6. size() - 获取大小 System.out.println(&quot;Size of map: &quot; + map.size()); // 输出 2 // 7. isEmpty() - 检查是否为空 System.out.println(&quot;Is map empty? &quot; + map.isEmpty()); // 输出 false // 8. keySet() - 获取所有的键 System.out.println(&quot;All keys: &quot; + map.keySet()); // 输出 [apple, orange] // 9. values() - 获取所有的值 System.out.println(&quot;All values: &quot; + map.values()); // 输出 [1, 3] // 10. entrySet() - 获取所有的键值对 for (Map.Entry&lt;String, Integer&gt; entry : map.entrySet()) { System.out.println(entry.getKey() + &quot;: &quot; + entry.getValue()); } // 11. clear() - 清空所有元素 map.clear(); System.out.println(&quot;After clearing map: &quot; + map); // 输出 {} }} 1. 两数之和 12345678910111213class Solution { public int[] twoSum(int[] nums, int target) { HashMap&lt;Integer, Integer&gt; mp = new HashMap&lt;&gt;(); for (int i = 0; i &lt; nums.length; i++){ int temp = target - nums[i]; if (mp.containsKey(temp)){ return new int[]{mp.get(temp), i}; } mp.put(nums[i], i); } return new int[0]; }} 49. 字母异位词分组 128. 最长连续序列 1234567891011121314151617181920212223class Solution { public int longestConsecutive(int[] nums) { Set&lt;Integer&gt; num_set = new HashSet&lt;Integer&gt;(); for (int num : nums){ num_set.add(num); } int ans = 0; for (int num : num_set){ if (!num_set.contains(num - 1)){ int cur = num; int temp = 1; while (num_set.contains(cur + 1)){ cur++; temp++; } ans = Math.max(ans, temp); } } return ans; }}","link":"/%E5%8A%9B%E6%89%A3/%E5%8A%9B%E6%89%A3%E7%83%AD%E9%97%A8100/LChot100-hashmap/"},{"title":"LRU与LFU缓存","text":"LRU与LFU缓存替换策略 LRU（Least Recently Used，最少最近使用）和 LFU（Least Frequently Used，最不经常使用）是两种常用的缓存替换策略，用于决定缓存中哪些项应该被淘汰。它们的实现和应用场景非常广泛，特别是在内存管理、数据库缓存和操作系统中。 LRU (Least Recently Used) 最少最近使用 LRU 策略用于在缓存满了时，淘汰最久没有使用的数据。即：每当一个缓存项被访问时，它就被认为是“最近使用”的，最少使用的缓存项就会被替换。 题目描述:设计并实现一个满足LRU最近最少使用缓存约束的数据结构。 实现LRUCache类： LRUCache (int capacity)以 正整数 作为容量 capacity 初始化 LRU 缓存 int get(int key) 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。 void put(int key, int value)如果关键字 key 已经存在，则变更其数据值 value ；如果不存在，则向缓存中插入该组 key-value 。如果插入操作导致关键字数量超过 capacity ，则应该 逐出 最久未使用的关键字。 函数get和put必须以O(1)的平均时间复杂度运行。} 思路： 每次访问缓存时，将该缓存项标记为“最近使用”。 当缓存满时，淘汰最久未被访问的缓存项。 实现方法： LRU 可以通过 双向链表 和 哈希表 来实现： 哈希表 用于快速访问缓存项。 双向链表 用于维护缓存项的使用顺序，最近访问的项放在链表头，最久未访问的项放在链表尾。 LRU 实现步骤： 哈希表：存储缓存的键值对，键是缓存的键，值是缓存项（值和最近使用的顺序）。 双向链表：存储缓存项的顺序，最近访问的缓存项放在头部，最久未访问的放在尾部。 插入和删除：每次访问缓存项时，将该项移动到链表头；如果缓存满了，移除链表尾部的项。 12345678910111213141516171819202122232425262728293031323334353637383940import java.util.*;class LRUCache { private int capacity; private Map&lt;Integer, Integer&gt; cache; private LinkedHashMap&lt;Integer, Long&gt; accessOrder; public LRUCache(int capacity) { this.capacity = capacity; this.cache = new HashMap&lt;&gt;(); this.accessOrder = new LinkedHashMap&lt;&gt;(capacity, 0.75f, true); // true 表示访问顺序 } public int get(int key) { if (!cache.containsKey(key)) { return -1; } // 更新访问顺序 accessOrder.put(key, System.nanoTime()); return cache.get(key); } public void put(int key, int value) { if (cache.size() &gt;= capacity) { // 找到最少使用的键 long leastUsedTime = Long.MAX_VALUE; int keyToRemove = -1; for (Map.Entry&lt;Integer, Long&gt; entry : accessOrder.entrySet()) { if (entry.getValue() &lt; leastUsedTime) { leastUsedTime = entry.getValue(); keyToRemove = entry.getKey(); } } // 移除最少使用的项 cache.remove(keyToRemove); accessOrder.remove(keyToRemove); } cache.put(key, value); accessOrder.put(key, System.nanoTime()); }}} 但这么写 过不了力扣...... 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273class LRUCache { // Node 类表示链表中的每个节点 private static class Node { int key, value; // 存储 key 和 value Node prev, next; // 前后指针，用于双向链表 Node(int k, int v) { // 构造函数初始化 key 和 value key = k; value = v; } } private final int capacity; // 缓存的最大容量 private final Node dummy = new Node(0, 0); // 哑节点，用于简化双向链表操作（头节点） private final Map&lt;Integer, Node&gt; keyToNode = new HashMap&lt;&gt;(); // 用于存储缓存中每个 key 对应的节点 // 构造函数初始化容量，并且初始化双向链表的 dummy 节点 public LRUCache(int capacity) { this.capacity = capacity; dummy.prev = dummy; // 哑节点的 prev 指向自己 dummy.next = dummy; // 哑节点的 next 指向自己 } // 获取缓存中某个 key 对应的 value public int get(int key) { Node node = getNode(key); // 查找 key 对应的节点 return node != null ? node.value : -1; // 如果找到节点，返回节点的值，否则返回 -1（表示不存在） } // 向缓存中插入新的 key-value 对 public void put(int key, int value) { Node node = getNode(key); // 查找 key 对应的节点 if (node != null) { // 如果节点存在，更新节点的值 node.value = value; return; // 直接返回，无需做其他操作 } // 如果节点不存在，创建一个新的节点并插入到缓存中 node = new Node(key, value); keyToNode.put(key, node); // 将新节点存入哈希表 pushFront(node); // 将新节点移动到链表的头部，表示最近使用 // 如果缓存的大小超过了容量，移除最不常用的节点（尾部节点） if (keyToNode.size() &gt; capacity) { Node backNode = dummy.prev; // 获取尾部节点（最久未使用的节点） keyToNode.remove(backNode.key); // 从哈希表中移除该节点 remove(backNode); // 从链表中移除该节点 } } // 根据 key 获取对应的节点 private Node getNode(int key) { if (!keyToNode.containsKey(key)) return null; // 如果 key 不存在，返回 null Node node = keyToNode.get(key); // 获取节点 remove(node); // 从链表中移除该节点 pushFront(node); // 将该节点移到链表头部，表示它是最新使用的 return node; // 返回节点 } // 从链表中移除指定的节点 private void remove(Node x) { x.prev.next = x.next; // 将前一个节点的 next 指向当前节点的下一个节点 x.next.prev = x.prev; // 将下一个节点的 prev 指向当前节点的前一个节点 } // 将指定的节点插入到链表头部 private void pushFront(Node x) { x.prev = dummy; // 新节点的 prev 指向哑节点 x.next = dummy.next; // 新节点的 next 指向哑节点的下一个节点 x.prev.next = x; // 哑节点的 next 指向新节点 x.next.prev = x; // 新节点的 next 节点的 prev 指向新节点 }}} LFU (Least Frequently Used) 最不经常使用 LFU 策略用于淘汰访问频率最低的缓存项。即：每次访问缓存时，缓存项的访问次数增加。缓存满时，淘汰访问次数最少的缓存项。 思路： 每个缓存项都有一个访问频率：当访问缓存时，增加该项的频率。 淘汰策略：当缓存满时，淘汰频率最低的缓存项。若频率相同，则淘汰最早添加的缓存项。 实现方法： LFU 通常使用 哈希表 和 最小堆（或 哈希表+双向链表）来实现。 哈希表 用于存储缓存的键值对。 频率表：哈希表将缓存项的访问次数作为键，缓存项列表作为值（即频率与缓存项的映射关系）。 最小堆：或者使用优先队列来管理访问频率，以便快速找到访问次数最少的缓存项。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364import java.util.*;class LFUCache { private int capacity; private Map&lt;Integer, Integer&gt; values; private Map&lt;Integer, Integer&gt; frequencies; private Map&lt;Integer, LinkedHashSet&lt;Integer&gt;&gt; freqList; private int minFreq; public LFUCache(int capacity) { this.capacity = capacity; this.values = new HashMap&lt;&gt;(); this.frequencies = new HashMap&lt;&gt;(); this.freqList = new HashMap&lt;&gt;(); this.minFreq = -1; } public int get(int key) { if (!values.containsKey(key)) { return -1; } int freq = frequencies.get(key); frequencies.put(key, freq + 1); freqList.get(freq).remove(key); if (freqList.get(freq).isEmpty()) { if (minFreq == freq) { minFreq++; } freqList.remove(freq); } freqList.putIfAbsent(freq + 1, new LinkedHashSet&lt;&gt;()); freqList.get(freq + 1).add(key); return values.get(key); } public void put(int key, int value) { if (capacity &lt;= 0) return; if (values.containsKey(key)) { values.put(key, value); get(key); // 更新频率 return; } if (values.size() &gt;= capacity) { // 淘汰最少频次的缓存项 int evictKey = freqList.get(minFreq).iterator().next(); freqList.get(minFreq).remove(evictKey); if (freqList.get(minFreq).isEmpty()) { freqList.remove(minFreq); } values.remove(evictKey); frequencies.remove(evictKey); } values.put(key, value); frequencies.put(key, 1); minFreq = 1; freqList.putIfAbsent(1, new LinkedHashSet&lt;&gt;()); freqList.get(1).add(key); }}} 主要思路： 频率管理：用一个哈希表 freqToDummy 存储每个访问频率对应的链表，链表的头部代表最近访问的节点，尾部代表最久未访问的节点。 双向链表：为每个访问频率维护一个双向链表，这样可以高效地管理节点的顺序，并能在常数时间内删除最不常使用的节点。 最小频率：minFreq 变量用于记录当前缓存中的最小访问频率。每当访问一个节点时，如果该节点的访问频率变化，并且该频率链表变为空，我们需要更新 minFreq。 核心操作： get 操作：查找并返回缓存中 key 对应的值，同时将该节点的访问频率加 1，并将其移动到新的频率链表中。 put 操作：如果缓存已满，先移除访问频率最少的节点。然后将新节点插入到频率为 1 的链表中，并设置 minFreq 为 1。 节点的移动：每次访问或插入时，节点会根据其访问频率被移动到对应的链表头部，从而保证频率最低的节点最先被淘汰。 性能分析： 时间复杂度：每个操作（get、put、remove、pushFront）都可以在 O(1) 时间内完成，因为链表操作和哈希表操作的时间复杂度是 O(1)。 空间复杂度：空间复杂度是 O(capacity)，因为我们只在缓存中存储最多 capacity 个节点。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899class LFUCache { // Node 类表示链表中的每个节点 private static class Node { int key, value, freq = 1; // key 是键，value 是值，freq 是访问频率，初始化为 1 Node prev, next; // prev 和 next 是双向链表的指针 Node(int key, int value) { // 构造函数初始化 key 和 value this.key = key; this.value = value; } } private final int capacity; // 缓存的最大容量 private final Map&lt;Integer, Node&gt; keyToNode = new HashMap&lt;&gt;(); // 存储缓存的 key -&gt; Node 映射 private final Map&lt;Integer, Node&gt; freqToDummy = new HashMap&lt;&gt;(); // 存储频率 -&gt; 哑节点（代表链表头） private int minFreq; // 记录当前缓存中的最小访问频率 // 构造函数初始化缓存容量 public LFUCache(int capacity) { this.capacity = capacity; } // 获取缓存中指定 key 对应的值 public int get(int key) { Node node = getNode(key); // 获取节点 return node != null ? node.value : -1; // 如果节点存在，返回其值，否则返回 -1 } // 向缓存中插入新的 key-value 对 public void put(int key, int value) { Node node = getNode(key); // 尝试从缓存中获取该节点 if (node != null) { // 如果节点已经存在，更新其值 node.value = value; return; } // 如果缓存已满，则删除访问频率最少的元素 if (keyToNode.size() == capacity) { Node dummy = freqToDummy.get(minFreq); // 获取最小频率的链表 Node backNode = dummy.prev; // 获取该链表中的最旧节点 keyToNode.remove(backNode.key); // 从哈希表中移除该节点 remove(backNode); // 从链表中移除该节点 if (dummy.prev == dummy) { // 如果该链表为空 freqToDummy.remove(minFreq); // 移除该频率的链表 } } // 创建新节点并放入缓存 node = new Node(key, value); keyToNode.put(key, node); // 添加到 keyToNode 哈希表 pushFront(1, node); // 将新节点放入频率为 1 的链表中（即最上面） minFreq = 1; // 更新最小频率为 1 } // 获取指定 key 对应的节点，并将其访问频率加 1 private Node getNode(int key) { if (!keyToNode.containsKey(key)) { // 如果没有该 key return null; } Node node = keyToNode.get(key); // 获取节点 remove(node); // 从链表中移除该节点 Node dummy = freqToDummy.get(node.freq); // 获取当前频率对应的链表 if (dummy.prev == dummy) { // 如果当前频率的链表为空 freqToDummy.remove(node.freq); // 移除该频率的链表 if (minFreq == node.freq) { // 如果当前频率是最小频率 minFreq++; // 增加最小频率 } } // 增加访问频率，并将节点放入新的频率链表的最上面 pushFront(++node.freq, node); return node; // 返回节点 } // 创建一个新的双向链表（每个频率的链表） private Node newList() { Node dummy = new Node(0, 0); // 哑节点作为双向链表的头节点 dummy.prev = dummy; dummy.next = dummy; return dummy; } // 将节点添加到指定频率的链表头部（表示该节点最近被访问） private void pushFront(int freq, Node x) { Node dummy = freqToDummy.computeIfAbsent(freq, k -&gt; newList()); // 获取该频率对应的链表头（如果不存在则创建） x.prev = dummy; // 将节点的 prev 指向该频率链表的头 x.next = dummy.next; // 将节点的 next 指向该频率链表的第一个节点 x.prev.next = x; // 连接节点到链表头 x.next.prev = x; // 连接节点到链表的下一个节点 } // 从链表中删除一个节点 private void remove(Node x) { x.prev.next = x.next; // 删除节点的前后节点的连接 x.next.prev = x.prev; // 删除节点的前后节点的连接 }}}","link":"/%E7%AE%97%E6%B3%95/LRU&LFU/"},{"title":"操作系统","text":"","link":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/operating-system/"},{"title":"数据结构","text":"第一章：绪论 第二章：线性表 第三章：栈和队列 第四章：串 第五章：树与二叉树 第六章：图 第七章：查找 第八章：排序","link":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/data-structure/"},{"title":"计算机组成原理","text":"","link":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/principle-of-computer-organization/"},{"title":"前端","text":"基础知识 HTML HTML 简介 HTML（HyperText Markup Language，超文本标记语言）是用于创建网页的标准标记语言。它是构建网页内容的基础，定义了网页的结构和内容。HTML 通过标签（Tags）来描述网页中的文本、图片、链接、表格等元素。 HTML 的核心概念 标签（Tags）： HTML 使用标签来定义网页中的元素。 标签通常成对出现，例如 &lt;p&gt; 和 &lt;/p&gt;。 有些标签是自闭合的，例如 &lt;img&gt; 和 &lt;br&gt;。 元素（Elements）： 一个完整的 HTML 元素包括开始标签、内容和结束标签。 例如：&lt;p&gt;这是一个段落。&lt;/p&gt;。 属性（Attributes）： 属性用于为 HTML 元素提供附加信息。 属性通常位于开始标签中，以键值对的形式出现。 例如：&lt;a href=&quot;https://www.example.com&quot;&gt;链接&lt;/a&gt;。 HTML 的基本结构 一个典型的 HTML 文档结构如下： 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;网页标题&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;这是一个标题&lt;/h1&gt; &lt;p&gt;这是一个段落。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; &lt;!DOCTYPE html&gt;：声明文档类型，告诉浏览器这是一个 HTML5 文档。 &lt;html&gt;：HTML 文档的根元素。 &lt;head&gt;：包含元数据（如字符集、标题、样式表链接等），不会显示在页面上。 &lt;body&gt;：包含网页的可见内容。 常用 HTML 标签 1. 文本标签 标题： 123&lt;h1&gt;一级标题&lt;/h1&gt;&lt;h2&gt;二级标题&lt;/h2&gt;&lt;h3&gt;三级标题&lt;/h3&gt; 段落： 1&lt;p&gt;这是一个段落。&lt;/p&gt; 加粗：除&lt;strong&gt;外，还有一个标签&lt;b&gt;会使包围的文字加粗。b元素代表侧重实用目的而不带任何额外重要性也不暗示不同语态或语气的一段文本，比如一段文本摘要中的关键字、一段审查中的产品名称、文本驱动软件中的可执行语句或者一篇文章的导语。&lt;strong&gt;元素代表内容的强烈的重要性、严重性或者紧急性，可以被用在标题（heading）、说明（caption）或者段落（paragraph）上，来显示这部分被包围的文字的重要性；可以被用来标记警告或者警示标志；还可以被用来表示需要被尽快看见的部分。 1&lt;strong&gt;加粗文本&lt;/strong&gt; 斜体：&lt;em&gt;意为对内容的强调(emphasis)，强调位置的不同通常会带来整个句子含义的变化（参考重读）。此外，还有一个标签&lt;i&gt;表示斜体(italic)，但这个没有强调的语义。这里关系到HTML5最大的特性之一——语义化，所有被HTML5保留的标签都带有其特有的语义，&lt;b&gt;和&lt;i&gt;也被重新赋予了语义，相比较而言，标签的样式反而变得不那么重要。&lt;i&gt;元素代表在普通文本中具有不同语态或语气的一段文本，某种程度上表明一段不同特性的文本，比如一个分类学名称、一个技术外语、一个外语习语、一个音译、一个想法，或者西方文本中的一艘船名。 1&lt;em&gt;斜体文本&lt;/em&gt; 2. 链接和图片 链接：1&lt;a href=&quot;https://www.example.com&quot;&gt;点击这里&lt;/a&gt; 图片：1&lt;img src=&quot;image.jpg&quot; alt=&quot;图片描述&quot;&gt; 3. 列表 无序列表：1234&lt;ul&gt; &lt;li&gt;项目1&lt;/li&gt; &lt;li&gt;项目2&lt;/li&gt;&lt;/ul&gt; 有序列表：1234&lt;ol&gt; &lt;li&gt;第一项&lt;/li&gt; &lt;li&gt;第二项&lt;/li&gt;&lt;/ol&gt; 4. 表格 12345678910&lt;table&gt; &lt;tr&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;年龄&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;张三&lt;/td&gt; &lt;td&gt;25&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 5. 表单 123456789&lt;form action=&quot;/submit&quot; method=&quot;post&quot;&gt; &lt;label for=&quot;username&quot;&gt;用户名：&lt;/label&gt; &lt;input type=&quot;text&quot; id=&quot;username&quot; name=&quot;username&quot;&gt; &lt;br&gt; &lt;label for=&quot;password&quot;&gt;密码：&lt;/label&gt; &lt;input type=&quot;password&quot; id=&quot;password&quot; name=&quot;password&quot;&gt; &lt;br&gt; &lt;button type=&quot;submit&quot;&gt;提交&lt;/button&gt;&lt;/form&gt; 6. 语义化标签 &lt;header&gt;：页眉。 &lt;footer&gt;：页脚。 &lt;section&gt;：文档中的一部分。 &lt;article&gt;：独立的内容块。 &lt;nav&gt;：导航栏。 HTML5 新特性 语义化标签： 例如 &lt;header&gt;、&lt;footer&gt;、&lt;article&gt; 等，使代码更具可读性。 多媒体支持： 音频：123&lt;audio controls&gt; &lt;source src=&quot;audio.mp3&quot; type=&quot;audio/mpeg&quot;&gt;&lt;/audio&gt; 视频：123&lt;video controls width=&quot;320&quot;&gt; &lt;source src=&quot;video.mp4&quot; type=&quot;video/mp4&quot;&gt;&lt;/video&gt; 表单增强： 新增输入类型：email、date、number、range 等。 新增属性：placeholder、required、autofocus 等。 Canvas 和 SVG： Canvas：用于绘制图形。1&lt;canvas id=&quot;myCanvas&quot; width=&quot;200&quot; height=&quot;100&quot;&gt;&lt;/canvas&gt; SVG：矢量图形。123&lt;svg width=&quot;100&quot; height=&quot;100&quot;&gt; &lt;circle cx=&quot;50&quot; cy=&quot;50&quot; r=&quot;40&quot; stroke=&quot;black&quot; stroke-width=&quot;3&quot; fill=&quot;red&quot; /&gt;&lt;/svg&gt; HTML 开发工具 编辑器： Visual Studio Code（推荐）。 Sublime Text。 Atom。 浏览器开发者工具： Chrome DevTools。 Firefox Developer Tools。 在线工具： CodePen：在线编写和测试 HTML 代码。 JSFiddle：类似 CodePen 的在线编辑器。 CSS CSS 简介 CSS（Cascading Style Sheets，层叠样式表）是一种用于描述 HTML 文档外观和格式的样式表语言。它用于控制网页的布局、颜色、字体、间距等视觉效果。CSS 与 HTML 和 JavaScript 一起构成了现代网页开发的三大核心技术。 CSS 的核心概念 选择器（Selectors）： 用于选择需要样式化的 HTML 元素。 例如：p 选择所有 &lt;p&gt; 元素，.class 选择具有特定类的元素。 属性（Properties）： 用于定义元素的样式。 例如：color、font-size、margin 等。 值（Values）： 属性的具体设置。 例如：color: red; 中的 red 就是值。 规则集（Rule Set）： 由选择器和一组声明（属性和值）组成。 例如：1234p { color: red; font-size: 16px;} 层叠（Cascading）： 当多个样式规则应用于同一个元素时，CSS 会根据优先级和规则顺序决定最终的样式。 盒模型（Box Model）： 每个 HTML 元素都可以看作一个盒子，包括内容（content）、内边距（padding）、边框（border）和外边距（margin）。 CSS 的基本语法 1234选择器 { 属性1: 值1; 属性2: 值2;} 示例： 12345h1 { color: blue; font-size: 24px; text-align: center;} CSS 的引入方式 内联样式： 直接在 HTML 元素的 style 属性中定义样式。 示例：1&lt;p style=&quot;color: red; font-size: 16px;&quot;&gt;这是一个段落。&lt;/p&gt; 内部样式表： 在 HTML 文件的 &lt;head&gt; 中使用 &lt;style&gt; 标签定义样式。 示例：123456&lt;style&gt; p { color: red; font-size: 16px; }&lt;/style&gt; 外部样式表： 将 CSS 代码保存在单独的 .css 文件中，并通过 &lt;link&gt; 标签引入。 示例：1&lt;link rel=&quot;stylesheet&quot; href=&quot;styles.css&quot;&gt; 常用 CSS 属性 1. 文本样式 颜色：1color: red; 字体大小：1font-size: 16px; 字体粗细：1font-weight: bold; 文本对齐：1text-align: center; 2. 盒模型 内边距：1padding: 10px; 外边距：1margin: 20px; 边框：1border: 1px solid black; 3. 背景 背景颜色：1background-color: yellow; 背景图片：1background-image: url('image.jpg'); 4. 布局 浮动：1float: left; 定位：123position: absolute;top: 10px;left: 20px; Flexbox：123display: flex;justify-content: center;align-items: center; Grid：12display: grid;grid-template-columns: 1fr 1fr; CSS 选择器 元素选择器： 123p { color: red;} 类选择器： 123.class-name { font-size: 16px;} ID 选择器： 123#id-name { background-color: yellow;} 后代选择器： 123div p { color: blue;} 伪类选择器： 123a:hover { color: green;} CSS 进阶特性 媒体查询（Media Queries）： 用于实现响应式设计。 示例：12345@media (max-width: 600px) { body { background-color: lightblue; }} 动画（Animations）： 使用 @keyframes 创建动画。 示例：1234567@keyframes slide { from { transform: translateX(0); } to { transform: translateX(100px); }}div { animation: slide 2s infinite;} 过渡（Transitions）： 用于在状态变化时添加平滑效果。 示例：123456button { transition: background-color 0.5s ease;}button:hover { background-color: blue;} CSS 开发工具 浏览器开发者工具： Chrome DevTools：用于调试和实时修改 CSS。 Firefox Developer Tools：功能类似，适合前端开发。 CSS 预处理器： Sass：支持变量、嵌套、混合等功能。 Less：类似 Sass，语法更接近原生 CSS。 CSS 框架： Bootstrap：提供现成的组件和样式。 Tailwind CSS：实用工具优先的 CSS 框架。 JavaScript JavaScript 简介 JavaScript（简称 JS）是一种轻量级、解释型的编程语言，主要用于为网页添加交互功能。它是现代 Web 开发的三大核心技术之一（另外两个是 HTML 和 CSS）。JavaScript 不仅可以运行在浏览器中，还可以通过 Node.js 运行在服务器端。 JavaScript 的核心特点 动态类型： 变量不需要声明类型，类型在运行时确定。 例如：let x = 10; 和 x = &quot;hello&quot;; 都是合法的。 基于原型： JavaScript 使用原型链实现继承，而不是传统的类继承。 事件驱动： JavaScript 可以通过事件（如点击、鼠标移动等）触发特定的函数。 单线程： JavaScript 是单线程的，但通过异步编程（如 Promise、async/await）可以实现非阻塞操作。 跨平台： JavaScript 可以在浏览器、服务器（Node.js）、移动端（React Native）等多个平台运行。 JavaScript 的基本语法 1. 变量声明 var：传统声明方式，作用域为函数级。 let：块级作用域，推荐使用。 const：块级作用域，用于声明常量。 12let name = &quot;Alice&quot;;const age = 25; 2. 数据类型 基本类型： 字符串（String）：&quot;Hello&quot;。 数字（Number）：10、3.14。 布尔值（Boolean）：true、false。 null 和 undefined。 引用类型： 对象（Object）：{ key: &quot;value&quot; }。 数组（Array）：[1, 2, 3]。 函数（Function）：function() {}。 3. 运算符 算术运算符：+、-、*、/。 比较运算符：==、===、&gt;、&lt;。 逻辑运算符：&amp;&amp;、||、!。 4. 控制结构 条件语句：12345if (age &gt; 18) { console.log(&quot;成年人&quot;);} else { console.log(&quot;未成年人&quot;);} 循环语句：123for (let i = 0; i &lt; 5; i++) { console.log(i);} 5. 函数 普通函数：123function greet(name) { return &quot;Hello, &quot; + name;} 箭头函数：1const greet = (name) =&gt; &quot;Hello, &quot; + name; JavaScript 的核心概念 1. DOM 操作 DOM（Document Object Model）是 HTML 文档的编程接口。 JavaScript 可以通过 DOM 操作 HTML 元素。 示例：1document.getElementById(&quot;myElement&quot;).innerHTML = &quot;Hello, World!&quot;; 2. 事件处理 JavaScript 可以为 HTML 元素添加事件监听器。 示例：123document.getElementById(&quot;myButton&quot;).addEventListener(&quot;click&quot;, function() { alert(&quot;按钮被点击了！&quot;);}); 3. 异步编程 回调函数：123setTimeout(function() { console.log(&quot;1 秒后执行&quot;);}, 1000); Promise：1234fetch(&quot;https://api.example.com/data&quot;) .then(response =&gt; response.json()) .then(data =&gt; console.log(data)) .catch(error =&gt; console.error(error)); async/await：123456789async function fetchData() { try { const response = await fetch(&quot;https://api.example.com/data&quot;); const data = await response.json(); console.log(data); } catch (error) { console.error(error); }} 4. 面向对象编程 构造函数：12345function Person(name, age) { this.name = name; this.age = age;}const alice = new Person(&quot;Alice&quot;, 25); 类（ES6）：1234567891011class Person { constructor(name, age) { this.name = name; this.age = age; } greet() { console.log(`Hello, my name is ${this.name}`); }}const bob = new Person(&quot;Bob&quot;, 30);bob.greet(); JavaScript 的进阶特性 1. ES6+ 新特性 模板字符串：12const name = &quot;Alice&quot;;console.log(`Hello, ${name}`); 解构赋值：12const [a, b] = [1, 2];const { name, age } = { name: &quot;Alice&quot;, age: 25 }; 模块化：123456// module.jsexport const add = (a, b) =&gt; a + b;// main.jsimport { add } from './module.js';console.log(add(1, 2)); 2. 闭包 闭包是指函数可以访问其词法作用域中的变量，即使函数在其词法作用域之外执行。 示例：123456789function outer() { const x = 10; function inner() { console.log(x); } return inner;}const closure = outer();closure(); // 输出 10 3. 原型链 JavaScript 使用原型链实现继承。 示例：12345678function Animal(name) { this.name = name;}Animal.prototype.speak = function() { console.log(`${this.name} makes a noise.`);};const dog = new Animal(&quot;Dog&quot;);dog.speak(); // 输出 &quot;Dog makes a noise.&quot; JavaScript 开发工具 浏览器开发者工具： Chrome DevTools：用于调试 JavaScript 代码。 Firefox Developer Tools：功能类似，适合前端开发。 代码编辑器： Visual Studio Code（推荐）。 Sublime Text。 Atom。 包管理工具： npm：Node.js 的包管理器。 yarn：更快的包管理工具。 构建工具： Webpack：模块打包工具。 Babel：将 ES6+ 代码转换为兼容性更好的代码。 应用","link":"/%E5%89%8D%E7%AB%AF/front-end/"},{"title":"Knowledge_points","text":"","link":"/uncategorized/knowledge-points/"}],"tags":[{"name":"系统组件","slug":"系统组件","link":"/tags/%E7%B3%BB%E7%BB%9F%E7%BB%84%E4%BB%B6/"},{"name":"未知","slug":"未知","link":"/tags/%E6%9C%AA%E7%9F%A5/"},{"name":"计网","slug":"计网","link":"/tags/%E8%AE%A1%E7%BD%91/"},{"name":"操作系统","slug":"操作系统","link":"/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"数据结构","slug":"数据结构","link":"/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"计组","slug":"计组","link":"/tags/%E8%AE%A1%E7%BB%84/"},{"name":"DL","slug":"DL","link":"/tags/DL/"}],"categories":[{"name":"力扣","slug":"力扣","link":"/categories/%E5%8A%9B%E6%89%A3/"},{"name":"力扣热门100","slug":"力扣/力扣热门100","link":"/categories/%E5%8A%9B%E6%89%A3/%E5%8A%9B%E6%89%A3%E7%83%AD%E9%97%A8100/"},{"name":"读书","slug":"读书","link":"/categories/%E8%AF%BB%E4%B9%A6/"},{"name":"算法","slug":"算法","link":"/categories/%E7%AE%97%E6%B3%95/"},{"name":"JAVA","slug":"JAVA","link":"/categories/JAVA/"},{"name":"天马行空","slug":"天马行空","link":"/categories/%E5%A4%A9%E9%A9%AC%E8%A1%8C%E7%A9%BA/"},{"name":"计算机基础","slug":"计算机基础","link":"/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"},{"name":"建站相关","slug":"建站相关","link":"/categories/%E5%BB%BA%E7%AB%99%E7%9B%B8%E5%85%B3/"},{"name":"JAVA基础知识点","slug":"JAVA/JAVA基础知识点","link":"/categories/JAVA/JAVA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"name":"JAVA常用API","slug":"JAVA/JAVA常用API","link":"/categories/JAVA/JAVA%E5%B8%B8%E7%94%A8API/"},{"name":"数据库","slug":"数据库","link":"/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"PYTHON","slug":"PYTHON","link":"/categories/PYTHON/"},{"name":"AI","slug":"AI","link":"/categories/AI/"},{"name":"前端","slug":"前端","link":"/categories/%E5%89%8D%E7%AB%AF/"}],"pages":[{"title":"Fundamentals-of-Computer-Science","text":"","link":"/Fundamentals-of-Computer-Science/index.html"},{"title":"文章分类","text":"","link":"/categories/index.html"},{"title":"About","text":"社交链接 关于我 /* social-links 容器水平排列图标，增加间距 */ .social-links { display: flex; justify-content: center; gap: 30px; /* 增加图标之间的间距 */ } /* qr-trigger 设置为 flex 布局，确保图标和二维码垂直对齐 */ .qr-trigger { display: flex; flex-direction: column; align-items: center; /* 水平居中对齐 */ position: relative; width: 100px; /* 可以根据需要调整宽度 */ } /* 默认情况下隐藏二维码图片 */ .qr-img { display: none; position: absolute; bottom: -230px; /* 增加二维码和图标的距离，避免重叠 */ left: 50%; transform: translateX(-50%); max-width: 240px; /* 设置最大宽度，保持比例 */ max-height: 240px; /* 设置最大高度，保持比例 */ z-index: 10; /* 确保二维码在最上层 */ transition: opacity 0.3s ease; } /* 鼠标悬停时显示二维码图片 */ .qr-trigger:hover .qr-img { display: block; opacity: 1; } /* 图标的大小调整 */ .qr-trigger i { font-size: 2rem; /* 设置图标的大小 */ } // 如果需要额外的JavaScript代码，可以在这里添加 // 当前没有JavaScript逻辑，仅用于未来扩展 本站建立初衷一为记录，二为查找，三为督促。如果你有什么建议或疑惑，或者只是单纯交友，欢迎添加好友。","link":"/about/index.html"}]}