{"posts":[{"title":"多维动态规划","text":"","link":"/%E5%8A%9B%E6%89%A3/%E5%8A%9B%E6%89%A3%E7%83%AD%E9%97%A8100/%E5%A4%9A%E7%BB%B4%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/LC100-MDdp/"},{"title":"数组","text":"","link":"/%E5%8A%9B%E6%89%A3/%E5%8A%9B%E6%89%A3%E7%83%AD%E9%97%A8100/%E6%95%B0%E7%BB%84/LC100-array/"},{"title":"回溯","text":"","link":"/%E5%8A%9B%E6%89%A3/%E5%8A%9B%E6%89%A3%E7%83%AD%E9%97%A8100/%E5%9B%9E%E6%BA%AF/LC100-backtrack/"},{"title":"图论","text":"","link":"/%E5%8A%9B%E6%89%A3/%E5%8A%9B%E6%89%A3%E7%83%AD%E9%97%A8100/%E5%9B%BE%E8%AE%BA/LC100-graph/"},{"title":"二分查找","text":"","link":"/%E5%8A%9B%E6%89%A3/%E5%8A%9B%E6%89%A3%E7%83%AD%E9%97%A8100/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/LC100-binary-search/"},{"title":"二叉树","text":"","link":"/%E5%8A%9B%E6%89%A3/%E5%8A%9B%E6%89%A3%E7%83%AD%E9%97%A8100/%E4%BA%8C%E5%8F%89%E6%A0%91/LC100-binary-tree/"},{"title":"双指针","text":"","link":"/%E5%8A%9B%E6%89%A3/%E5%8A%9B%E6%89%A3%E7%83%AD%E9%97%A8100/%E5%8F%8C%E6%8C%87%E9%92%88/LC100-dual-pointer/"},{"title":"动态规划","text":"","link":"/%E5%8A%9B%E6%89%A3/%E5%8A%9B%E6%89%A3%E7%83%AD%E9%97%A8100/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/LC100-dp/"},{"title":"堆","text":"","link":"/%E5%8A%9B%E6%89%A3/%E5%8A%9B%E6%89%A3%E7%83%AD%E9%97%A8100/%E5%A0%86/LC100-heap/"},{"title":"贪心算法","text":"","link":"/%E5%8A%9B%E6%89%A3/%E5%8A%9B%E6%89%A3%E7%83%AD%E9%97%A8100/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/LC100-greedy/"},{"title":"链表","text":"","link":"/%E5%8A%9B%E6%89%A3/%E5%8A%9B%E6%89%A3%E7%83%AD%E9%97%A8100/%E9%93%BE%E8%A1%A8/LC100-linked-list/"},{"title":"技巧","text":"","link":"/%E5%8A%9B%E6%89%A3/%E5%8A%9B%E6%89%A3%E7%83%AD%E9%97%A8100/%E6%8A%80%E5%B7%A7/LC100-skill/"},{"title":"滑动窗口","text":"","link":"/%E5%8A%9B%E6%89%A3/%E5%8A%9B%E6%89%A3%E7%83%AD%E9%97%A8100/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/LC100-sliding-window/"},{"title":"栈","text":"","link":"/%E5%8A%9B%E6%89%A3/%E5%8A%9B%E6%89%A3%E7%83%AD%E9%97%A8100/%E6%A0%88/LC100-stack/"},{"title":"矩阵","text":"","link":"/%E5%8A%9B%E6%89%A3/%E5%8A%9B%E6%89%A3%E7%83%AD%E9%97%A8100/%E7%9F%A9%E9%98%B5/LC100-matrix/"},{"title":"子串","text":"","link":"/%E5%8A%9B%E6%89%A3/%E5%8A%9B%E6%89%A3%E7%83%AD%E9%97%A8100/%E5%AD%90%E4%B8%B2/LC100-substring/"},{"title":"力扣热门100JAVA版","text":"基础操作 put(K key, V value)：将指定的键值对插入到 HashMap 中，若键已存在，则更新值。get(Object key)：根据键获取值，如果不存在该键，返回 null。remove(Object key)：根据键删除键值对。containsKey(Object key)：检查是否包含指定的键。containsValue(Object value)：检查是否包含指定的值。size()：返回 HashMap 中键值对的数量。isEmpty()：检查 HashMap 是否为空。keySet()：返回所有键的集合。values()：返回所有值的集合。entrySet()：返回 HashMap 中所有键值对的 Set 集合。clear()：清空所有元素。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import java.util.HashMap;import java.util.Map;public class HashMapExample { public static void main(String[] args) { // 创建 HashMap 实例 HashMap&lt;String, Integer&gt; map = new HashMap&lt;&gt;(); // 1. put() - 添加或更新元素 map.put(&quot;apple&quot;, 1); // key = &quot;apple&quot;, value = 1 map.put(&quot;banana&quot;, 2); // key = &quot;banana&quot;, value = 2 map.put(&quot;orange&quot;, 3); // key = &quot;orange&quot;, value = 3 // 2. get() - 获取元素 System.out.println(&quot;Value for key 'apple': &quot; + map.get(&quot;apple&quot;)); // 输出 1 // 3. containsKey() - 检查是否包含某个键 System.out.println(&quot;Contains key 'banana': &quot; + map.containsKey(&quot;banana&quot;)); // 输出 true // 4. containsValue() - 检查是否包含某个值 System.out.println(&quot;Contains value 2: &quot; + map.containsValue(2)); // 输出 true // 5. remove() - 删除某个键值对 map.remove(&quot;banana&quot;); System.out.println(&quot;After removing 'banana': &quot; + map); // 6. size() - 获取大小 System.out.println(&quot;Size of map: &quot; + map.size()); // 输出 2 // 7. isEmpty() - 检查是否为空 System.out.println(&quot;Is map empty? &quot; + map.isEmpty()); // 输出 false // 8. keySet() - 获取所有的键 System.out.println(&quot;All keys: &quot; + map.keySet()); // 输出 [apple, orange] // 9. values() - 获取所有的值 System.out.println(&quot;All values: &quot; + map.values()); // 输出 [1, 3] // 10. entrySet() - 获取所有的键值对 for (Map.Entry&lt;String, Integer&gt; entry : map.entrySet()) { System.out.println(entry.getKey() + &quot;: &quot; + entry.getValue()); } // 11. clear() - 清空所有元素 map.clear(); System.out.println(&quot;After clearing map: &quot; + map); // 输出 {} }} 1. 两数之和12345678910111213class Solution { public int[] twoSum(int[] nums, int target) { HashMap&lt;Integer, Integer&gt; mp = new HashMap&lt;&gt;(); for (int i = 0; i &lt; nums.length; i++){ int temp = target - nums[i]; if (mp.containsKey(temp)){ return new int[]{mp.get(temp), i}; } mp.put(nums[i], i); } return new int[0]; }} 49. 字母异位词分组128. 最长连续序列1234567891011121314151617181920212223class Solution { public int longestConsecutive(int[] nums) { Set&lt;Integer&gt; num_set = new HashSet&lt;Integer&gt;(); for (int num : nums){ num_set.add(num); } int ans = 0; for (int num : num_set){ if (!num_set.contains(num - 1)){ int cur = num; int temp = 1; while (num_set.contains(cur + 1)){ cur++; temp++; } ans = Math.max(ans, temp); } } return ans; }}","link":"/%E5%8A%9B%E6%89%A3/%E5%8A%9B%E6%89%A3%E7%83%AD%E9%97%A8100/%E5%93%88%E5%B8%8C/LChot100/"},{"title":"LRU与LFU缓存","text":"LRU与LFU缓存替换策略LRU（Least Recently Used，最少最近使用）和 LFU（Least Frequently Used，最不经常使用）是两种常用的缓存替换策略，用于决定缓存中哪些项应该被淘汰。它们的实现和应用场景非常广泛，特别是在内存管理、数据库缓存和操作系统中。 LRU (Least Recently Used) 最少最近使用LRU 策略用于在缓存满了时，淘汰最久没有使用的数据。即：每当一个缓存项被访问时，它就被认为是“最近使用”的，最少使用的缓存项就会被替换。 题目描述:设计并实现一个满足LRU最近最少使用缓存约束的数据结构。实现LRUCache类：LRUCache (int capacity)以 正整数 作为容量 capacity 初始化 LRU 缓存int get(int key) 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。void put(int key, int value)如果关键字 key 已经存在，则变更其数据值 value ；如果不存在，则向缓存中插入该组 key-value 。如果插入操作导致关键字数量超过 capacity ，则应该 逐出 最久未使用的关键字。函数get和put必须以O(1)的平均时间复杂度运行。} 思路：每次访问缓存时，将该缓存项标记为“最近使用”。当缓存满时，淘汰最久未被访问的缓存项。实现方法：LRU 可以通过 双向链表 和 哈希表 来实现： 哈希表 用于快速访问缓存项。双向链表 用于维护缓存项的使用顺序，最近访问的项放在链表头，最久未访问的项放在链表尾。LRU 实现步骤：哈希表：存储缓存的键值对，键是缓存的键，值是缓存项（值和最近使用的顺序）。双向链表：存储缓存项的顺序，最近访问的缓存项放在头部，最久未访问的放在尾部。插入和删除：每次访问缓存项时，将该项移动到链表头；如果缓存满了，移除链表尾部的项。 12345678910111213141516171819202122232425262728293031323334353637383940import java.util.*;class LRUCache { private int capacity; private Map&lt;Integer, Integer&gt; cache; private LinkedHashMap&lt;Integer, Long&gt; accessOrder; public LRUCache(int capacity) { this.capacity = capacity; this.cache = new HashMap&lt;&gt;(); this.accessOrder = new LinkedHashMap&lt;&gt;(capacity, 0.75f, true); // true 表示访问顺序 } public int get(int key) { if (!cache.containsKey(key)) { return -1; } // 更新访问顺序 accessOrder.put(key, System.nanoTime()); return cache.get(key); } public void put(int key, int value) { if (cache.size() &gt;= capacity) { // 找到最少使用的键 long leastUsedTime = Long.MAX_VALUE; int keyToRemove = -1; for (Map.Entry&lt;Integer, Long&gt; entry : accessOrder.entrySet()) { if (entry.getValue() &lt; leastUsedTime) { leastUsedTime = entry.getValue(); keyToRemove = entry.getKey(); } } // 移除最少使用的项 cache.remove(keyToRemove); accessOrder.remove(keyToRemove); } cache.put(key, value); accessOrder.put(key, System.nanoTime()); }}} 但这么写 过不了力扣…… 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273class LRUCache { // Node 类表示链表中的每个节点 private static class Node { int key, value; // 存储 key 和 value Node prev, next; // 前后指针，用于双向链表 Node(int k, int v) { // 构造函数初始化 key 和 value key = k; value = v; } } private final int capacity; // 缓存的最大容量 private final Node dummy = new Node(0, 0); // 哑节点，用于简化双向链表操作（头节点） private final Map&lt;Integer, Node&gt; keyToNode = new HashMap&lt;&gt;(); // 用于存储缓存中每个 key 对应的节点 // 构造函数初始化容量，并且初始化双向链表的 dummy 节点 public LRUCache(int capacity) { this.capacity = capacity; dummy.prev = dummy; // 哑节点的 prev 指向自己 dummy.next = dummy; // 哑节点的 next 指向自己 } // 获取缓存中某个 key 对应的 value public int get(int key) { Node node = getNode(key); // 查找 key 对应的节点 return node != null ? node.value : -1; // 如果找到节点，返回节点的值，否则返回 -1（表示不存在） } // 向缓存中插入新的 key-value 对 public void put(int key, int value) { Node node = getNode(key); // 查找 key 对应的节点 if (node != null) { // 如果节点存在，更新节点的值 node.value = value; return; // 直接返回，无需做其他操作 } // 如果节点不存在，创建一个新的节点并插入到缓存中 node = new Node(key, value); keyToNode.put(key, node); // 将新节点存入哈希表 pushFront(node); // 将新节点移动到链表的头部，表示最近使用 // 如果缓存的大小超过了容量，移除最不常用的节点（尾部节点） if (keyToNode.size() &gt; capacity) { Node backNode = dummy.prev; // 获取尾部节点（最久未使用的节点） keyToNode.remove(backNode.key); // 从哈希表中移除该节点 remove(backNode); // 从链表中移除该节点 } } // 根据 key 获取对应的节点 private Node getNode(int key) { if (!keyToNode.containsKey(key)) return null; // 如果 key 不存在，返回 null Node node = keyToNode.get(key); // 获取节点 remove(node); // 从链表中移除该节点 pushFront(node); // 将该节点移到链表头部，表示它是最新使用的 return node; // 返回节点 } // 从链表中移除指定的节点 private void remove(Node x) { x.prev.next = x.next; // 将前一个节点的 next 指向当前节点的下一个节点 x.next.prev = x.prev; // 将下一个节点的 prev 指向当前节点的前一个节点 } // 将指定的节点插入到链表头部 private void pushFront(Node x) { x.prev = dummy; // 新节点的 prev 指向哑节点 x.next = dummy.next; // 新节点的 next 指向哑节点的下一个节点 x.prev.next = x; // 哑节点的 next 指向新节点 x.next.prev = x; // 新节点的 next 节点的 prev 指向新节点 }}} LFU (Least Frequently Used) 最不经常使用LFU 策略用于淘汰访问频率最低的缓存项。即：每次访问缓存时，缓存项的访问次数增加。缓存满时，淘汰访问次数最少的缓存项。 思路：每个缓存项都有一个访问频率：当访问缓存时，增加该项的频率。淘汰策略：当缓存满时，淘汰频率最低的缓存项。若频率相同，则淘汰最早添加的缓存项。实现方法：LFU 通常使用 哈希表 和 最小堆（或 哈希表+双向链表）来实现。 哈希表 用于存储缓存的键值对。频率表：哈希表将缓存项的访问次数作为键，缓存项列表作为值（即频率与缓存项的映射关系）。最小堆：或者使用优先队列来管理访问频率，以便快速找到访问次数最少的缓存项。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364import java.util.*;class LFUCache { private int capacity; private Map&lt;Integer, Integer&gt; values; private Map&lt;Integer, Integer&gt; frequencies; private Map&lt;Integer, LinkedHashSet&lt;Integer&gt;&gt; freqList; private int minFreq; public LFUCache(int capacity) { this.capacity = capacity; this.values = new HashMap&lt;&gt;(); this.frequencies = new HashMap&lt;&gt;(); this.freqList = new HashMap&lt;&gt;(); this.minFreq = -1; } public int get(int key) { if (!values.containsKey(key)) { return -1; } int freq = frequencies.get(key); frequencies.put(key, freq + 1); freqList.get(freq).remove(key); if (freqList.get(freq).isEmpty()) { if (minFreq == freq) { minFreq++; } freqList.remove(freq); } freqList.putIfAbsent(freq + 1, new LinkedHashSet&lt;&gt;()); freqList.get(freq + 1).add(key); return values.get(key); } public void put(int key, int value) { if (capacity &lt;= 0) return; if (values.containsKey(key)) { values.put(key, value); get(key); // 更新频率 return; } if (values.size() &gt;= capacity) { // 淘汰最少频次的缓存项 int evictKey = freqList.get(minFreq).iterator().next(); freqList.get(minFreq).remove(evictKey); if (freqList.get(minFreq).isEmpty()) { freqList.remove(minFreq); } values.remove(evictKey); frequencies.remove(evictKey); } values.put(key, value); frequencies.put(key, 1); minFreq = 1; freqList.putIfAbsent(1, new LinkedHashSet&lt;&gt;()); freqList.get(1).add(key); }}} 主要思路：频率管理：用一个哈希表 freqToDummy 存储每个访问频率对应的链表，链表的头部代表最近访问的节点，尾部代表最久未访问的节点。双向链表：为每个访问频率维护一个双向链表，这样可以高效地管理节点的顺序，并能在常数时间内删除最不常使用的节点。最小频率：minFreq 变量用于记录当前缓存中的最小访问频率。每当访问一个节点时，如果该节点的访问频率变化，并且该频率链表变为空，我们需要更新 minFreq。核心操作：get 操作：查找并返回缓存中 key 对应的值，同时将该节点的访问频率加 1，并将其移动到新的频率链表中。put 操作：如果缓存已满，先移除访问频率最少的节点。然后将新节点插入到频率为 1 的链表中，并设置 minFreq 为 1。节点的移动：每次访问或插入时，节点会根据其访问频率被移动到对应的链表头部，从而保证频率最低的节点最先被淘汰。性能分析：时间复杂度：每个操作（get、put、remove、pushFront）都可以在 O(1) 时间内完成，因为链表操作和哈希表操作的时间复杂度是 O(1)。空间复杂度：空间复杂度是 O(capacity)，因为我们只在缓存中存储最多 capacity 个节点。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899class LFUCache { // Node 类表示链表中的每个节点 private static class Node { int key, value, freq = 1; // key 是键，value 是值，freq 是访问频率，初始化为 1 Node prev, next; // prev 和 next 是双向链表的指针 Node(int key, int value) { // 构造函数初始化 key 和 value this.key = key; this.value = value; } } private final int capacity; // 缓存的最大容量 private final Map&lt;Integer, Node&gt; keyToNode = new HashMap&lt;&gt;(); // 存储缓存的 key -&gt; Node 映射 private final Map&lt;Integer, Node&gt; freqToDummy = new HashMap&lt;&gt;(); // 存储频率 -&gt; 哑节点（代表链表头） private int minFreq; // 记录当前缓存中的最小访问频率 // 构造函数初始化缓存容量 public LFUCache(int capacity) { this.capacity = capacity; } // 获取缓存中指定 key 对应的值 public int get(int key) { Node node = getNode(key); // 获取节点 return node != null ? node.value : -1; // 如果节点存在，返回其值，否则返回 -1 } // 向缓存中插入新的 key-value 对 public void put(int key, int value) { Node node = getNode(key); // 尝试从缓存中获取该节点 if (node != null) { // 如果节点已经存在，更新其值 node.value = value; return; } // 如果缓存已满，则删除访问频率最少的元素 if (keyToNode.size() == capacity) { Node dummy = freqToDummy.get(minFreq); // 获取最小频率的链表 Node backNode = dummy.prev; // 获取该链表中的最旧节点 keyToNode.remove(backNode.key); // 从哈希表中移除该节点 remove(backNode); // 从链表中移除该节点 if (dummy.prev == dummy) { // 如果该链表为空 freqToDummy.remove(minFreq); // 移除该频率的链表 } } // 创建新节点并放入缓存 node = new Node(key, value); keyToNode.put(key, node); // 添加到 keyToNode 哈希表 pushFront(1, node); // 将新节点放入频率为 1 的链表中（即最上面） minFreq = 1; // 更新最小频率为 1 } // 获取指定 key 对应的节点，并将其访问频率加 1 private Node getNode(int key) { if (!keyToNode.containsKey(key)) { // 如果没有该 key return null; } Node node = keyToNode.get(key); // 获取节点 remove(node); // 从链表中移除该节点 Node dummy = freqToDummy.get(node.freq); // 获取当前频率对应的链表 if (dummy.prev == dummy) { // 如果当前频率的链表为空 freqToDummy.remove(node.freq); // 移除该频率的链表 if (minFreq == node.freq) { // 如果当前频率是最小频率 minFreq++; // 增加最小频率 } } // 增加访问频率，并将节点放入新的频率链表的最上面 pushFront(++node.freq, node); return node; // 返回节点 } // 创建一个新的双向链表（每个频率的链表） private Node newList() { Node dummy = new Node(0, 0); // 哑节点作为双向链表的头节点 dummy.prev = dummy; dummy.next = dummy; return dummy; } // 将节点添加到指定频率的链表头部（表示该节点最近被访问） private void pushFront(int freq, Node x) { Node dummy = freqToDummy.computeIfAbsent(freq, k -&gt; newList()); // 获取该频率对应的链表头（如果不存在则创建） x.prev = dummy; // 将节点的 prev 指向该频率链表的头 x.next = dummy.next; // 将节点的 next 指向该频率链表的第一个节点 x.prev.next = x; // 连接节点到链表头 x.next.prev = x; // 连接节点到链表的下一个节点 } // 从链表中删除一个节点 private void remove(Node x) { x.prev.next = x.next; // 删除节点的前后节点的连接 x.next.prev = x.prev; // 删除节点的前后节点的连接 }}}","link":"/%E7%AE%97%E6%B3%95/LRU%E4%B8%8ELFU%E7%BC%93%E5%AD%98%E6%9B%BF%E6%8D%A2/algorithm-fundamentals/"},{"title":"JAVA基础知识","text":"Java 基本数据类型 Java 基本数据类型对比表，涵盖了整数、浮点、字符和布尔类型： 数据类型 存储字节数 最小值 最大值 说明 byte 1 字节 -128 127 8 位带符号整数 short 2 字节 -32,768 32,767 16 位带符号整数 int 4 字节 -2,147,483,648 2,147,483,647 32 位带符号整数 long 8 字节 -9,223,372,036,854,775,808 9,223,372,036,854,775,807 64 位带符号整数 float 4 字节 ±1.4E-45 ±3.4028235E38 单精度浮点数（32 位） double 8 字节 ±4.9E-324 ±1.7976931348623157E308 双精度浮点数（64 位） char 2 字节 0 65,535 单一字符（UTF-16编码） boolean 1 字节（理论上） false true 布尔类型，通常表示为 true 或 false","link":"/JAVA/JAVA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/java-basic-data-type/"},{"title":"力扣每日一题","text":"该文档仅仅自用 3066. 超过阈值的最少操作数 II时间：2025/1/15 使用数据结构：优先队列 此题模拟即可，但要熟练掌握优先队列的使用，同时需要注意到数据范围，$1 &lt;= nums[i] &lt;= 10^9$，使用long接收参数。 12345678910111213141516class Solution { public int minOperations(int[] nums, int k) { int ans = 0; PriorityQueue&lt;Long&gt; pq = new PriorityQueue&lt;&gt;(); for(long num : nums){ pq.offer(num); } while(pq.peek() &lt; k){ long x = pq.poll(), y = pq.poll(); pq.offer(x + x + y); ans++; } return ans; }} 3095. 或值至少 K 的最短子数组 I时间：2025/1/16 枚举以i为起始位置的子数组，找到最短的符合要求的长度。 1234567891011121314151617class Solution { public int minimumSubarrayLength(int[] nums, int k) { int ans = Integer.MAX_VALUE; for(int i = 0; i &lt; nums.length; i++){ int cur = 0; for(int j = i; j &lt; nums.length; j++){ cur |= nums[j]; if(cur &gt;= k){ ans = Math.min(ans, j - i + 1); break; } } } return ans == Integer.MAX_VALUE ? -1 : ans; }} 或者可以使用滑动窗口 12345678910111213141516171819202122232425262728293031class Solution { public int minimumSubarrayLength(int[] nums, int k) { int n = nums.length; int[] bits = new int[30]; int res = Integer.MAX_VALUE; for (int left = 0, right = 0; right &lt; n; right++) { for (int i = 0; i &lt; 30; i++) { bits[i] += (nums[right] &gt;&gt; i) &amp; 1; } while (left &lt;= right &amp;&amp; calc(bits) &gt;= k) { res = Math.min(res, right - left + 1); for (int i = 0; i &lt; 30; i++) { bits[i] -= (nums[left] &gt;&gt; i) &amp; 1; } left++; } } return res == Integer.MAX_VALUE ? -1 : res; } private int calc(int[] bits) { int ans = 0; for (int i = 0; i &lt; bits.length; i++) { if (bits[i] &gt; 0) { ans |= 1 &lt;&lt; i; } } return ans; }}","link":"/%E5%8A%9B%E6%89%A3/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/lcday/"},{"title":"位运算","text":"位运算是对整数在二进制位层面上进行直接操作的运算。它在性能敏感的程序中尤其重要，例如操作系统、嵌入式系统、加密算法等领域，通常比普通的算术运算更高效。 你提到的性质是位运算中的一个基本属性，对于按位“或”操作（OR）而言，确实存在一些规律和性质。这些性质在位运算中非常重要，特别是在优化和证明等场景中。以下是关于 按位与（AND）、按位或（OR）、按位异或（XOR） 和 按位非（NOT） 等常见位运算的各种基本性质的详细说明。 1. 按位“或”运算的性质（OR）对于任意两个整数 A 和 B，按位或运算（A | B）具有以下几条重要性质： 1.1. 自反性（Idempotence）任何数与自身做按位或运算，结果仍然是自身。例如： 5 | 5 = 5 1.2. 单调性（Monotonicity）$A \\leq B \\implies A | C \\leq B | C \\quad \\text{对于任意的} C$ 这意味着，如果 A 小于 B，则 A 与任意数 C 做按位或运算的结果将不大于 B 与 C 的按位或结果。直观来说，按位或运算不会缩小数值。 1.3. 与任意元素按位或运算，结果大于等于自身$A | B \\geq A$ 按位或操作将 A 中的 0 变为 1，不会使 1 变回 0，因此 A | B 的每一位都大于或等于 A 的相应位。 1.4. 交换律（Commutativity）$A | B = B | A$ 按位或运算是交换的，即 A 与 B 按位或运算的结果与顺序无关。 1.5. 结合律（Associativity）$(A | B) | C = A | (B | C)$ 按位或运算是结合的，即对多个数进行按位或时，操作的顺序可以任意调整。 1.6. 单位元（Identity Element）$A | 0 = A$ 任意数与 0 做按位或运算，结果仍然是该数本身。 1.7. 吸收律（Absorption）$A | (A &amp; B) = A$ 任何数与它与另一个数按位与（&amp;）的结果做按位或，结果等于原数。这个性质的意思是，按位或操作“吸收”了按位与的结果。 1.8. 按位或与按位与的分配律（Distributivity）$A | (B &amp; C) = (A | B) &amp; (A | C)$ 按位或和按位与之间存在分配律，类似于普通算数运算中的分配律。 2. 按位“与”运算的性质（AND）按位与运算（A &amp; B）也有一些类似的性质： 2.1. 自反性（Idempotence）A &amp; A = A 任何数与自身做按位与运算，结果仍然是自身。 2.2. 交换律（Commutativity）A &amp; B = B &amp; A 按位与运算是交换的。 2.3. 结合律（Associativity）(A &amp; B) &amp; C = A &amp; (B &amp; C) 按位与运算是结合的。 2.4. 单位元（Identity Element）A &amp; 1 = A 任意数与 1 做按位与运算，结果仍然是该数本身。注意，1 在二进制中相当于所有位都为 1。 2.5. 零元（Null Element）A &amp; 0 = 0 任意数与 0 做按位与运算，结果为 0。这是因为与 0 按位与运算的任何结果都会是 0。 2.6. 吸收律（Absorption）A &amp; (A | B) = A 按位与与按位或之间也有吸收律，类似于上面按位或的吸收律。 3. 按位异或运算的性质（XOR）按位异或运算（A ^ B）也具有一些特别的性质： 3.1. 自反性（Idempotence）A ^ A = 0 任何数与自身做按位异或，结果为 0。 3.2. 交换律（Commutativity）A ^ B = B ^ A 按位异或是交换的。 3.3. 结合律（Associativity）(A ^ B) ^ C = A ^ (B ^ C) 按位异或是结合的。 3.4. 单位元（Identity Element）A ^ 0 = A 任何数与 0 做按位异或运算，结果仍然是该数本身。 3.5. 对称性（Symmetry）A ^ B = B ^ A 按位异或是对称的。 4. 按位“非”运算的性质（NOT）按位非（~）运算的性质相对简单： 4.1. 自反性（Idempotence）$\\sim (\\sim A) = A$ 对某个数取两次按位非，结果是原数。 4.2. 按位非操作按位非操作对二进制数的每一位取反，即 0 变 1，1 变 0。 5. 位运算的应用位运算在编程中非常有用，特别是在涉及到大量的数值操作、标志位管理、内存优化等场景。以下是一些常见的应用： 判断某个数是否为偶数：x &amp; 1 == 0 判断某个数是否为 2 的幂：x &amp; (x - 1) == 0 提取某一位：(x &gt;&gt; n) &amp; 1，获取第 n 位的值。 设置某一位：x | (1 &lt;&lt; n)，设置第 n 位为 1。 清除某一位：x &amp; ~(1 &lt;&lt; n)，清除第 n 位。 反转某一位：x ^ (1 &lt;&lt; n)，反转第 n 位。 位运算的基本操作Java 和大多数编程语言支持以下几种常见的位运算： 按位与（AND）：&amp; 规则：两个操作数的相同位置上的位都为 1，结果才为 1。 15 &amp; 3 5 的二进制是 0101 3 的二进制是 0011 结果：0101 &amp; 0011 = 0001 → 1 按位或（OR）：| 规则：两个操作数的相同位置上的位只要有一个为 1，结果就为 1。 15 | 3 5 的二进制是 0101 3 的二进制是 0011 结果：0101 | 0011 = 0111 → 7 按位异或（XOR）：^ 规则：两个操作数的相同位置上的位不同，结果为 1，相同则为 0。 15 ^ 3 5 的二进制是 0101 3 的二进制是 0011 结果：0101 ^ 0011 = 0110 → 6 按位非（NOT）：~ 规则：对每一位取反，0 变成 1，1 变成 0。注意，这个操作会影响符号位，在 Java 中对 int 取反后是 32 位。 1~5 5 的二进制是 00000000000000000000000000000101 结果：~5 = 11111111111111111111111111111010 → -6（二进制补码表示） 位移操作： 左移（&lt;&lt;）：将数字的所有位向左移动指定的位数，右侧用0补充。 15 &lt;&lt; 1 5 的二进制是 0101 左移一位：1010 → 10 右移（&gt;&gt;）：将数字的所有位向右移动指定的位数，对于正数，用0填补；对于负数，符号位保持不变。 15 &gt;&gt; 1 5 的二进制是 0101 右移一位：0010 → 2 无符号右移（&gt;&gt;&gt;）：与右移类似，但是对负数无符号右移时会将符号位填充为0。 1-5 &gt;&gt;&gt; 1 -5 的二进制（补码表示）是 11111111111111111111111111111011 无符号右移一位：01111111111111111111111111111101 → 2147483642 位运算的技巧与应用 快速计算乘法与除法（2 的幂） 左移：相当于乘以 2 的某个次幂。例如，x &lt;&lt; n 等价于 x * 2^n。 12int x = 5; int result = x &lt;&lt; 2; // 相当于 5 * 4 = 20 右移：相当于除以 2 的某个次幂。例如，x &gt;&gt; n等价于 x / 2^n。 12int x = 20;int result = x &gt;&gt; 2; // 相当于 20 / 4 = 5 判断奇偶数 奇数：x &amp; 1 为 1 时，表示 x 是奇数。 偶数：x &amp; 1为 0时，表示x是偶数。 12int x = 5;boolean isOdd = (x &amp; 1) == 1; // 5 是奇数，结果为 true 判断是否是 2 的幂 一个数如果是 2 的幂，则它与它的前一个数按位与结果为 0。例如，x 是 2 的幂，当且仅当 x &amp; (x - 1) == 0。 12int x = 8;boolean isPowerOfTwo = (x &amp; (x - 1)) == 0; // 8 是 2 的幂，结果为 true 交换两个数 利用异或操作可以在不使用临时变量的情况下交换两个数。 12345int a = 5, b = 3;a = a ^ b; // a = 6b = a ^ b; // b = 5a = a ^ b; // a = 3// 交换后，a=3, b=5 设置某一位 使用按位或操作来设置某一位为1 12int x = 5; // 0101int result = x | (1 &lt;&lt; 2); // 设置第 2 位为 1 -&gt; 0111 清除某一位 使用按位与操作和按位非操作清除某一位。 12int x = 5; // 0101int result = x &amp; ~(1 &lt;&lt; 2); // 清除第 2 位 -&gt; 0001 反转某一位 使用按位异或操作来反转某一位。 12int x = 5; // 0101int result = x ^ (1 &lt;&lt; 2); // 反转第 2 位 -&gt; 0001 求平均数不带小数 位运算(a + b) &gt;&gt; 1 使用了位运算来高效地计算两个整数的平均值。通过按位与运算找到不进位的部分，按位异或运算找出进位的部分，然后将进位部分右移并与不进位部分相加，最终得到 a 和 b 的平均值。这种方法比直接使用 (a + b) / 2 更加高效。 1int result = ((a &amp; b) + (a ^ b) &gt;&gt; 1) ; 清零最低位的1 检查 n 是否是 2 的幂：如果 n &amp; (n - 1) == 0，那么 n 是 2 的幂。 清除 n 中最低位的 1。 1int result = n &amp; (n - 1) ; 位运算的常见应用场景： 图像处理：位运算用于像素的颜色深度处理和图像操作。 网络协议：许多网络协议（如 IP 地址、子网掩码）都依赖于位运算来处理二进制数据。 压缩算法：一些数据压缩算法利用位运算优化空间存储。 加密与解密：位运算被广泛应用于数据加密算法中（如 XOR 操作）。 位运算是计算机科学中非常重要且高效的工具，它使得很多操作能够以最小的成本完成，尤其在性能要求高的场景下，掌握位运算能大大提高程序的效率。","link":"/JAVA/JAVA%E5%9F%BA%E7%A1%80/%E4%BD%8D%E8%BF%90%E7%AE%97/bitewise/"},{"title":"优先队列","text":"在 Java 中，优先队列（PriorityQueue） 是一个基于堆（通常是最小堆）的数据结构，位于 java.util 包中。优先队列的元素会按照自然顺序或提供的比较器顺序进行排序。以下是关于优先队列的详细介绍： 特点 自动排序：默认是最小优先队列（最小堆），即每次取出的元素是当前队列中最小的元素。 非线程安全：PriorityQueue 不是线程安全的，如果需要线程安全，可以使用 PriorityBlockingQueue。 不允许 null 元素。 支持自定义顺序：可以通过传入 Comparator 定义元素的排序方式。 构造方法PriorityQueue 提供多种构造方法： 默认构造方法： 1PriorityQueue&lt;E&gt; pq = new PriorityQueue&lt;&gt;(); 创建一个初始容量为 11 的最小堆。 指定初始容量： 1PriorityQueue&lt;E&gt; pq = new PriorityQueue&lt;&gt;(int initialCapacity); 指定比较器： 1PriorityQueue&lt;E&gt; pq = new PriorityQueue&lt;&gt;(Comparator&lt;? super E&gt; comparator); 创建一个使用自定义比较器的优先队列。 通过集合初始化： 1PriorityQueue&lt;E&gt; pq = new PriorityQueue&lt;&gt;(Collection&lt;? extends E&gt; c); 常用方法以下是 PriorityQueue 的常用方法： 方法名 说明 add(E e) 向队列中添加元素，若超出容量会抛出异常。 offer(E e) 向队列中添加元素，推荐使用。 poll() 移除并返回队列的头部元素，若队列为空则返回 null。 peek() 返回队列的头部元素但不移除，若队列为空则返回 null。 remove(Object o) 删除队列中指定的元素。 size() 返回队列中元素的数量。 isEmpty() 判断队列是否为空。 clear() 清空队列中的所有元素。","link":"/JAVA/JAVA%E5%B8%B8%E7%94%A8API/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/java-priority-queue/"},{"title":"听歌吗","text":"","link":"/%E5%A4%A9%E9%A9%AC%E8%A1%8C%E7%A9%BA/%E8%AF%97%E8%AF%8D%E6%AD%8C%E8%B5%8B/old-songs/"},{"title":"基础乐理","text":"基础乐理知识一个曲谱有：调号、拍号、曲谱、歌词。 知道上述名称后，要从基础学起。 首先要明白音的性质：音高、音值、音量、音色。不同的乐器和人声都是通过这四项的不同变化才产生我们听到的音乐。 一、音及音高 音是由于物体的振动而产生的。音有高低、强弱、长短、音色等四种性质。 （1）音的高低是由于物体在一定时间内的振动次数(频率)而决定的。振动次数多，音则高;振动次数少，音则低。 （2）音的长短是由于音的延续时间的不同而决定的。音的延续时间长，音则长;音的延续时间短，音则短。 （3）音的强弱是由于振幅(音的振动范围的幅度)的大小而决定的。振幅大，音则强;振幅小，音则弱。 （4）音色则由于发音体的性质、形状及其泛音的多少等而不同。 由于音的振动状态的规则与不规则，音被分为乐音与噪音两类。音乐中所使用的主要是乐音，但噪音也是音乐表现中不可缺少的组成部分。 1、乐音体系音列音级 （1）在音乐中使用的、有固定音高的音的总和，叫做乐音体系。 （2）乐音体系中的音，按照上行或下行次序排列起来，叫做音列。 （3）乐音体系中的各音叫做音级。音级有基本音级和变化音级。 （4）乐音体系中，七个具有独立名称的音级叫做基本音级。 基本音级的名称是用字母和唱名两种方式来标记的。 字母体系：C D E F G A B 唱名体系：1 2 3 4 5 6 7 钢琴上白键所发出的音是与基本音级相符合的。钢琴上五十二个白键循环重复地使用七个基本音级名称。两个相邻的具有同样名称的音叫做八度。 升高或降低基本音级而得来的音，叫做变化音级。将基本音级升高半音用“升”或“#”来标明。降低半音用“降”或“b”来标明。升高全音用“重升”或“×”来标明。降低全音用“重降”或“bb”来标明。 如：升C或#C 降C或bC 2、音的分组 为了区分音名相同而音高不同的各音，我们将音列分成许多个“组”。 在音列中央的一组叫做小字一组。它的音级标记用小写字母并在右上方加数字1来表示。 比小字一组高的组顺次定名为：小字二组、小字三组、小字四组、小字五组。 小字二组的标记用小写字母并在右上方加数字2来表示。 比小字一组低的组，依次定名为小字组、大字组、大字一组及大字二组。 小字组各音的标记用不带数字的小写字母来表示。 大字组用不带数字的大写字母来标记。 大字一组用大写字母并在右下方加数字1来标明。 大字二组用大写字母并在右下方加数字2来标明。 3、音域及音区 总的音域是指音列的总范围，即从它的最低音(C2——c5)间的距离而言。 个别的人声或乐器的音域是指在整个音域中所能够达到的那一部分，如钢琴的音域是A2——c5。 音区是音域中的一部分，有高音区、低音区、中音区三种。 在整个音域中，小字组、小字一组和小字二组属于中音区。小字三组、小字四组和小字五组属高音区。大字组、大字一组和大字二组属低音区。 各音区的特性音色在音乐表现中，有着重大的意义。高音区一般具有清脆、嘹亮、尖锐的特性;而低音区则往往给人以浑厚、笨重之感。 二、音律 乐音体系中各音的绝对准确高度及其相互关系叫做音律。将八度分成十二个均等的部分——半音——的音律叫做十二平均律。 半音是十二平均律组织中最小的音高距离。两音间的距离等于两个半音的叫做全音。八度内包括十二个半音，也就是六个全音。 在音列中的基本音级中间，除了E到F、B到C是半音外，其余相邻两音间的距离都是全音。 根据复合音的第二分音和第三分音的纯五度关系，即由某一音开始向上推一纯五度，产生次一律，再由次一律向上推一纯五度，产生再次一律，如此继续相生所定出的音律叫做五度相生律。 纯律是于五度相生律用以构成的第二分音和第三分音之外，再加入第五分音来作为生律要素，构成和弦形式。 1、自然半音和自然全音变化半音和变化全音 由两个相邻的音级构成的半音叫做自然半音。如;e—f #e—#f #g—a 由相邻的两个音级形成的全音叫做自然全音。如：C—d C—#d ba—bB 由同一音级的两种不同形式所构成的半音，叫做变化半音。如：C—#C D—bD bbB—bB 由同一音级的两种不同形式或隔开一个音级所构成的全音，叫做变化全音。 如：B——bbB #C——bE 2、等音 音高相同而意义和记法不同的音，叫做等音。 1. 认识音符和节奏 学习内容： 音符（C、D、E、F、G、A、B）和升降音（#、b）的概念。 音名/音符是乐音体系中各音级各自的名称。现行通用音名为：CDEFGAB。除了音名还有do、re、mi、fa、sol、la、si这些音名，多用于歌唱，故又称唱名。除了音名和唱名以外，还有全音和半音，音高关系的最小计量单位，叫做“半音”，两个半音叫“全音”。 节奏符号（全音符、二分音符、四分音符等）。 节拍和拍号（如 4/4、3/4）。 练习建议： 在吉他上找到每根弦的音符位置。 打节拍器练习简单的节奏型。 2. 音阶与调式 学习内容： 自然大调音阶（C 大调）及其公式（全全半全全全半）。 自然小调音阶（A 小调）及其公式（全半全全半全全）。 了解调号和音阶关系。 练习建议： 在吉他指板上弹奏 C 大调和 A 小调音阶。 练习音阶爬格子，熟悉指板位置。 3. 和弦基础 学习内容： 什么是三和弦（大三和弦、小三和弦）。 常见和弦的构成音（如 C 和弦：C、E、G）。 和弦表记法（如 C、Am、G7）。 练习建议： 学会简单的和弦切换（如 C-G-Am-F）。 用和弦为简单的流行曲伴奏。","link":"/%E5%A4%A9%E9%A9%AC%E8%A1%8C%E7%A9%BA/%E4%B9%90%E7%90%86/musictheory/"},{"title":"建站过程","text":"什么是 Hexo？Hexo 是一个快速、简洁且高效的博客框架。 Hexo 使用 Markdown（或其他标记语言）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 详情请自行翻阅官网：https://hexo.io/zh-cn/docs/ 此处仅贴出常用指令自用。 1234567891011121314151617181920212223242526272829303132333435363738# 使用 npm 安装 Hexo$ npm install -g hexo-cli# 请自行替换文件夹名,新建一个网站$ hexo init &lt;folder&gt; $ cd &lt;folder&gt;$ npm install# 新建一篇文章,文章名称和标题为 [title],文章采用 [layout] 布局$ hexo new [layout] &lt;title&gt;$ hexo new &quot;post title with whitespace&quot; # 如果标题包含空格，需加引号# 清除缓存,网页正常情况下可以忽略此条命令,执行该指令后,会删掉站点根目录下的public文件夹$ hexo clean# 生成静态文件$ hexo generate$ hexo g# 发表草稿$ hexo publish [layout] &lt;filename&gt;# 启动服务器（常用于调试）$ hexo server$ hexo s# 部署网站,将本地数据部署到远端服务器(如github、coding)$ hexo deploy$ hexo d# 创建分类选项Created: ~\\myBlog\\source\\categories\\index.md$ hexo new page categories# 需分类的文章要添加# categories: # - web前端# 注意这里的分类名前需要一个空格#如果在“- web前端”下方添加“-xxx”，hexo不会产生两个分类，而是把分类嵌套（即该文章属于 “- web前端”下的 “-xxx ”分类）。 链接Github 123456789101. 生成SSH_KEY首先在git下输入命令：cd ~/.ssh进入.ssh文件输入命令：ssh-keygen -t rsa -C ‘注册时的邮箱地址’ 将刚刚在.ssh目录下所复制的id_rsa.put文件中的信息复制进key(注意空格)（名字随意） 接着在本地绑定与Github的用户名和邮箱（git）输入命令：git config --global user.name “注册时用户名”输入命令：git config --global user.email “注册时邮箱” 在 Windows PowerShell 下重新生成 SSH 密钥并配置 GitHub，按照以下步骤操作：（出自gpt） 1. 打开 PowerShell首先，按下 Win + X，然后选择 Windows PowerShell，或在开始菜单中搜索 “PowerShell” 并运行。 2. 生成 SSH 密钥在 PowerShell 中运行以下命令来生成新的 SSH 密钥： 1ssh-keygen -t rsa -b 4096 -C &quot;your_email@example.com&quot; -t rsa：指定使用 RSA 算法。 -b 4096：指定密钥长度为 4096 位（安全性更高）。 -C &quot;your_email@example.com&quot;：添加一个注释，通常是你的电子邮件地址，方便以后识别。 执行该命令后，你会看到类似以下的提示： 1Enter file in which to save the key (C:\\Users\\your_username\\.ssh\\id_rsa): 按下 Enter，接受默认的保存位置（C:\\Users\\your_username\\.ssh\\id_rsa），或者可以输入一个新的路径。 3. 设置密码短语（可选）接下来会提示你输入一个 密码短语。这个密码用于保护私钥，你可以选择设置一个密码，或者直接按 Enter 跳过设置密码短语。 4. 添加 SSH 密钥到 SSH 代理生成完密钥后，接下来需要将 SSH 密钥添加到 SSH 代理。首先启动 SSH 代理，并将密钥加载到代理中。 运行以下命令启动 SSH 代理： 1eval $(ssh-agent -s) 然后，添加你的私钥（默认为 id_rsa）到 SSH 代理： 1ssh-add ~/.ssh/id_rsa 5. 复制公钥到剪贴板接下来，你需要将公钥复制到剪贴板，以便将其添加到 GitHub。 运行以下命令来显示公钥： 1cat ~/.ssh/id_rsa.pub 将显示的公钥内容复制到剪贴板，按下 Ctrl + C 或右键点击 PowerShell 窗口并选择 复制。 6. 将公钥添加到 GitHub 登录到 GitHub。 点击右上角的头像，然后选择 Settings。 在左侧菜单中，点击 SSH and GPG keys。 点击 New SSH key。 在 Title 字段中，为你的 SSH 密钥命名（例如：“Windows SSH Key”）。 将刚才复制的公钥粘贴到 Key 字段中。 点击 Add SSH key。 7. 测试 SSH 连接完成上述步骤后，测试 SSH 连接是否成功： 1ssh -T git@github.com 如果是第一次连接，可能会看到如下提示，询问你是否信任 GitHub 的服务器： 12The authenticity of host 'github.com (IP_ADDRESS)' can't be established.Are you sure you want to continue connecting (yes/no)? 输入 yes 后继续。 如果成功连接，你将看到类似以下的消息： 1Hi username! You've successfully authenticated, but GitHub does not provide shell access. 8. 配置 Git 使用 SSH最后，确保你的 Git 配置使用 SSH 而不是 HTTPS 进行推送和拉取操作。可以检查你的远程 URL： 1git remote -v 如果显示的 URL 是类似于 https://github.com/username/repository.git，你可以将它改成 SSH 版本： 1git remote set-url origin git@github.com:username/repository.git 总结：现在你已经重新生成了 SSH 密钥，并将其添加到 GitHub 上。通过 SSH 进行 Git 操作时，应该不会再遇到需要输入用户名和密码的问题。如果有任何问题，可以再次联系我！","link":"/%E5%BB%BA%E7%AB%99%E7%9B%B8%E5%85%B3/Hexo%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/use-of-theme/"},{"title":"诗词歌赋","text":"哲理菩提偈惠能 唐代 菩提本无树，明镜亦非台。佛性常清净，何处有尘埃！ 身是菩提树，心为明镜台。明镜本清净，何处染尘埃！ 菩提本无树，明镜亦非台。本来无一物，何处惹尘埃！ 菩提只向心觅，何劳向外求玄？听说依此修行，西方只在目前！ 诀别卜算子·赠乐婉杭妓施酒监 宋代 相逢情便深，恨不相逢早。识尽千千万万人，终不似、伊家好。别你登长道。转更添烦恼。楼外朱楼独倚阑，满目围芳草。 卜算子·答施乐婉 宋代 相思似海深，旧事如天远。泪滴千千万万行，更使人、愁肠断。要见无因见，拚了终难拚。若是前生未有缘，待重结、来生愿。 山歌·亲老婆冯梦龙 明代 天上星多月弗多。雪白样雄鸡当弗得个鹅。煮粥煮饭还是自家田里个米。有病还需亲老婆。忽然道学。还是无病的日子多。","link":"/%E5%A4%A9%E9%A9%AC%E8%A1%8C%E7%A9%BA/%E8%AF%97%E8%AF%8D%E6%AD%8C%E8%B5%8B/poems/"}],"tags":[],"categories":[{"name":"力扣","slug":"力扣","link":"/categories/%E5%8A%9B%E6%89%A3/"},{"name":"力扣热门100","slug":"力扣/力扣热门100","link":"/categories/%E5%8A%9B%E6%89%A3/%E5%8A%9B%E6%89%A3%E7%83%AD%E9%97%A8100/"},{"name":"贪心算法","slug":"力扣/力扣热门100/贪心算法","link":"/categories/%E5%8A%9B%E6%89%A3/%E5%8A%9B%E6%89%A3%E7%83%AD%E9%97%A8100/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"},{"name":"图论","slug":"力扣/力扣热门100/图论","link":"/categories/%E5%8A%9B%E6%89%A3/%E5%8A%9B%E6%89%A3%E7%83%AD%E9%97%A8100/%E5%9B%BE%E8%AE%BA/"},{"name":"链表","slug":"力扣/力扣热门100/链表","link":"/categories/%E5%8A%9B%E6%89%A3/%E5%8A%9B%E6%89%A3%E7%83%AD%E9%97%A8100/%E9%93%BE%E8%A1%A8/"},{"name":"技巧","slug":"力扣/力扣热门100/技巧","link":"/categories/%E5%8A%9B%E6%89%A3/%E5%8A%9B%E6%89%A3%E7%83%AD%E9%97%A8100/%E6%8A%80%E5%B7%A7/"},{"name":"多维动态规划","slug":"力扣/力扣热门100/多维动态规划","link":"/categories/%E5%8A%9B%E6%89%A3/%E5%8A%9B%E6%89%A3%E7%83%AD%E9%97%A8100/%E5%A4%9A%E7%BB%B4%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"二分查找","slug":"力扣/力扣热门100/二分查找","link":"/categories/%E5%8A%9B%E6%89%A3/%E5%8A%9B%E6%89%A3%E7%83%AD%E9%97%A8100/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"name":"二叉树","slug":"力扣/力扣热门100/二叉树","link":"/categories/%E5%8A%9B%E6%89%A3/%E5%8A%9B%E6%89%A3%E7%83%AD%E9%97%A8100/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"数组","slug":"力扣/力扣热门100/数组","link":"/categories/%E5%8A%9B%E6%89%A3/%E5%8A%9B%E6%89%A3%E7%83%AD%E9%97%A8100/%E6%95%B0%E7%BB%84/"},{"name":"双指针","slug":"力扣/力扣热门100/双指针","link":"/categories/%E5%8A%9B%E6%89%A3/%E5%8A%9B%E6%89%A3%E7%83%AD%E9%97%A8100/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"动态规划","slug":"力扣/力扣热门100/动态规划","link":"/categories/%E5%8A%9B%E6%89%A3/%E5%8A%9B%E6%89%A3%E7%83%AD%E9%97%A8100/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"回溯","slug":"力扣/力扣热门100/回溯","link":"/categories/%E5%8A%9B%E6%89%A3/%E5%8A%9B%E6%89%A3%E7%83%AD%E9%97%A8100/%E5%9B%9E%E6%BA%AF/"},{"name":"堆","slug":"力扣/力扣热门100/堆","link":"/categories/%E5%8A%9B%E6%89%A3/%E5%8A%9B%E6%89%A3%E7%83%AD%E9%97%A8100/%E5%A0%86/"},{"name":"滑动窗口","slug":"力扣/力扣热门100/滑动窗口","link":"/categories/%E5%8A%9B%E6%89%A3/%E5%8A%9B%E6%89%A3%E7%83%AD%E9%97%A8100/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"},{"name":"栈","slug":"力扣/力扣热门100/栈","link":"/categories/%E5%8A%9B%E6%89%A3/%E5%8A%9B%E6%89%A3%E7%83%AD%E9%97%A8100/%E6%A0%88/"},{"name":"矩阵","slug":"力扣/力扣热门100/矩阵","link":"/categories/%E5%8A%9B%E6%89%A3/%E5%8A%9B%E6%89%A3%E7%83%AD%E9%97%A8100/%E7%9F%A9%E9%98%B5/"},{"name":"子串","slug":"力扣/力扣热门100/子串","link":"/categories/%E5%8A%9B%E6%89%A3/%E5%8A%9B%E6%89%A3%E7%83%AD%E9%97%A8100/%E5%AD%90%E4%B8%B2/"},{"name":"哈希","slug":"力扣/力扣热门100/哈希","link":"/categories/%E5%8A%9B%E6%89%A3/%E5%8A%9B%E6%89%A3%E7%83%AD%E9%97%A8100/%E5%93%88%E5%B8%8C/"},{"name":"算法","slug":"算法","link":"/categories/%E7%AE%97%E6%B3%95/"},{"name":"JAVA","slug":"JAVA","link":"/categories/JAVA/"},{"name":"力扣每日一题","slug":"力扣/力扣每日一题","link":"/categories/%E5%8A%9B%E6%89%A3/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"name":"天马行空","slug":"天马行空","link":"/categories/%E5%A4%A9%E9%A9%AC%E8%A1%8C%E7%A9%BA/"},{"name":"建站相关","slug":"建站相关","link":"/categories/%E5%BB%BA%E7%AB%99%E7%9B%B8%E5%85%B3/"},{"name":"LRU与LFU缓存替换","slug":"算法/LRU与LFU缓存替换","link":"/categories/%E7%AE%97%E6%B3%95/LRU%E4%B8%8ELFU%E7%BC%93%E5%AD%98%E6%9B%BF%E6%8D%A2/"},{"name":"JAVA基础知识点","slug":"JAVA/JAVA基础知识点","link":"/categories/JAVA/JAVA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"name":"JAVA基础","slug":"JAVA/JAVA基础","link":"/categories/JAVA/JAVA%E5%9F%BA%E7%A1%80/"},{"name":"JAVA常用API","slug":"JAVA/JAVA常用API","link":"/categories/JAVA/JAVA%E5%B8%B8%E7%94%A8API/"},{"name":"诗词歌赋","slug":"天马行空/诗词歌赋","link":"/categories/%E5%A4%A9%E9%A9%AC%E8%A1%8C%E7%A9%BA/%E8%AF%97%E8%AF%8D%E6%AD%8C%E8%B5%8B/"},{"name":"乐理","slug":"天马行空/乐理","link":"/categories/%E5%A4%A9%E9%A9%AC%E8%A1%8C%E7%A9%BA/%E4%B9%90%E7%90%86/"},{"name":"Hexo常用指令","slug":"建站相关/Hexo常用指令","link":"/categories/%E5%BB%BA%E7%AB%99%E7%9B%B8%E5%85%B3/Hexo%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/"},{"name":"基本数据类型","slug":"JAVA/JAVA基础知识点/基本数据类型","link":"/categories/JAVA/JAVA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"name":"位运算","slug":"JAVA/JAVA基础/位运算","link":"/categories/JAVA/JAVA%E5%9F%BA%E7%A1%80/%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"name":"优先队列","slug":"JAVA/JAVA常用API/优先队列","link":"/categories/JAVA/JAVA%E5%B8%B8%E7%94%A8API/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"}],"pages":[{"title":"文章分类","text":"","link":"/categories/index.html"}]}